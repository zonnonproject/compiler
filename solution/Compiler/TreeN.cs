//-----------------------------------------------------------------------------
//
//  Copyright (c) 2000-2013 ETH Zurich (http://www.ethz.ch) and others.
//  All rights reserved. This program and the accompanying materials
//  are made available under the terms of the Microsoft Public License.
//  which accompanies this distribution, and is available at
//  http://opensource.org/licenses/MS-PL
//
//  Contributors:
//    ETH Zurich, Native Systems Group - Initial contribution and API
//    http://zonnon.ethz.ch/contributors.html
//
//-----------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Compiler;
using System.Xml;

using ZonnonHalt     = Zonnon.RTL.Halt;
using ZonnonAttribute = Zonnon.RTL.ZonnonAttribute;
using ETH.Zonnon.Compute;

namespace ETH.Zonnon {
    /// <summary>
    /// Represents leafs of AST. Correspond to sealed classes only.
    /// </summary>
    public enum ASTNodeType {
        STATEMENT_LIST,
        IDENT_LIST,
        COMMENT,
        COMMENT_LIST,        
        IF_PAIR,        
        CASE_ITEM,
        RANGE,
        EXCEPTION,
        // Group TYPE:
            ANY_TYPE,
            UNKNOWN_TYPE,
            ARRAY_TYPE,
            SET_TYPE,
            RANGE_TYPE,
            INTERFACE_TYPE,
            OBJECT_TYPE,
            ACTIVITY_TYPE,
            ABSTRACT_ACTIVITY_TYPE,
            INTEGER_TYPE,
            REAL_TYPE,
            FIXED_TYPE,
            CHAR_TYPE,
            STRING_TYPE,
            CARDINAL_TYPE,
            BOOLEAN_TYPE,
            VOID_TYPE,
            ENUM_TYPE,
            PROC_TYPE,
            EXTERNAL_TYPE,            
        SPARSE_TYPE,
        MATH_TYPE,
        // Group EXPRESSION:            
            // Sub Group UNARY:
                NEGATION,
                UNARY_MINUS,
                UNARY_PLUS,
                TYPE_CONV,
            // Sub Group BINARY:
                ASSIGNMENT_OPERATOR,
                PLUS,
                MINUS,
                MULTIPLY,
                MULTIPLY_ELEMENTWISE,
                DIVIDE,
                DIVIDE_ELEMENTWISE,
                PSEUDO_SCALAR_PRODUCT,
                TRANSPOSE,
                EXPR_ARRAY_ASSIGNMENT,
                RANGESTEP,
                ARRAY_RANGE,
                LEFTDIVISION,
                DIV,
                MOD,
                EXPONENT,
                AND,
                OR,
                // Sub Sub Group RELATION
                    EQUAL,
                    NON_EQUAL,
                    LESS,
                    LESS_EQUAL,
                    GREATER,
                    GREATER_EQUAL,
                    EQUAL_ELEMENTWISE,
                    NON_EQUAL_ELEMENTWISE,
                    LESS_ELEMENTWISE,
                    LESS_EQUAL_ELEMENTWISE,
                    GREATER_ELEMENTWISE,
                    GREATER_EQUAL_ELEMENTWISE,
                    IN,
                    IMPLEMENTS,
                    IS,
            // Sub Group DESIGNATOR:
                    DEREFERENCE,
                    INDEXER,
                    SELECTOR,
                    SAFEGUARD,
                    CALL,
                    SET_CTOR,
                    NEW,
                    SELF,
                    OBJECT,
                    INSTANCE,
                    //Sub Sub Group LITERAL:
                        ENUMERATOR,
                        STRING_LITERAL,
                        CHAR_LITERAL,
                        INTEGER_LITERAL,
                        REAL_LITERAL,
                        CCI_LITERAL,
                        NULL,
        // Group STATEMENT:
            ASSIGNMENT,
            CALL_STMT,
            EXIT,
            RETURN,
            REPLY,
            AWAIT,
            SEND_RECEIVE,
            LAUNCH,
            ACCEPT,
            IF,
            CASE,
            BLOCK,
            // Sub Group CYCLE:
                FOR,
                WHILE,
                REPEAT,
                LOOP,
        // Group DECLARATION:
            // Sub Group UNIT_DECL:
                UNKNOWN_DECL,
                EXTERNAL_DECL,
                NAMESPACE_DECL,
                IMPORTSPACE_DECL,
                MODULE_DECL,
                OBJECT_DECL,
                DEFINITION_DECL,
                IMPLEMENTATION_DECL,                                               
            // Sub Group ROUTINE_DECL:
                PROCEDURE_DECL,
                OPERATOR_DECL,
                ACTIVITY_DECL,
            // Sub Group SIMPLE_DECL:
                IMPORT_DECL,
                // SUb Sub Group VARIABLE_DECL:
                    PARAMETER_DECL,
                    LOCAL_DECL,
                    FIELD_DECL,
                CONSTANT_DECL,
                TYPE_DECL,
                ENUMERATOR_DECL,
                PROTOCOL_DECL,
        // Group EXTENSION
            SYNTAX,
            PRODUCTION,
            // Sub Group UNIT:
                TERMINAL,
                TYPE_NAME,
                CONSTANT,
                NONTERMINAL,
                UNKNOWN_NONTERMINAL,
                SEQUENCE,
                ALTERNATIVES
    }

    public abstract class NODE {
        private static int global_unique = 0;
        private        int this_unique;
        public         int unique { get { return this_unique; } }

        /// <summary>
        /// A scalar tag that identifies the concrete type of the node. 
        /// This is provided to allow efficient type membership tests that 
        /// facilitate tree traversal.
        /// </summary>
        public ASTNodeType ASTNodeType;

        private NODE() { }

        public NODE(ASTNodeType astNodeType) {
            this.ASTNodeType = astNodeType;
            this_unique = ++global_unique;
            this.modifiers = new MODIFIERS();
            this.ErrorReported = false;
        }

        public NODE(ASTNodeType astNodeType, Identifier name) {
            this.ASTNodeType = astNodeType;

            this_unique = ++global_unique;
            this.name = name;

            if ( name != null )
                this.sourceContext = name.SourceContext;
            else if ( Parser.LEXAN != null )  // can be null at the very beginning
                this.sourceContext = Parser.LEXAN.getSourceContext();

            this.modifiers = new MODIFIERS();
            this.ErrorReported = false;
        }

        //----------------------------------------------------------------

        public SourceContext sourceContext;
        public Identifier    name;
        public string Name { get {
            if (this is UNKNOWN_DECL && ((UNKNOWN_DECL)this).RealDeclaration != null)
                if (((UNKNOWN_DECL)this).RealDeclaration.name != null)
                    return ((UNKNOWN_DECL)this).RealDeclaration.name.Name;
                else
                    return ((UNKNOWN_DECL)this).RealDeclaration.sourceContext.SourceText;

            return ((this.name != null) ? this.name.Name : this.sourceContext.SourceText);                        
        } }
        public IDENT_LIST    full_name;
        public MODIFIERS     modifiers;

        public NODE          enclosing;

        private bool          errorReported;
        public bool ErrorReported {
            set {
                errorReported = value;
            }
            get {
                return errorReported || containsErrorReport();                
            }
        }

        protected virtual bool containsErrorReport() {
            return false;
        }

		public COMMENT_LIST	 comments;

        //-----------------------------------------------------------------

        public virtual NODE find ( Identifier name ) { return null; }

        /// <summary>
        /// If for a paricular type find ncludes outer scopes. findLocal searchs only within the
        /// scope
        /// </summary>
        public virtual NODE findLocal(Identifier name)  { return find(name); }

        //-----------------------------------------------------------------

        public Node node = null;

        public abstract Node convert ( ); // Converts our own NODE to a corresponding CCI Node.

        public Node convertAndGetType() {
            convert();
            if (node is Namespace)
                return ((Namespace)node).Types[0];
            else
                return node;
        }

        //-----------------------------------------------------------------

        public static string generateFullName(NODE node) {
            string s = "";

            if (node == null)
                return "";

            if (node.enclosing != null && node.enclosing != CONTEXT.globalTree)
                s = generateFullName(node.enclosing) + ".";

            if (node is EXTERNAL_DECL
                && (((EXTERNAL_DECL)node).entity is Member))
                return s + ((Member)((EXTERNAL_DECL)node).entity).FullName;

            return s + node.Name;
        }

        //-----------------------------------------------------------------

        protected static Expression convertTypeName(NODE node) {
            if (node.enclosing == null)
                return node.name;

            QualifiedIdentifier qualId = new QualifiedIdentifier();
            qualId.Identifier = node.name;
            qualId.Qualifier  = convertTypeName(node.enclosing);

            return qualId;
        }

        //-----------------------------------------------------------------

        public static bool isBuiltIn(string name) {
			if (name == STANDARD.WriteLn.name.ToString())
				return true;
			if (name == STANDARD.Write.name.ToString())
				return true;
			if (name == STANDARD.ReadLn.name.ToString())
				return true;
			if (name == STANDARD.Read.name.ToString())
				return true;
			if (name == STANDARD.True.name.ToString())
				return true;
			if (name == STANDARD.False.name.ToString())
				return true;
			if (name == STANDARD.Integer.name.ToString())
				return true;
			if (name == STANDARD.Real.name.ToString())
                    return true;
            if (name == STANDARD.Char.name.ToString())
                    return true;
            if (name == STANDARD.String.name.ToString())
                    return true;
            if (name == STANDARD.Boolean.name.ToString())
                    return true;
			if (name == STANDARD.Abs.name.ToString())
                    return true;
            if (name == STANDARD.Assert.name.ToString())
                    return true;
            if (name == STANDARD.Cap.name.ToString())
                    return true;
            if (name == STANDARD.Copy.name.ToString())
                    return true;
			if (name == STANDARD.Set.name.ToString())
					return true;
            if (name == STANDARD.Range.name.ToString())
                    return true;
            //if (name == STANDARD.copyvalue
            //        return true;
            if (name == STANDARD.Dec.name.ToString())
                    return true;
            if (name == STANDARD.Excl.name.ToString())
                    return true;
            if (name == STANDARD.Halt.name.ToString())
                    return true;
            if (name == STANDARD.Inc.name.ToString())
                    return true;
            if (name == STANDARD.Incl.name.ToString())
                    return true;
            if (name == STANDARD.Len.name.ToString())
                    return true;
            if (name == STANDARD.Low.name.ToString())
                    return true;
            if (name == STANDARD.Max.name.ToString())
                    return true;
            if (name == STANDARD.Min.name.ToString())
                    return true;
            if (name == STANDARD.Odd.name.ToString())
                    return true;
            if (name == STANDARD.Pred.name.ToString())
                    return true;
            //if (name == STANDARD.reason"):
            //        return true;
            if (name == STANDARD.Size.name.ToString())
                    return true;
            if (name == STANDARD.Succ.name.ToString())
                    return true;
			return false;
        }

        //-----------------------------------------------------------------

        public UNIT_DECL getEnclosingUnit() {
            NODE n = this.enclosing;
         
            while ((n != null) && !(n is UNIT_DECL) || n is IMPORTSPACE_DECL)
                    n = n.enclosing;
            return (UNIT_DECL)n;
        }

        public DECLARATION getEnclosingDeclaration() {
            NODE n = this.enclosing;

            while ((n != null) && !(n is DECLARATION))
                n = n.enclosing;
            return (DECLARATION)n;
        }

        public bool IsTopLevelUnit() {
            NODE n = this.enclosing;

            while ((n != null) && !(n is MODULE_DECL) && !(n is OBJECT_DECL))
                n = n.enclosing;
            return n == null; //Top most
        }

        public BLOCK getEnclosingBlock() {
            NODE n = this.enclosing;

            while ((n != null) && !(n is BLOCK))
                    n = n.enclosing;
            return (BLOCK)n;
        }
        //-----------------------------------------------------------------

        public abstract bool validate ( );   // Checks semantical correctness of the node.

        //-----------------------------------------------------------------

        // The "universal" field; it can be unnecessary for some classes
        // derived from NODE but in most cases it's an important characteristics
        // of the enitiy represented by the node.

        protected TYPE internal_type = null;

        public abstract TYPE type { get; set; }   // Evaluates and returns the type of the node.

        //-----------------------------------------------------------------

        // The function traverses the subtree with the given node as the root
        // trying to resolve all unknown nodes (i.e., to replace them for
        // known equivalents).

        public abstract NODE resolve ( );

        //----------------------------------------------------------------

        // For preparing main dialogue program in case of 'EmbeddedDialogue' mode.
        // Images for all program modules are collected here after compilation.
        protected static TypeNodeList modules = new TypeNodeList();

        //public static void prepare ( Node ns )
        //{
        //    if ( !CONTEXT.options.EmbeddedDialogue ) return;

        //    Class start = new Class();
        //    start.Members = new MemberList();
        //    start.DeclaringModule = CONTEXT.symbolTable;
        //    CONTEXT.symbolTable.Types.Add(start);
        //    start.Name = Identifier.For("_start");
        //    start.Namespace = Identifier.For(NODE.generateFullName(CONTEXT.globalTree));
        //    start.Flags |= TypeFlags.Public | TypeFlags.Sealed;

        //    Method main = new Method();

        //    main.Body = new Block(new StatementList());
        //    main.DeclaringType = start;
        //    main.Flags |= MethodFlags.Static | MethodFlags.Public;
        //    main.Parameters = new ParameterList();
        //    main.ReturnType = SystemTypes.Int32;
        //    main.Name = Identifier.For("Main");

        //    MethodCall call = new MethodCall();
        //    call.Type = SystemTypes.Void;
        ////  call.Callee = new QualifiedIdentifier(
        ////                      new QualifiedIdentifier(
        ////                            new QualifiedIdentifier(Identifier.For("Zonnon"),
        ////                                                    Identifier.For("RTL")),
        ////                            Identifier.For("_start")),
        ////                      Identifier.For("_dialogue"));

        //    TypeNode _start = AssemblyNode.GetAssembly(typeof(Starter).Assembly).GetType(Identifier.For("Zonnon.RTL"),Identifier.For("_start"));
        //    MemberBinding mb = new MemberBinding(null,_start);
        //    call.Callee = new QualifiedIdentifier(mb,Identifier.For("_dialogue"));

        //    call.Operands = new ExpressionList();
        //    call.Operands.Add(new Literal(false,SystemTypes.Boolean));
        //    call.Operands.Add(new Literal(CONTEXT.options.SafeMode,SystemTypes.Boolean));
        //    call.Operands.Add(new Literal(CONTEXT.options.Output,SystemTypes.String));
        //    for ( int i=0, n=modules.Length; i<n; i++ )
        //    {
        //        call.Operands.Add(new Literal(modules[i].FullName,SystemTypes.String));
        //    }

        //    main.Body.Statements.Add(new ExpressionStatement(call));

        //    start.Members.Add(main);

        //    ((Namespace)ns).Types.Add(start);
        //}

        //-----------------------------------------------------------------

        public void setLeftContext  ( SourceContext left  ) { this.sourceContext.StartPos = left.StartPos; }
        public void setRightContext ( SourceContext right ) { this.sourceContext.EndPos   = right.EndPos;  }

        public void setContext(NODE node) {
            if (node == null)
                return;
            this.sourceContext = node.sourceContext; 
        }
        public void setContext ( SourceContext context ) { this.sourceContext = context; }

        public void setContext(SourceContext left, SourceContext right) {
            this.sourceContext.Document = left.Document;
            this.sourceContext.StartPos = left.StartPos;
            this.sourceContext.EndPos   = right.EndPos;
        }

        public void setContextExcludingLast(SourceContext left, SourceContext right) {
            this.sourceContext.Document = left.Document;
            this.sourceContext.StartPos = left.StartPos;
            this.sourceContext.EndPos = right.EndPos-1;
        }

        public void setContext(NODE left, NODE right) {
            if (left == null && right == null)
                return;
            if (left == null && right != null)
                setContext(right);
            else if (right == null && left != null)
                setContext(left);
            else {
                this.sourceContext.StartPos = left.sourceContext.StartPos;
                this.sourceContext.EndPos   = right.sourceContext.EndPos;
            }
        }

        public NODE findScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            if (CONTEXT.globalTree == this || this is NAMESPACE_DECL ||
                (sourceContext.StartLine < line || (sourceContext.StartLine == line && sourceContext.StartColumn <= col))
                && (sourceContext.EndLine > line || (sourceContext.EndLine == line && sourceContext.EndColumn >= col)
                ) && (sourceContext.Document.Name == documentName)
                ) {
                scope = (this is NAMESPACE_DECL)? null : this;
                // We're in this scope. Then we can try and find subscopes
                NODE subscope = findSubScopeAtContext(line, col, documentName);
                if (subscope != null)
                    scope = subscope;
            }            
            return scope;
        }

        /// <summary>
        /// This function supposed to call findScopeAtContext for each sub
        /// </summary>
        /// <returns>first non null result of the call to findScopeAtContext or null</returns>
        protected virtual NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            return null;
        }

        public string generateXPath() {
            NODE parent;
            string temp = "";
            string str = "";
            parent = this;
            if ((parent.enclosing != null) && (parent.enclosing.name != null) && (parent.enclosing != CONTEXT.globalTree)) {
                parent = parent.enclosing;
                temp = parent.generateXPath();
            }
            if (this is NAMESPACE_DECL)
                str = "namespace";
            else if (this is MODULE_DECL)
                str = "module";
            else if (this is OBJECT_DECL)
                if (this.enclosing is NAMESPACE_DECL)
                    str = "object";
                else
                    str = "declarations_object";
            else if (this is DEFINITION_DECL)
                if (this.enclosing is NAMESPACE_DECL)
                    str = "definition";
                else
                    str = "declarations_definition";
            else if (this is IMPLEMENTATION_DECL)
                if (this.enclosing is NAMESPACE_DECL)
                    str = "implementation";
                else
                    str = "declarations_implementation";
            else if (this is VARIABLE_DECL) {
                if (this is PARAMETER_DECL)
                    str = "parameters_parameter";
                else if (this is FIELD_DECL)
                    str = "declarations_field";
                else if (this is LOCAL_DECL)
                    str = "declarations_local";
                else
                    str = "var";
            } else if (this is CONSTANT_DECL)
                str = "declarations_constantdeclaration";

            else if (this is ENUMERATOR_DECL)
                if (this.enclosing is PROTOCOL_DECL)
                    str = "declarations_protocol_enum";
                else
                    str = "declarations_typedeclaration_" + enclosing.enclosing.name + "_enum_enumeratordeclaration";
            else if (this is PROCEDURE_DECL)
                str = "declarations_procedure";
            else if (this is OPERATOR_DECL)
                str = "declarations_operator";
            else if (this is TYPE_DECL) {
                str = "declarations_typedeclaration";
            }
            
            if (str != "")
                return temp + "_" + str + "_" + this.name;
            else
                return temp + "_" + this.name;
        }



        //-----------------------------------------------------------------
#if DEBUG
        public static int reportShift = 4;

        public static void doShift(int shift) {
            for (int i = 0; i < shift; i++)
                System.Console.Write(" ");
        }

        public static void doShift(int shift, System.IO.StreamWriter fileWriter) {
            for (int i = 0; i < shift; i++) 
                fileWriter.Write(" ");
        }

        public void report_unique ( int shift )   // <UN>:
        {
            doShift(shift);
            System.Console.Write("{0}: ",this_unique);
        }

        public void report_extra() {
            System.Console.Write("; OWNER=");
            if ( enclosing == null )
                System.Console.Write("null");
            else {
                System.Console.Write("{0}:",enclosing.unique);
                if ( enclosing.name != null )
                    System.Console.Write("{0}",enclosing.name.Name);
                else
                    System.Console.Write("unnamed");
            }
            System.Console.WriteLine();
        }

        public abstract void report ( int shift );

        public virtual void report_short() {
            if (this is NAMESPACE_DECL)
                ((NAMESPACE_DECL)this).report_short();
            else if (this is UNIT_DECL)
                ((UNIT_DECL)this).report_short();
            else if (this is IMPORT_DECL)
                ((IMPORT_DECL)this).report_short();
        }
#endif
    }

	// ==================================================================================
	// COMMENTS
	// ==================================================================================

    public class COMMENT : NODE {
		public string str;

		public NODE context;
		public NODE	owner;

        public COMMENT()
            : base(ASTNodeType.COMMENT, null) {
			
		}

        public COMMENT(NODE owner)
            : base(ASTNodeType.COMMENT, null) {
			if ( CONTEXT.current_unit == null ) // global unit
				this.context = CONTEXT.globalTree;  // Zonnon namespace
			else
				this.context = CONTEXT.current_unit;

			setEnvironment(owner);
		}

        public void setEnvironment(NODE owner) {
            if (owner != null) {
				this.owner = owner;
            } else
				this.owner = this.context;

            if (this.owner.comments == null) {
				this.owner.comments = new COMMENT_LIST();
			}

			this.owner.comments.Add(this);
		}

        public override Node convert() {
			return null;
		}

#if DEBUG
        public override void report(int shift) {
			report_unique(shift);
			System.Console.Write("COMMENT line={0}, \"{1}\"", this.sourceContext.StartLine.ToString(), str);
			if (owner != null)
				System.Console.Write("; owner={0}", owner.unique);
			System.Console.WriteLine();
		}
#endif

        public override NODE resolve() {
			return null;
		}
		
		/*
		public static COMMENT create ( string comment )
		{
			COMMENT Comment = new COMMENT();
			// String.enclosing
			// String.modifiers
			// String.name
			// String.operator_kind
			// String.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor
			// String.type
			Comment.str = "";
			for ( int i=0, n=comment.Length; i<n; i++ )
				Comment.str += comment[i];

			return Comment;
		}
		*/

		public override bool validate ( )  // checks semantical correctness
		{
			return true;
		}
		
		public override TYPE type { get { return null; } set { } }
	}

	public sealed class COMMENT_LIST : NODE ///////////////////////////////////////
	{
		public override Node convert ( ) { return null; }
		public override bool validate ( ) { return true; }
		public override TYPE type { get{return null;} set{} }
		public override NODE resolve ( ) { return null; }
		
#if DEBUG
		public override void report ( int shift ) { }
#endif

		private COMMENT[] commentlist;
		private int length = 0;

		public COMMENT_LIST (       ) : base(ASTNodeType.COMMENT_LIST, null) { this.commentlist = new COMMENT[8]; }
		public COMMENT_LIST ( int n ) : base(ASTNodeType.COMMENT_LIST, null) { this.commentlist = new COMMENT[n]; }

        public void Add(COMMENT comment) {
			int n = this.commentlist.Length;
			int i = this.length++;
            if (i == n) {
				COMMENT[] new_comments = new COMMENT[n+8];
                for (int j = 0; j < n; j++)
                    new_comments[j] = commentlist[j];
				this.commentlist = new_comments;
			}
			this.commentlist[i] = comment;
		}

        public int Length {
            get { return this.length; }
			set { this.length = value; } 
		}

        public COMMENT this[int index] {
            get { return this.commentlist[index]; }
			set { this.commentlist[index] = value; } 
		}

	}

    // ==================================================================================
    // 1 DECLARATIONS
    // ==================================================================================

    // DECLARATION
    // ===========
    // The common abstraction for kinds of Zonnon declarations:
    // either unit declarations (including namespace declarations)
    // or "simple" declarations such as variables, types, constants etc.
    //
    public abstract class DECLARATION : NODE {
        public DECLARATION (ASTNodeType astNodeType, Identifier name ) : base(astNodeType, name) { }

        public abstract override NODE resolve ( );
        public abstract override bool validate ( );
        public abstract override TYPE type { get; set; }
        public abstract override Node convert ( );

        public override string ToString() {
            return "<"+base.ASTNodeType.ToString()+" name = \""+Name+"\"/>";
        }

		/* 
		 * This method is used for XML Processing only and returns the full qualified name of
		 * an entity. As imports are not renamed in XML dumps any more, this method simply
		 * compares the names of enclosing entities, i.e:
		 * If we have a declaration that uses an objecttype, we have to find out, whether 
		 * declaration and object are within the same module. If so, the name does not need
		 * to be qualified (although: if the enclosing unit is imported, then renaming would
		 * be correct). Otherwise, we have to deal with an importedunit and will have to use
		 * the fully qualified name.
		 */
        public static string resolveObjectTypeNameInDeclaration(OBJECT_TYPE type, NODE declaration) {
			ArrayList declUnits = new ArrayList();
			ArrayList typeUnits = new ArrayList();

			UNIT_DECL tunit = (UNIT_DECL)type.ObjectUnit;
			typeUnits.Add(tunit);

			string tunits = type.ObjectUnit.name.ToString(); // This variable will hold the full qualified name of the type unit
			// UNIT_DECL firstUnit = null;
			// firstUnit = declaration.getEnclosingUnit();

            while (tunit.enclosing != CONTEXT.globalTree) {
				tunit = tunit.getEnclosingUnit();
				typeUnits.Add(tunit);
				tunits = tunit.name.ToString() + "." + tunits;
			}

			UNIT_DECL thisunit = declaration.getEnclosingUnit();
            if (thisunit != null) {
				declUnits.Add(thisunit);

                while ((thisunit.enclosing != CONTEXT.globalTree) && !(thisunit.getEnclosingUnit() is NAMESPACE_DECL)) {
					thisunit = thisunit.getEnclosingUnit();
					declUnits.Add(thisunit);
				}

				// We have to deal with an imported unit
                if (!(tunit.name.ToString().Equals(thisunit.name.ToString()))) {
					return tunits;
                } else
					//if (declaration is ARRAY_TYPE)
					//	return null;
					return type.ObjectUnit.name.ToString();
            } else
				return tunits;
		}

		/*
		 * Do the same as above, but for expressions, i.e. this is mostly used by NEW
		 * */
        public static string resolveObjectTypeNameInExpression(OBJECT_TYPE type, NODE expression) {
			ArrayList declUnits = new ArrayList();
			ArrayList typeUnits = new ArrayList();

			UNIT_DECL tunit = (UNIT_DECL)type.ObjectUnit;
			typeUnits.Add(tunit);

			string tunits = type.ObjectUnit.name.ToString(); // This variable will hold the full qualified name of the unit

            while (tunit.enclosing != CONTEXT.globalTree) {
				tunit = tunit.getEnclosingUnit();
				typeUnits.Add(tunit);
				tunits = tunit.name.ToString() + "." + tunits;
			}

			UNIT_DECL thisunit = expression.getEnclosingUnit();	

            if (thisunit != null) {
                while ((thisunit.enclosing != CONTEXT.globalTree) && !(thisunit.getEnclosingUnit() is NAMESPACE_DECL)) {
					thisunit = thisunit.getEnclosingUnit();
					declUnits.Add(thisunit);
				}

				// We have to deal with an imported unit
				//if (((UNIT_DECL)type.object_unit.enclosing).name != thisunit.name)
                if (!(tunit.name.ToString().Equals(thisunit.name.ToString()))) {
					return tunits;
                } else
					return type.ObjectUnit.name.ToString();
            } else
				return tunits;
		}

		/* 
		 * Finds out, whether the name of an interface needs to be qualified or not.
		 * Therefore, it compares the enclosing units.
		 */
        public static string resolveInterfaceTypeNameInDeclaration(INTERFACE_TYPE type, UNIT_DECL interfac, NODE declaration) {
            if (interfac != null) {
				DECLARATION tunit = interfac; 
				string tunits = tunit.name.ToString();
	                                
                while (tunit.getEnclosingUnit() != CONTEXT.globalTree) {
					tunit = tunit.getEnclosingUnit();
					tunits = tunit.name.ToString() + "." + tunits;
				}

                if (tunit.enclosing is NAMESPACE_DECL) {
                    while (tunit.enclosing != CONTEXT.globalTree) {
						tunit = tunit.getEnclosingUnit();
						tunits = tunit.name.ToString() + "." + tunits;
	                                        
					}
				}   
				UNIT_DECL thisunit = declaration.getEnclosingUnit();
				while (!(thisunit.getEnclosingUnit() is NAMESPACE_DECL))
					thisunit = thisunit.getEnclosingUnit();

				//The interfacedeclaration is not the in the same module
                if (!(tunits.StartsWith(thisunit.name.ToString())) && !(tunits.EndsWith(thisunit.name.ToString()))) {
					return tunits; // + "." + type.enclosing.name;
                } else
					return interfac.name.ToString();

				//return tunits;
			}
			return null;
		}

		/* 
		 * 
		 */
        public static string resolveExternalTypeNameInDeclaration(EXTERNAL_TYPE type, NODE declaration) {
			return type.entity.ToString();
		}

		/*
		 * Find out, whether a typename belongs to an import and needs to be
		 * qualified or not.
		 */
        public static string resolveTypeTypeNameInDeclaration(TYPE type, NODE declaration) {
			UNIT_DECL tunit = type.getEnclosingUnit();
			string tunits = type.getEnclosingUnit().name.ToString();
            while (tunit.getEnclosingUnit() != CONTEXT.globalTree) {
				tunit = tunit.getEnclosingUnit();
				// If the program has errors, the compiler might through an
				// exception here...
				if (tunit != null)
					tunits = tunit.name.ToString() + "." + tunits;
				else 
					return null;
			}
			UNIT_DECL thisunit = declaration.getEnclosingUnit();
            if (thisunit != null) {
				while (!(thisunit.getEnclosingUnit() is NAMESPACE_DECL))
					thisunit = thisunit.getEnclosingUnit();
			
				//The typedeclaration is not in the in the same module
                if (!(tunits.StartsWith(thisunit.name.ToString())) && !(tunits.EndsWith(thisunit.name.ToString()))) {
					return tunits + "." + type.enclosing.name;
                } else
					return type.enclosing.name.ToString();
            } else
                return null;
			}

#if DEBUG
        public abstract override void report ( int shift );
#endif
    }

    // ====================================================================================
    // 1.1 UNIT DECLARATIONS
    // ====================================================================================

    public abstract class UNIT_DECL : DECLARATION {
        // Attributes
        public LinkedList<string> imports = new LinkedList<string>();
        public string typestamp = "notset";

        /// <summary>
        /// activeBody can be set by any nested blocking operation to 
        /// inform convertion phase that body should be compiled as an activity
        /// </summary>
        public bool activeBody = false;

        // Constructor
        public UNIT_DECL(ASTNodeType astNodeType, Identifier name)
            : base(astNodeType, name) {
            locals = new DECLARATION_LIST();
            body   = new BLOCK();
            body.enclosing = this;
            imported_by = null;
        }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            for (int i = 0; i < locals.Length; i++)
            {
                if (locals[i] == null) continue;
                NODE scope = locals[i].findScopeAtContext(line, col, documentName);
                if (scope != null) return scope;
            }
            return null;
        }

        public override string ToString() {
            string nested = "";
            for (int i = 0; i < locals.Length; i++)
                if ((locals[i] is UNIT_DECL) || (locals[i] is IMPORT_DECL))
                    nested += locals[i].ToString();
            return "<" + base.ASTNodeType.ToString() + " name = \"" + Name + "\">" + nested + "</" + base.ASTNodeType.ToString() + ">";
        }
        //-----------------------------------------------------------

        public DECLARATION_LIST locals;  // imports, parameters, locals, procedures, nested units...
        public BLOCK            body;

        public IMPORT_DECL      imported_by;
        public List<string>  prefixesForMixed; 
		// used for XML generation in derived classes
		public XmlNode xmlUnitNode;

        //-----------------------------------------------------------

        public abstract NODE findExcludingDefs(Identifier name);

        public override NODE find(Identifier name) {
            if (this.name.Name == name.Name)
                return this; // Object is visible inside itself
            return locals.find(name, !IsTopLevelUnit());
        }

        public virtual NODE find_in_scope ( Identifier name )
        {
            bool excludeImportspace = true; // Hmm.. where did I modify it?
            NODE result = locals.find(name, excludeImportspace);            
            return result;
        }

        public NODE find_getter(Identifier name) {
            for (int i = 0, n = locals.Length; i < n; i++) {
                if (locals[i].name == null)
                    continue;
                if ( locals[i].name.Name == name.Name && locals[i].modifiers.Getter )
                    return locals[i];
            }
            return null;
        }

        public NODE find_setter(Identifier name) {
            for (int i = 0, n = locals.Length; i < n; i++) {
                if (locals[i].name == null)
                    continue;
                if ( locals[i].name.Name == name.Name && locals[i].modifiers.Setter )
                    return locals[i];
            }
            return null;
        }

        public void find_operators(OPERATOR_DECL_LIST opList, string sign, bool rec) {
            for (int i = 0, n = locals.Length; i < n; i++) {
                DECLARATION local = locals[i];
                if (local == null)
                    continue;
                if (local is OPERATOR_DECL && ((OPERATOR_DECL)local).code == sign) {
                    opList.Add((OPERATOR_DECL)local);
                    continue;
                }
                if (local is IMPORT_DECL && rec) {
                    IMPORT_DECL import = (IMPORT_DECL)local;
                    UNIT_DECL unit = import.imported_unit;
                    if (unit is MODULE_DECL)
                        unit.find_operators(opList, sign, false);
                    if (unit is EXTERNAL_DECL)
                        ((EXTERNAL_DECL)unit).findImportedOperators(opList, sign, false);
                }
            }
            UNIT_DECL encl = getEnclosingUnit();
            if (encl != null)
                encl.find_operators(opList, sign, rec);
        }

        // Is there an unnamed import declaration importing an entity
        // whose qualified name starts with 'member', e.g.:
        //
        //     IMPORT a.b.c.d;
        //            =
        // Notice that the current unit can be _local_ one;
        // so, we organize the search trough all enclosing units.
        //
        public DECLARATION findUnnamedImport(Identifier member) {
            UNIT_DECL unit = this;
            DECLARATION_LIST locals = this.locals;

            while (locals != null) {
                for (int i = 0, n = locals.Length; i < n; i++) {
                    DECLARATION local = locals[i];
                    if (local == null)
                        continue;
                    if (!(local is IMPORT_DECL))
                        continue;

                    IMPORT_DECL import = local as IMPORT_DECL;
                    if (import.name != null)
                        continue;

                    UNIT_DECL imported = import.imported_unit;
                    while ( imported.enclosing != CONTEXT.globalTree ) // !(imported.enclosing is NAMESPACE_DECL) )
                        imported = (UNIT_DECL)imported.enclosing;

                    if ( imported.name.Name == member.Name )
                        return imported;
                }
                if ( unit.enclosing is UNIT_DECL )  // the current unit is local
                {
                    unit = (UNIT_DECL)unit.enclosing;
                    locals = unit.locals;
                } else
                    locals = null;
            }
            return null;
        }

        // processName
        // -----------
        // The function processes (possibly qualified) name of a new program unit:
        //
        //        MODULE N1.N2.m; ...
        //        DEFINITION N.d; ...
        //        IMPLEMENTATION d; ...
        //        OBJECT o ...
        //
        // The function is called from the following four functions:
        //
        //        MODULE_DECL.create()
        //        DEFINITION_DECL.create()
        //        IMPLEMENTATION_DECL.create()
        //        OBJECT_DECL.create()
        //
        public static DECLARATION processName(UNIT_DECL unit, IDENT_LIST qual_id) {
            // The main purpose of this function is to create the entire context
            // for the unit: add all the enclosing namespaces to the context
            // (creating them before if they do not exist yet), AND to add new
            // program unit to that context.
            //
            // We treat the name of a compilation unit as _absolute_ just because
            // there are no (global) imports at all. This means, we consider only
            // unit names from the program tree.
            //
            // The first parameter carries the program unit which has been already
            // created by the caller. Again, out aim here is to build the context
            // and to add unit to it.

            // We have _qualified-id_ as the name of the compilation unit.
            // That is, the unit name consists of more than one identifier.

            if (CONTEXT.current_unit != null && qual_id.Length > 1) {
                // ERROR: nested unit should have simple name
                ERROR.QualIdInNestedUnit(qual_id.ToString());
                qual_id[0] = qual_id[qual_id.Length-1];
                qual_id.Length = 1;
                // return null;
            }

            // Consider all simple names from the qual-id except the unit name itself.

            UNKNOWN_DECL unknown = null;
            UNIT_DECL    ns      = null;

            if ( CONTEXT.current_unit == null ) // global unit
                ns = CONTEXT.globalTree;  // Zonnon namespace
            else  // nested unit
                ns = CONTEXT.current_unit;

            for (int i = 0, n = qual_id.Length; i < n - 1; i++) {
                // We search the very first id in the program tree,
                // and search other ids in nested namespaces.
                NODE ns1 = ns.find(qual_id[i]);

                if ( unknown != null )
                    unknown = (UNKNOWN_DECL)unknown.find(qual_id[i]);

                if (ns1 == null || ns1 is UNKNOWN_DECL) {
                    // We haven't found qual_id[i] in ns namespace; create one.
                    ns = NAMESPACE_DECL.create(qual_id[i],(NAMESPACE_DECL)ns);

                    // The most non-trivial case: the name is already mentioned in an import
                    // declaration as "either namespace or a unit". Now we are sure this is
                    // namespace. So, create namespace and modify UNKNOWN_DECL so that it refers
                    // to our new namespace.
                    if (ns1 is UNKNOWN_DECL) {
                        unknown = (UNKNOWN_DECL)ns1;
                        unknown.RealDeclaration = ns;
                        unknown.name = null;
                    }
                } else if (ns1 is NAMESPACE_DECL)  // OK; namespace exists.
                {
                    ns = ns1 as NAMESPACE_DECL;
                } else  // ns1 is UNIT_DECL other than NAMECPACE_DECL
                {
                    // Error: name {0} from qualified-name {1} doesn't denote a namespace
                    ERROR.WrongUnitName(qual_id[i].ToString(),qual_id.ToString());
                    ns = NAMESPACE_DECL.create(ERROR.errUnitName,(NAMESPACE_DECL)ns);
                }

                // Build the unit context: the main aim of the function.
                CONTEXT.enter(ns);
            }

            // Resolve UNKNOWN_DECL for the last name (if any)
            Identifier lastName = qual_id[qual_id.Length-1];
            if (unknown != null) {
                unknown = (UNKNOWN_DECL)unknown.find(lastName);
                if (unknown != null) {
                    unknown.name = null;
                    unknown.RealDeclaration = unit;
                }
            }
            // Checking if there is another unit with the same name
            DECLARATION anotherUnit = (DECLARATION)ns.find(lastName);  // UNIT_DECL or UNKNOWN_DECL

            //If another unit is UNKNOWN_DECL then resolve it with new one
            if (anotherUnit is UNKNOWN_DECL) {
                ((UNKNOWN_DECL)anotherUnit).RealDeclaration = unit;
                ns.locals.replace(anotherUnit, unit);
                unit.enclosing = ns;

                anotherUnit = null; // pretend that nothing happened.
            } else if (anotherUnit != null && CONTEXT.partialParsing) {
                ns.locals.replace(anotherUnit, unit);
                unit.enclosing = ns;
                anotherUnit = null; // pretend that nothing happened.
            } else {

                // Final step: adding the previously created unit
                // to the current context.

                ns.locals.Add(unit);
                unit.enclosing = ns;
            }

            return anotherUnit;
        }

        //------------------------------------------------------------

        public static void finalize(UNIT_DECL unit, Identifier id) {
            // Checking the name after END.
            if (id != null) {
                if (unit.name != null && unit.name.Name != id.Name && !ERROR.artificialName(unit.name)) {
                    ERROR.TerminatorDoesntMatchTypeName(unit.name.Name,id.Name);
                }
                unit.sourceContext.EndPos = id.SourceContext.EndPos;
            }
            // Removing the unit from the current context
            CONTEXT.exit();
        }

        //------------------------------------------------------------

        // addImportedUnit
        // ---------------
        // The functions collect all components of import declaration:
        //
        // IMPORT a.b AS a;
        //        ===    =
        //
        // The first version is used from the Parser; the second one
        // is used while processing REFINES and IMPLEMENTS clauses
        // (which by default mean _importing_).
        //
        public void addImportedUnit(IDENT_LIST qualName, Identifier nick, bool satellite, SourceContext sct)
        {
            // We do auto-Importing for ALL level units.
            // if (satellite && !IsTopLevelUnit()) return; 
            // for nested this means aggregation of implementations if any
            // TODO: replace import with aggregate in the language

            //Save for attributes
            string save = qualName.ToString()+":"+((nick==null)?"-null-":nick.Name);           
            if (!imports.Contains(save)) imports.AddLast(save);
            // Consitency check
            if (save.StartsWith("System.Threading")&& !ErrorReported)
            {
                ERROR.DeprecatedImport(sct, "System.Threading");
                ErrorReported = true;
            }

            INSTANCE context;
            if(IsTopLevelUnit()) 
                context = INSTANCE.create(CONTEXT.globalTree);
            else
                context = INSTANCE.create(this.enclosing as DECLARATION);
            DESIGNATOR imported = SELECTOR.processSpecialName(context, qualName);

            if (imported == null)
                return;
            // An error in qualified-id has been detected
            // and the message has been issued. We can do nothing...
            NODE resolved_imported = imported.resolve();
            if (resolved_imported is IMPORT_DECL)
                resolved_imported = ((IMPORT_DECL)resolved_imported).imported_unit;
            if (resolved_imported is UNIT_DECL)
                addImportedUnit(qualName, (UNIT_DECL)resolved_imported, nick, satellite, sct);
            else
                ERROR.WrongImportName(qualName.ToString());
        }

        public void addImportedUnit(IDENT_LIST qualName, UNIT_DECL imported_unit, Identifier nick, bool satellite, SourceContext sct)
        {            
            // nick == null means that we have to have full qualified import
            // and the use is fully qualified e.g.
            // import A.B.C;
            // A.B.C.x := 10; 
            /* THIS ALL NOT NEEDED
             * AS IMPORTS MUST BE EXPLICIT
                // Ensure that there are no import declarations with the same name as 'nick'.
                LinkedList<string> newimports = null;
                // we import all imports in the definition
                if (imported_unit is DEFINITION_DECL)
                { // for defuinition we just take local IMPORT's
                    newimports = imported_unit.imports;
                }
                else if (imported_unit is EXTERNAL_DECL)
                { // for external we take imports from the metadata
                  // they are stored as import:Identifier:Identifier
                  // this first one is the space to be imported. The second is as clause or keyword null
                  // The first attribute must be "definition"
                    ((EXTERNAL_DECL)imported_unit).loadAttributes();
                    newimports = imported_unit.imports; 
                }
                if (newimports != null)
                {
                    foreach (string s in newimports)
                    {
                        string [] idnick = s.Split(':');
                        Identifier nk = ((idnick[1] == "-null-") ? null : Identifier.For(idnick[1]));
                        //UNIT_DECL decl = CONTEXT.globalTree.find(Identifier.For(idnick[0])) as UNIT_DECL;
                        IDENT_LIST idl = new IDENT_LIST();
                        foreach(string ss in idnick[0].Split('.')) idl.Add(Identifier.For(ss));
                        this.addImportedUnit(idl, nk, true);
                    }
                }
            */
            IMPORT_DECL importDecl = null;
            NODE anotherImport = null;
            if ( nick != null )
            {
                NODE anotherImportLocal = this.findExcludingDefs(nick);
                anotherImport = this.find(nick);

                if (anotherImportLocal is UNKNOWN_DECL) {
                    importDecl = new IMPORT_DECL(nick, satellite, sct);
                    importDecl.sourceContext = this.sourceContext;
                    if (!(imported_unit is UNKNOWN_DECL))
                        ((UNKNOWN_DECL)anotherImportLocal).RealDeclaration = imported_unit;
                    locals.replace((UNKNOWN_DECL)anotherImportLocal, importDecl);
                    anotherImport = null; // It's ok
                }
                

                if ((anotherImportLocal is IMPORT_DECL) && (((IMPORT_DECL)anotherImportLocal).IsSatellite()))
                {
                    importDecl = new IMPORT_DECL(nick, satellite, sct);
                    importDecl.sourceContext = this.sourceContext;
                    if (((IMPORT_DECL)anotherImportLocal).imported_unit is UNKNOWN_DECL)
                    {
                        if(!(imported_unit is UNKNOWN_DECL))
                            ((UNKNOWN_DECL)((IMPORT_DECL)anotherImportLocal).imported_unit).RealDeclaration = imported_unit;
                        ((UNKNOWN_DECL)((IMPORT_DECL)anotherImportLocal).imported_unit).enclosing = imported_unit.enclosing;
                    }
                    locals.replace((DECLARATION)anotherImportLocal, importDecl);
                    anotherImport = null; // It's ok
                }
                else
                    if ((anotherImportLocal is IMPORT_DECL) && satellite) anotherImport = null;

                if ( anotherImport != null && !ErrorReported)
                {
                    ErrorReported = true;
                    // ERROR: duplicate declaration
                    if (anotherImportLocal != null) {
                        ERROR.DuplicateDeclaration(qualName.sourceContext, nick.Name);
                        return;
                    } else {
                    // TODO: Add warning here
                   //     if(!satellite)
                   //         ERROR.AlreadyImportedInDefinition(nick.Name, anotherImport.enclosing.name.Name, qualName.sourceContext);
                        // Warning issued. Import skipped.
                        return;
                    }
                }
                // Additional check for cases like as follows:
                // import C, A.B as C;
                for (int i = 0, n = this.locals.Length; i < n; i++) {
                    IMPORT_DECL import = locals[i] as IMPORT_DECL;
                    if (import == null)
                        continue;
                    if (import.name != null)
                        continue; // check only unnamed imports
                    UNIT_DECL imported = import.imported_unit;
                    if (imported.enclosing == null || !(imported.enclosing is NAMESPACE_DECL))
                        continue;
                        // Consider only top-level modules (with non-qualified names)
                    if (imported.name.Name == nick.Name) {
                        if (!ErrorReported)
                        {
                            ERROR.DuplicateDeclaration(nick.Name);
                            ErrorReported = true;
                        }
                        return;
                    }
                }
            } else {
                NODE anotherImportLocal = this.findExcludingDefs(qualName[0]);
                if (anotherImportLocal != null && !(anotherImportLocal is IMPORTSPACE_DECL && qualName.Length > 1))
                {
                    if (!ErrorReported)
                    {
                        ERROR.DuplicateDeclaration(qualName.ToString());
                        ErrorReported = true;
                    }
                    return;
                }
               /* THIS IS WRONG
                // Additional check for cases like as follows:
                // import A.B as C, C;
                if (imported_unit.enclosing != null && imported_unit.enclosing is NAMESPACE_DECL) {
                    Identifier nick1 = imported_unit.name;
                    NODE anotherImport = this.findExcludingDefs(nick1);
                    if (anotherImport is UNKNOWN_DECL) {
                        importDecl = new IMPORT_DECL(nick, satellite);
                        ((UNKNOWN_DECL)anotherImport).real_declaration = imported_unit;
                        locals.replace((UNKNOWN_DECL)anotherImport, importDecl);
                    }else
                        if (anotherImport != null) {
                        // ERROR: duplicate declaration
                        ERROR.DuplicateDeclaration(nick1.Name);
                        return;
                    }
                }
                * */
            }

            UNIT_DECL import_here = this; // Where to import
            // Probably namespace has to be created

            if (nick == null) {
                // Import possibly qualified name without renaming it
                // For every name create/find a namespace within the object
                // Put import within the namespace
                for (int i = 0; i < qualName.Length - 1; i++) {
                    DECLARATION ns = import_here.locals.find(qualName[i]);
                    if (ns != null) {
                        if (ns is IMPORTSPACE_DECL)
                            import_here = ((IMPORTSPACE_DECL)ns);
                        else if (ns is UNKNOWN_DECL)
                        {
                            IMPORTSPACE_DECL isp = new IMPORTSPACE_DECL(qualName[i]);
                            isp.sourceContext = this.sourceContext;
                            isp.enclosing = import_here;                                
                            import_here.locals.replace(ns, isp);                            
                            import_here = isp;
                        }
                        else
                            ERROR.DuplicateDeclaration(qualName[i].Name);
                    } else {
                        // Create a namespace here                        
                        ns = new IMPORTSPACE_DECL(qualName[i]);
                        ns.enclosing = import_here;                        
                        import_here.locals.Add(ns);
                        import_here = ((IMPORTSPACE_DECL)ns); 
                    }
                }

                nick = qualName[qualName.Length - 1];
            }
            // Create new import declaration.            

            anotherImport = import_here.locals.find(nick);
            if (anotherImport is IMPORT_DECL)
            {
                importDecl = (IMPORT_DECL)anotherImport;
                anotherImport = null;
            }
            else
            {
                importDecl = new IMPORT_DECL(nick, satellite, sct);                

                if (anotherImport is UNKNOWN_DECL)
                {
                    //if(!(imported_unit is UNKNOWN_DECL)) ((UNKNOWN_DECL)anotherImport).real_declaration = imported_unit;
                    import_here.locals.replace((UNKNOWN_DECL)anotherImport, importDecl);
                }
                else
                    import_here.locals.Add(importDecl);
            }

            importDecl.enclosing = import_here;
            importDecl.imported_unit = imported_unit;
         // importDecl.modifiers -- already initialized
         // importDecl.name  -- already given
         // importDecl.sourceContext = Parser.LEXAN.getSourceContext();--already done in ctor            

            imported_unit.imported_by = importDecl;

            // Notice that this is not necessary to check the uniqueness
            // among the names of imported units. For example:
            //
            //    MODULE m;
            //       IMPORT a.b.c AS x,
            //              a.b.c AS y,
            //              a.b.c;   // Allowes the use as a.b.c;       
            //       ...
            //
            // Such a situation is quite safe and legal.
            // Notice also that we have already checked the uniqueness
            // of the _nicknames_ (at the beginning of the function).
        }

        //------------------------------------------------------------

        // addImplementedDefinition
        // ------------------------
        // The function processes IMPLEMENTS clause for units:
        //
        //     MODULE m IMPLEMENTS d1, d2; ...
        //                         ==
        //     OBJECT o IMPLEMENTS a.d; ...
        //                         ===
        //
        // The function evaluates the name (using common rules, see SELECTOR.process())
        // and adds the information about new implemented definition
        //
        //   (a) to the list of unit's implemented definitions,
        //   (b) to the list of unit's imported units (as for IMPORT).
        //
        public void addImplementedDefinition(IDENT_LIST qualName) {
            NODE           entity = SELECTOR.processDefinitionName(qualName);
            UNIT_DECL      implemented_definition;
            UNIT_DECL_LIST definitions;

            if (entity == null) {
                // The error message has been already issued by
                // processQualName() function; nothing to do...
                return;
            }

            DECLARATION definition = null;

            if ( entity is INSTANCE || entity is SELECTOR )
                definition = (DECLARATION)((DESIGNATOR)entity).resolve();
            else {
                ERROR.SystemErrorIn("addImplementedDefinition","strange unit in IMPLEMENTS");
                return;
            }
            if (definition is IMPORT_DECL) {
                IMPORT_DECL import = definition as IMPORT_DECL;
                definition = import.imported_unit;
            }

            if ( definition is DEFINITION_DECL ) // We have found the definition.
            {
                implemented_definition = definition as DEFINITION_DECL;
                goto ProcessDefinition;
            }
            if (definition is IMPLEMENTATION_DECL) {
                IMPLEMENTATION_DECL implementation = definition as IMPLEMENTATION_DECL;
                implemented_definition = implementation.implemented_definition;
                // It is still unclear how to interpret the case if base_id names
                // an implementation, and this implementation doesn't have definition...
                if (implemented_definition == null)
                    goto WrongDefinition;
                goto ProcessDefinition;
            }
            if (definition is UNKNOWN_DECL) {
                // This means that there wasn't definition with the given name,
                // and SELECTOR.processQualName() has created it.
                // Here we should use this unknown unit just as we've got
                // a real definition...
                implemented_definition = definition as UNIT_DECL;
                ((UNKNOWN_DECL)definition).resolveasdefinition = true;
                goto ProcessDefinition;
            }

            // All other cases (e.g., module) are illegal.

        WrongDefinition:

            // Name '{0}' does not denote a definition as expected
            ERROR.WrongDefinitionName(definition.name.Name);
            return;

        ProcessDefinition:

            if (this is MODULE_DECL)
                definitions = ((MODULE_DECL)this).definitions;
            else if (this is OBJECT_DECL)
                definitions = ((OBJECT_DECL)this).definitions;
            else
                definitions = null;

            // Semantic check: the uniqueness of the definition in the list?
            DECLARATION def;
            def = definitions.find(implemented_definition);
            if (def != null) {
                // Duplicate imported unit:
                // duplicate declaration of implemented definition <name>
                ERROR.DuplicateUnit("implemented definition",implemented_definition.name.Name);
                return;
            }
            // Otherwise:
            // Add definition to the list of unit's implemented definitions.
            definitions.Add(implemented_definition);
            if (prefixesForMixed == null)
                prefixesForMixed = new List<string>();
            string mixed = "";
            // Prepare mixed name
            for (int i = 0; i < qualName.Length; i++)
                mixed += qualName[i].Name + "_";
            mixed += "mixed";
            prefixesForMixed.Add(mixed);

            addImportedUnit(qualName, null, true, sourceContext);
         //   // Add the definition to the list of _imported_ units:
         //   // the definition is considered as imported by default.
         //   IMPORT_DECL imported_by_default = new IMPORT_DECL(qualName[qualName.Length-1]);            
         //   //IMPORT_DECL imported_by_default = new IMPORT_DECL(qualName[0]); // First namespace
         //   imported_by_default.enclosing = this;
         //   imported_by_default.imported_unit = implemented_definition;
         //// imported_by_default.modifiers -- already initialized
         //// imported_by_default.name  -- already given
         //// imported_by_default.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor

         //   // Put the declaration to the unit's list of locals.
         //   this.locals.Add(imported_by_default);
         //   // Notice that it is not necessary to check the uniqueness
         //   // of the definition added to the list: just because
         //   // this is the very first unit added to the local context.
        }

        //------------------------------------------------------------
        private bool _resolved = false;
        private bool _onetryisused = false;

        protected bool resolved()
        {
            if(_resolved) return true;
            if (CONTEXT.firstPass)
            {
                if (_onetryisused) return true;
                _onetryisused = true;
                return false;
            }
            _resolved = true; 
            return false; // Let resolve for the last time
        }
        public abstract override NODE resolve ( );
        public abstract override bool validate ( );
        public abstract override TYPE type { get; set; }
        public abstract override Node convert ( );

		//------------------------------------------------------------

#if DEBUG
        public override void report(int shift) {
            NODE.doShift(shift);
            System.Console.Write("IMPORTED BY ");
            if ( imported_by == null )
                System.Console.WriteLine("NOBODY");
            else
                imported_by.report_short();

            NODE.doShift(shift);
            System.Console.Write("UNIT DECLARATIONS:");
            if ( locals == null || locals.Length == 0 )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine(" {0}",locals.Length);
                for ( int i=0, n=locals.Length; i<n; i++ )
                    locals[i].report(shift+reportShift);
            }

            NODE.doShift(shift);
            System.Console.Write("UNIT BODY: ");
            if ( body == null )
                System.Console.WriteLine(" MISSED");
            else if ( ( body.statements == null || body.statements.Length == 0 ) &&
                ( body.exceptions == null || body.exceptions.Length == 0 ) )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                body.report(shift+reportShift);
            }
        }
#endif
    }

    // UNKNOWN_DECL
    // ============
    // This is a placeholder for an entity which is not known yet.
    // There are several legal cases where entities can be undeclared.
    //
    // 1. Unit or namespace is not known yet:
    //
    // MODULE m;
    //    IMPORT A.B;
    //  ...
    //
    // (Assuming that neither A nor B were not declared before.)
    // Here both A and B are represented as UNKNOWN_DECLs.
    //
    // During resolution this node will be replaced for a some
    // other class derived from UNIT_DECL (i.e., for NAMESPACE,
    // or for MODULE_DECL, OBJECT_DECL, ...).
    //
    // 2. A local entity is not known yet:
    //
    // MODULE m;
    //    VAR x : o;             <=== o is UNKNOWN_DECL
    //    VAR y : t;             <=== t is UNKNOWN_DECL
    //    VAR z : OBJECT { d };  <=== d is UNKNOWN_DECL
    //
    //    OBJECT o; ... END o;
    //    TYPE t = ...
    //    DEFINITION d; ... END d;
    // END m.
    //
    // During resolution this node will be replaced for
    // a node derived from DECLARATION.
    //
    public sealed class UNKNOWN_DECL : UNIT_DECL {
        // Constructor
        public UNKNOWN_DECL ( Identifier name ) : base(ASTNodeType.UNKNOWN_DECL, name) { RealDeclaration = null; }

        //---------------------------------------------------------
        public bool resolveasdefinition = false;
        // FROM THE BASE:
     // public DECLARATION_LIST  locals; -- only UNKNOWN_DECLs
     // public BLOCK             body;   -- doesn't exist

        private DECLARATION      real_declaration;
        public DECLARATION       RealDeclaration {
            get {return real_declaration;}
            set 
            {
                real_declaration = value;
                System.Diagnostics.Debug.Assert(!(real_declaration is UNKNOWN_DECL));
            }
        }

        //--------------------------------------------------------------

        public override NODE findExcludingDefs(Identifier name) {
            return base.find(name);
        }

        public override NODE find ( Identifier name )
        {
            if ( this.RealDeclaration != null )
            {
                if ( RealDeclaration is IMPLEMENTATION_DECL )
                {
                    IMPLEMENTATION_DECL impl = RealDeclaration as IMPLEMENTATION_DECL;
                    UNIT_DECL def = impl.implemented_definition;
                    if ( def != null ) {
                        NODE found = def.find(name);
                        if (found != null)
                            return found;
                        // Else will search in base.
                        }
                } else
                    return RealDeclaration.find (name);
            }
            return base.find(name);
        }

        //--------------------------------------------------------------

        public static UNKNOWN_DECL create(Identifier id, DECLARATION enclosing) {
            System.Diagnostics.Debug.Assert(enclosing != null);
            UNKNOWN_DECL external = new UNKNOWN_DECL(id);
            external.sourceContext = enclosing.sourceContext;
            external.enclosing = enclosing;
            DECLARATION encldecl;
            if (enclosing is IMPORT_DECL) encldecl = ((IMPORT_DECL)enclosing).imported_unit;
            else encldecl = enclosing;
/* there is no need to see/list unknown
            if ( encldecl != null )
            {
                if ( encldecl is UNIT_DECL ) ((UNIT_DECL)encldecl).locals.Add(external);
                else /* ROUTINE_DECL * /       ((ROUTINE_DECL)encldecl).locals.Add(external);
            }
*/
            return external;
        }
        //--------------------------------------------------------------

        public static UNKNOWN_DECL create(Identifier id, SAFEGUARD enclosing) {
            System.Diagnostics.Debug.Assert(enclosing != null);
            UNKNOWN_DECL external = new UNKNOWN_DECL(id);            
            external.enclosing = enclosing;
            external.sourceContext = enclosing.sourceContext;
            return external;
        }

        public static UNKNOWN_DECL create(Identifier id, INDEXER enclosing) {
            System.Diagnostics.Debug.Assert(enclosing != null);
            UNKNOWN_DECL external = new UNKNOWN_DECL(id);
            external.enclosing = enclosing;
            external.sourceContext = enclosing.sourceContext;
            return external;
        }
        //--------------------------------------------------------------

        public override NODE resolve()
        {
            resolveInternal();
            if (RealDeclaration is IMPLEMENTATION_DECL && resolveasdefinition)
            {
                if (((IMPLEMENTATION_DECL)RealDeclaration).implemented_definition != null)
                    RealDeclaration = ((IMPLEMENTATION_DECL)RealDeclaration).implemented_definition;
            }
            if (RealDeclaration == null) return this;
            return real_declaration;
        }
        private NODE resolveInternal ( )
        {
            if ( RealDeclaration != null )
            {
                return RealDeclaration.resolve();
            }
            if (resolved()&&CONTEXT.firstPass) return this; // Try once. Then wait till the second pass 
            if (enclosing != null)
            {
                if (enclosing is SAFEGUARD) //Special case
                {
                    UNIT_DECL_LIST defs = ((SAFEGUARD)enclosing).definitions;
                    if (defs != null) { // Our case with Africa's problem 
                        for (int i = 0, n = defs.Length; i < n; i++) {
                            NODE decl = defs[i].find(this.name);
                            if (decl is DECLARATION) {// Resolved
                                RealDeclaration = decl as DECLARATION;
                                return RealDeclaration;
                            }
                        }
                        //Not resolved. Error. Return again UNKNOWN.
                        return this;
                    }

                }

                if (enclosing is INDEXER) //Special case
                {
                    INDEXER scope = (INDEXER)enclosing;
                    if (scope.type != null)
                        enclosing = scope.type;
                    else if (!CONTEXT.firstPass)
                        ERROR.UnknownType(sourceContext, enclosing.sourceContext.SourceText);
                }

                // ACHTUNG! How to deal with import is underspecified in the
                // language report.

                //// Make an attempt to resolve the sequence of UNKNOWN decl's
                //// For the import case with qualified names
                //if (enclosing is UNKNOWN_DECL)
                //{
                //    string combName = this.name.Name;
                //    NODE enc = enclosing as UNKNOWN_DECL;
                //    while (enc is UNKNOWN_DECL)
                //    {
                //        combName = enc.Name +"."+ combName;
                //        enc = enc.enclosing;
                //    }
                //    // Make an attempt
                //    if (enc != null)
                //    {
                //        NODE result = enc.find(new Identifier(combName));
                //        if (result != null && !(result is UNKNOWN_DECL))
                //        {
                //            this.enclosing = result.enclosing; // outer;
                //            this.real_declaration = (DECLARATION)result;
                //            this.real_declaration.enclosing = this.enclosing;
                //            this.real_declaration.name = this.name;

                //            base.name = null;

                //            return this.real_declaration;
                //        }
                //    }
                //}

                NODE outer = (enclosing is UNKNOWN_DECL || enclosing is UNKNOWN_TYPE) ? enclosing.resolve() : enclosing;
                if (outer is OBJECT_TYPE)
                    outer = ((OBJECT_TYPE)outer).ObjectUnit;

                if (!(outer is UNKNOWN_DECL)) {
                    NODE result = outer.find(this.name);
                    // TODO: Figure out how it can happen to be unknown. Added as a hack

                    if (result == null && (outer is UNIT_DECL) || (result is UNKNOWN_DECL)) {
                        while ((outer.enclosing != null) && !(outer.IsTopLevelUnit())) {
                            outer = outer.enclosing.resolve();
                            if (outer.enclosing != null) { // Prohibit search on 'Zonnon' namespace level
                                result = outer.find(this.name);
                                if ((result != null) && !(result is UNKNOWN_DECL))
                                    break;
                            }
                        }
                    }
                    if (result is IMPORT_DECL)
                    {
                        result = ((IMPORT_DECL)result).imported_unit;
                        if (result is UNKNOWN_DECL) result = result.resolve();
                    }
                    if (result != null && !(result is UNKNOWN_DECL))
                    {
                        this.enclosing = result.enclosing; // outer;
                        this.RealDeclaration = (DECLARATION)result;
                        this.RealDeclaration.enclosing = this.enclosing;
                        this.RealDeclaration.name = this.name;

                        base.name = null;

                        return this.RealDeclaration;
                    } else if (result is UNKNOWN_DECL) {
                        if (CONTEXT.firstPass)
                            return this;
                    }
                    else if (result is UNKNOWN_DECL)
                    {
                        if (CONTEXT.firstPass) return this;
                    }
                }
                // Cannot resolve enclosing node;
                // perhaps, this is an external assembly?
                
                    if (CONTEXT.firstPass)
                        return this;
                

                Node external = this.resolveAsExternal();
                if (external != null) {
                    this.RealDeclaration = EXTERNAL_DECL.create(external, name, this.enclosing);
                    this.name = null;

                    return RealDeclaration;
                }
            }
            else
                System.Diagnostics.Debug.Assert(false);
            return this;
        }

        private Node resolveAsExternal() {
            // First we try to find the namespace with the full name...
            // Notice that we are only interested if there is the namespace with the
            // given name but not in the namespace itself.                     

            // The last attempt: we assume the name is from a _native_ external
            // assembly, that is, somethig like Zonnon.TYPE...

            EXTERNAL_DECL zonnon = new EXTERNAL_DECL(Identifier.For("Zonnon"));
            NODE native = zonnon.find(Identifier.For(this.Name));
            if ( native != null )
                return ((EXTERNAL_DECL)native).entity;

            // If we fail then we assume that only a part of the full name
            // represents namespace. We recursively call resolveAsExternal()
            // for 'enclosing'...

            if (enclosing is UNKNOWN_DECL)
            {

                Node result = ((UNKNOWN_DECL)enclosing).resolveAsExternal();
                // If success then we try to find the entity with the own name
                // in the entity found for 'enclosing'.
            if (result != null) {
                    // 'enclosing' was resolved either as a namespace or as a type.
                    // So, we try to find a member of the entity.
                    EXTERNAL_DECL ext = new EXTERNAL_DECL(result);
                    NODE res = ext.find(Identifier.For(this.Name));
                    if (res != null)
                        return ((EXTERNAL_DECL)res).entity;
                }
            }

            NODE ths = this;

            string full = "";
            while (ths.enclosing is UNKNOWN_DECL || ths.enclosing is NAMESPACE_DECL)
            {
                ths = ths.enclosing;
                if(full.Length > 0)
                    full = ths.Name + "." + full;
                else
                    full = ths.Name;
            }
            if (ths.enclosing is IMPORTSPACE_DECL)
            {                
                if (full.Length > 0)
                    full = ths.enclosing.Name + "." + full;
                else
                    full = ths.enclosing.Name;
            }
            
            string zprefix, prefix;

            if (full.StartsWith("Zonnon"))
            {
                zprefix = full;
                if (full.Length > 7) prefix = full.Substring(7);
                else prefix = "";
            }
            else
            {
                prefix = full;
                if (full.Length > 0) zprefix = "Zonnon." + full;
                else zprefix = "Zonnon";
            }

            if (EXTERNALS.testNamespace(zprefix))
            {
                Node fnd = EXTERNALS.findType(zprefix, Identifier.For(this.Name));
                if (fnd != null) return fnd;
            }

            if (EXTERNALS.testNamespace(prefix))
            {
                Node fnd = EXTERNALS.findType(prefix, Identifier.For(this.Name));
                if (fnd != null) return fnd;
            }

            zprefix = zprefix + "." + this.Name;
            if (prefix.Length > 0) prefix = prefix + "." + this.Name;
            else prefix = this.Name;

            // This can be just a namespace (we support it although it shouldn't be in Zonnon)

            if (EXTERNALS.testNamespace(zprefix)) return Identifier.For(zprefix);

            if (EXTERNALS.testNamespace(prefix)) return Identifier.For(prefix);

            // Probably its namespace + type
            
            return null;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if ( RealDeclaration != null )
                return RealDeclaration.validate();

            // return true;
            // Undeclared entity
            //if ( !ErrorReported )
            //{
            //    ERROR.UndeclaredLocal(this.Name,this.sourceContext);
            //    ErrorReported = true;
            //}
            return false;
        }

        //---------------------------------------------------------------------

        public override TYPE type {
            get {
                if ( internal_type == null && RealDeclaration != null )
                    internal_type = RealDeclaration.type;
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if ( RealDeclaration == null )
            {
                if ( enclosing is NAMESPACE_DECL )  // this is unresolved external declaration
                {
                    if (!ErrorReported) {
                        ERROR.UndeclaredUnit(this.sourceContext,this.name.Name);
                        ErrorReported = true;
                    }
                }
                return null;
             // else // this is unresolved local declaration
             // {
             //     if ( !validate() ) return null;
             // }
            }
            else if ( RealDeclaration is EXTERNAL_DECL )
            {
                node = ((EXTERNAL_DECL)RealDeclaration).convert();
                return node;
            }
            // First convert the owner of this UNKNOWN_DECL
            UNIT_DECL unit = RealDeclaration.enclosing as UNIT_DECL;
            if ( unit != null && unit.node == null )
                unit.convert();

      ////  Let's postpone the generation until the real declaration
      ////  occurs: otherwise, the code appears twice in the output!
      ////
      ////  // Then convert the "real" declaration from the node itself.
      ////  node = real_declaration.convert();
      ////  return node;
            return null;
        }

        //-------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("UNKNOWN DECLARATION ");
            if ( base.name == null ) // resolved
                System.Console.Write("<RESOLVED>");
            else
                System.Console.Write("{0}",base.name.Name);

            report_extra();

            if ( RealDeclaration != null )
            {
                NODE.doShift(shift+NODE.reportShift);
                System.Console.Write("RESOLVED TO ");
                RealDeclaration.report_short();
                System.Console.WriteLine();
            }

            base.report(shift+reportShift);
        }

        public override void report_short() {
            string name = (base.name!=null) ? base.name.Name : "NONAME";
            System.Console.Write("UNKNOWN DECLARATION {0}:{1}",unique,name);
        }
#endif
    }

    // EXTERNAL_DECL
    // -------------
    // For namespace or class or member from an external assembly.
    //
    public sealed class EXTERNAL_DECL : UNIT_DECL {
        // for external namespace: Identifier;
        // for external type:      TypeNode;
        // for external method:    Method;
        // for external property:  Property.
        public Node entity;

        // Constructor
        public EXTERNAL_DECL ( Node e ) : this(e,null,null) { }

        public void loadAttributes()
        {
            if(typestamp != "notset") return;            
            if (!(entity is TypeNode)) return;
            TypeNode tn = (TypeNode)entity;
            if (tn.Attributes == null) return;
            AttributeNode atr = null;
            foreach (AttributeNode nd in tn.Attributes)
            {
                if (nd.Type.FullName == "Zonnon.RTL.ZonnonAttribute") { atr = nd; break; }
            }
            if (atr != null)
            {
                string metadata = (string)((Literal)atr.Expressions[0]).Value;
                string[] lines = metadata.Split('\n');
                typestamp = lines[0];
                for (int i = 1; i < lines.Length; i++)
                {
                    string[] line = lines[i].Split(':');
                    if (line[0] == "import")
                    {
                        imports.AddLast(line[1]+":"+line[2]);
                    }
                }
            }

            
        }

        // Constructor
        public EXTERNAL_DECL(Node e, Identifier name, NODE enclosing)
            : base(ASTNodeType.EXTERNAL_DECL, name) {
            entity = e;
            if ( enclosing == CONTEXT.globalTree )
                base.enclosing = null;
            else
                base.enclosing = enclosing;
        }

        public void findImportedOperators(OPERATOR_DECL_LIST opList, string sign, bool rec) {
            Identifier extName = OPERATOR_DECL.toName(sign);

            
            TypeNode ent = entity as TypeNode;
            while (ent != null) {
                for (int i = 0, n = ent.Members.Length; i < n; i++) {
                    Method local = ent.Members[i] as Method;
                    if (local == null)
                        continue;
                    if (local.Name.Name == extName.Name) {
                        // Let's import operator
                        OPERATOR_DECL op = new OPERATOR_DECL(sign);
                        op.node = local;
                        op.paramCount = local.Parameters.Length;
                        op.enclosing = new EXTERNAL_TYPE(ent);
                        if (op.paramCount > 0) {
                            IDENT_LIST list = new IDENT_LIST();
                            list.Add(new Identifier("arg0"));
                            EXTERNAL_TYPE type = new EXTERNAL_TYPE(local.Parameters[0].Type);
                            MODIFIERS mods = new MODIFIERS();
                            PARAMETER_DECL.create(op, list, type, false, mods);       //!local.Parameters[0].Type.IsValueType
                        }
                        if (op.paramCount > 1) {
                            IDENT_LIST list = new IDENT_LIST();
                            list.Add(new Identifier("arg1"));
                            EXTERNAL_TYPE type = new EXTERNAL_TYPE(local.Parameters[1].Type);
                            MODIFIERS mods = new MODIFIERS();
                            PARAMETER_DECL.create(op, list, type, false, mods);     //!local.Parameters[0].Type.IsValueType
                        }
                        op.return_type = new EXTERNAL_TYPE(local.ReturnType);
                        op.sourceContext = this.sourceContext;
                        op.external = true;
                        opList.Add(op);
                        continue;
                    }
                }
                ent = ent.DeclaringType;                
            }; // while ent # null
        }

        public static EXTERNAL_DECL create(Node entity, Identifier name, NODE enclosing) {
            EXTERNAL_DECL external = new EXTERNAL_DECL(entity,name,enclosing);
            return external;
        }

        //---------------------------------------------------------------

        public override NODE findExcludingDefs(Identifier name) {
            return this.find(name);
        }

        public override NODE find_in_scope(Identifier name)
        {            
            NODE result = this.find(name);
            return result;
        }

        public override NODE find ( Identifier name )
        {
            if ( name == null ) return null;
            if ( entity == null ) return null;

            if (entity is Identifier) {
                string entity_name = ((Identifier)entity).Name;

                TypeNode typ = EXTERNALS.findType(entity_name, name);
                if (typ != null)
                    return new EXTERNAL_DECL(typ);

            } else if (entity is TypeNode) {
                Node e = entity;
                do {
                    MemberList members = ((TypeNode)e).GetMembersNamed(name);
                    if ( members != null && members.Length >0 )
                        return new EXTERNAL_DECL(members[0]);

                    e = ((TypeNode)e).BaseType;
                }
                while ( e != null );
                //Check interfaces
                TypeNode t = (TypeNode)entity;
                for (int j = 0, n = t.Interfaces.Length; j < n; j++)
                {
                    Interface intf = t.Interfaces[j];                    
                    MemberList members = intf.GetMembersNamed(name);
                    if (members != null && members.Length > 0)
                        return new EXTERNAL_DECL(members[0]);
                }
            }
            else if (entity is Field)
            {
                TypeNode t = ((Field)entity).Type;
                Node e = t;
                do {
                    MemberList members = ((TypeNode)e).GetMembersNamed(name);
                    if (members != null && members.Length > 0)
                        return new EXTERNAL_DECL(members[0]);

                    e = ((TypeNode)e).BaseType;
                }
                while (e != null);
            } else if (entity is Property) {
                TypeNode t = ((Property)entity).Type;
                Node e = t;
                do {
                    MemberList members = ((TypeNode)e).GetMembersNamed(name);
                    if (members != null && members.Length > 0)
                        return new EXTERNAL_DECL(members[0]);

                    e = ((TypeNode)e).BaseType;
                }
                while (e != null);
            }
            return null;
        }

        //---------------------------------------------------------------

        public override NODE resolve ( ) {             
            return this;         
        }
        public override bool validate ( ) {
            if (!CONTEXT.firstPass) {
                DECLARATION encl = (enclosing == null) ? null : enclosing.resolve() as DECLARATION;
                if (entity == null && !ErrorReported)
                {
                    ERROR.UndeclaredEntity(this.Name, enclosing.Name);
                    ErrorReported = true;
                }                
                //if (encl != null && encl.find(this.name) == null)
                //{
                //    //It still can be a namespace                    
                //    if (encl is EXTERNAL_DECL && (((EXTERNAL_DECL)(encl)).entity) is Identifier &&
                //        EXTERNALS.testNamespace(((System.Compiler.Identifier)(((EXTERNAL_DECL)(encl)).entity)).Name + "." + this.name.Name))
                //    { }else
                //    {
                //        ERROR.UndeclaredEntity(this.Name, encl.Name);
                //        ErrorReported = true;
                //    }
                //}
            }
            return true; 
        }  // checks semantical correctness

        //---------------------------------------------------------------

        public override TYPE type   // evaluates type
        {
            get {
                if ( this.internal_type != null )
                    return internal_type;

                if ( entity is Field )
                    internal_type = EXTERNAL_TYPE.create(((Field)entity).Type);
                else if ( entity is Method )
                    internal_type = EXTERNAL_TYPE.create(((Method)entity).ReturnType);
                else if ( entity is Property )
                    internal_type = EXTERNAL_TYPE.create(((Property)entity).Type);
                else if (entity is Class)
                    internal_type = EXTERNAL_TYPE.create(entity);
                else if (entity is Struct)
                    internal_type = EXTERNAL_TYPE.create(entity);
                else if (entity is EnumNode)
                    internal_type = EXTERNAL_TYPE.create(entity);

                return internal_type;
            }
            set {
            }
        }

        //--------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            if (entity is Identifier)
                node = entity;
            else if (entity is Namespace)
                node = ((Namespace)entity).Name;
            else if (entity is TypeNode)
                node = entity; // ((TypeNode)entity).Name;
            else if (entity is Method)
                node = ((Method)entity).Name;  // entity
                                                     // if issue just entity, then problems with
                                                     // overloading resolution may occur
            else if (entity is Property)
                node = ((Property)entity).Name;
                                             // node = new MemberBinding(null,(Property)entity);

            if (node != null)
                node.SourceContext = this.sourceContext;
            return node;
        }

        public void addUnimplementedInterfaceEntities(UNIT_DECL unit, bool module, string mixedName)
        {

            string unit_kind = module ? "module" : "object";

            TypeNode cls = (TypeNode)unit.node;

            if (cls.Members == null) cls.Members = new MemberList();

            Interface def = this.entity as Interface;
            if (def == null) return;
            //   while(def != null)
            //   {

            for (int i = 0, n = def.Members.Length; i < n; i++)
            {
                Member declaration = def.Members[i];
                bool SomeProcExists = false;  // for procedures in definition (not for variables)

                if (declaration is Property)
                {
                    #region VariableDeclaration
                    Property prop = (Property)declaration;

                    string name = prop.Name.Name;
                    // First of all, generate the property itself for MODULES
                    Property property = null;

                    // Generating property which corresponds to the variable
                    property = new Property();
                    // property.Attributes;
                    property.DeclaringType = cls;
                    property.Flags = PropertyFlags.None;
                    // property.Getter;  -- see below
                    // property.HidesBaseClassMember;
                    property.ImplementedTypes = new TypeNodeList();
                    property.ImplementedTypes.Add((TypeNode)this.entity);
                    property.Name = prop.Name;
                    property.SourceContext = base.sourceContext;
                    property.Type = prop.Type;
                    property.OverridesBaseClassMember = true;
                    cls.Members.Add(property);

                    NODE getter_in_unit = unit.find_getter(prop.Name);
                    NODE setter_in_unit = unit.find_setter(prop.Name);

                    bool need_getter = false, need_setter = false;

                    if (getter_in_unit != null)
                    {
                        Method getter = (Method)getter_in_unit.convert();
                        if (getter == null) /* an error */ goto Skip1;
                        getter.ImplementedInterfaceMethods = new MethodList();
                        Member def_getter = ((Interface)node).GetMembersNamed(Identifier.For("get_" + name))[0];
                        getter.ImplementedInterfaceMethods.Add((Method)def_getter);
                        property.Getter = getter;
                    Skip1: ;
                    }
                    else
                    {
/* TODO: Find external implementation
                        // No getter for the definition variable defined in object/module.
                        // Perhaps, there is a getter in the default implementation?
                        if (implementation != null)
                            getter_in_impl = implementation.find_getter(declaration.name);
 * */
                    }
                    if (setter_in_unit != null)
                    {
                        Method setter = (Method)setter_in_unit.convert();
                        if (setter == null) /* en error */ goto Skip2;
                        setter.ImplementedInterfaceMethods = new MethodList();
                        Member def_setter = ((Interface)node).GetMembersNamed(Identifier.For("set_" + name))[0];
                        setter.ImplementedInterfaceMethods.Add((Method)def_setter);
                        property.Setter = setter;
                    Skip2: ;
                    }
                    else
                    {
/* TODO: Find external implementation

                        // No setter for the definition variable defined in object/module.
                        // Perhaps, there is a setter in the default implementation?
                        if (implementation != null)
                            setter_in_impl = implementation.find_setter(declaration.name);
 * */
                    }

                    // If there is no getter/setter anywhere - that is, 
                    // a) we do not have an implementation at all (otherwise we do have accessors anyway)
                    // b) there is no getter/setter in the object/module itself, 
                    // then we need to generate default one(s).
                    if (/*declaration.modifiers.Getter && implementation == null &&*/ getter_in_unit == null)
                        need_getter = true;
                    if (/*declaration.modifiers.Setter && implementation == null &&*/ setter_in_unit == null)
                        need_setter = true;

                    if (need_getter || need_setter)
                    {
                        // We need to generate either getter or setter or both for object/module.
                        // Before that, we have to generate the internal (default) variable 
                        // which will be used as the internal representation for the accessor(s).
                        //
                        // NOTICE that it is not necessary to generate the property itself
                        // because the accessors are the implementations of the existing property
                        // which is already defined in the definition.
                        // - NO: for MODULES we do need the property in the module body!

                        

                        Field variable = new Field();

                        variable.Type = prop.Type;
                        variable.Name = Identifier.For(name + "_default");
                        variable.Flags = FieldFlags.Private;
                        if (module) variable.Flags |= FieldFlags.Static;
                        // variable.Attributes;
                        variable.DeclaringType = cls;
                        variable.DefaultValue = null;
                        // variable.Initializer = var.createInitializer(var);

                        cls.Members.Add(variable);

                        // Now generate the accessor(s) needed

                        if (need_getter)
                        {
                            // Getter is not declared; generating it here.
                            Method getter = new Method();
                            getter.Body = new Block();
                            getter.Body.Statements = new StatementList();

                            // Making 'return <variable>;'
                            Return return_stmt = new Return();
                            if (module)
                                return_stmt.Expression = new MemberBinding(null, variable);
                            else
                                return_stmt.Expression = new MemberBinding(new This(), variable); //Identifier.For(name+"_default");
                            return_stmt.SourceContext = base.sourceContext;
                            getter.Body.Statements.Add(return_stmt);

                            getter.DeclaringType = cls;
                            getter.Flags = MethodFlags.Public | MethodFlags.SpecialName;
                            if (module) getter.Flags |= MethodFlags.Static;
                            else getter.CallingConvention = CallingConventionFlags.HasThis;

                            // if ( !module )
                            // {
                            getter.ImplementedInterfaceMethods = new MethodList();
                            Member def_getter = ((Interface)node).GetMembersNamed(Identifier.For("get_" + name))[0];
                            getter.ImplementedInterfaceMethods.Add((Method)def_getter);
                            // }
                            getter.Name = Identifier.For("get_" + name);
                            getter.ReturnType = prop.Type;
                            getter.Parameters = null;

                            cls.Members.Add(getter);
                            /*   if ( module ) */
                            property.Getter = getter;
                        }
                        if (need_setter)
                        {
                            // Setter is not declared; generating it here.
                            Method setter = new Method();
                            setter.Body = new Block();
                            setter.Body.Statements = new StatementList();

                            // Making '<variable> = value;'
                            AssignmentStatement assign = new AssignmentStatement();
                            assign.Operator = NodeType.Nop;
                            if (module)
                                assign.Target = new MemberBinding(null, variable);
                            else
                                assign.Target = new MemberBinding(new This(), variable); // Identifier.For(name+"_default");
                            assign.Source = Identifier.For("value");
                            setter.Body.Statements.Add(assign);

                            setter.DeclaringType = cls;
                            setter.Flags = MethodFlags.Public | MethodFlags.SpecialName;
                            if (module) setter.Flags |= MethodFlags.Static;
                            else setter.CallingConvention = CallingConventionFlags.HasThis;

                            // if ( !module )
                            // {
                            setter.ImplementedInterfaceMethods = new MethodList();
                            Member def_setter = ((Interface)node).GetMembersNamed(Identifier.For("set_" + name))[0];
                            setter.ImplementedInterfaceMethods.Add((Method)def_setter);
                            // }
                            setter.Name = Identifier.For("set_" + name);
                            setter.ReturnType = SystemTypes.Void; // type;
                            setter.Parameters = new ParameterList();

                            Parameter par = new Parameter();
                            // par.Attributes;
                            par.DefaultValue = null;
                            par.Flags = ParameterFlags.In;
                            // par.MarshalType;
                            par.Name = Identifier.For("value");
                            // par.NodeType;
                            par.ParameterListIndex = 0;
                            par.SourceContext = base.sourceContext;
                            par.Type = prop.Type; // SystemTypes.Object;
                            setter.Parameters.Add(par);

                            cls.Members.Add(setter);
                            /* if ( module ) */
                            property.Setter = setter;
                        }
                    }
/* TODO: Learn to import implementation                        

                    else 
                        if (implementation != null)
                    {
                        // Implementation unit contains (default) implementation 
                        // of the accessors. We should generate the "equivalents"
                        // to these accessors in the module/object according the following scheme:
                        //
                        // object O implements D;
                        //
                        //       ==>  D D_mixed = new D_implem();
                        //
                        //            int  get_i() { return D_mixed.i; }
                        //            void set_i(int v) { D_mixed.i = v; }

                        bool need_replacement_getter = declaration.modifiers.Getter && getter_in_unit == null;
                        bool need_replacement_setter = declaration.modifiers.Setter && setter_in_unit == null;

                        if (need_replacement_getter)
                        {
                            Method getter = new Method();
                            getter.Body = new Block();
                            getter.Body.Statements = new StatementList();

                            // Making 'return D_mixed.i;'
                            Return return_stmt = new Return();
                            return_stmt.Expression = new QualifiedIdentifier(
                                                            Identifier.For(mixedName),
                                                            Identifier.For(name));
                            return_stmt.SourceContext = base.sourceContext;
                            getter.Body.Statements.Add(return_stmt);

                            getter.DeclaringType = cls;
                            getter.Flags = MethodFlags.Public | MethodFlags.SpecialName;
                            if (module) getter.Flags |= MethodFlags.Static;
                            else getter.CallingConvention = CallingConventionFlags.HasThis;

                            // if ( !module )
                            // {
                            getter.ImplementedInterfaceMethods = new MethodList();
                            Member def_getter = ((Interface)node).GetMembersNamed(Identifier.For("get_" + name))[0];
                            getter.ImplementedInterfaceMethods.Add((Method)def_getter);
                            // }
                            getter.Name = Identifier.For("get_" + name);
                            getter.ReturnType = type;
                            getter.Parameters = null;

                            cls.Members.Add(getter);
                            // if ( module ) 
                            property.Getter = getter;
                        }
                        if (need_replacement_setter)
                        {
                            Method setter = new Method();
                            setter.Body = new Block();
                            setter.Body.Statements = new StatementList();

                            // Making 'D_mixed.i = value;'
                            AssignmentStatement assign = new AssignmentStatement();
                            assign.Operator = NodeType.Nop;
                            assign.Target = new QualifiedIdentifier(Identifier.For(mixedName),
                                                                    Identifier.For(name));
                            assign.Source = Identifier.For("value");
                            setter.Body.Statements.Add(assign);

                            setter.DeclaringType = cls;
                            setter.Flags = MethodFlags.Public | MethodFlags.SpecialName;
                            if (module) setter.Flags |= MethodFlags.Static;
                            else setter.CallingConvention = CallingConventionFlags.HasThis;

                            // if ( !module )
                            // {
                            setter.ImplementedInterfaceMethods = new MethodList();
                            Member def_setter = ((Interface)node).GetMembersNamed(Identifier.For("set_" + name))[0];
                            setter.ImplementedInterfaceMethods.Add((Method)def_setter);
                            // }
                            setter.Name = Identifier.For("set_" + name);
                            setter.ReturnType = SystemTypes.Void; // type;
                            setter.Parameters = new ParameterList();

                            Parameter par = new Parameter();
                            // par.Attributes;
                            par.DefaultValue = null;
                            par.Flags = ParameterFlags.In;
                            // par.MarshalType;
                            par.Name = Identifier.For("value");
                            // par.NodeType;
                            par.ParameterListIndex = 0;
                            par.SourceContext = base.sourceContext;
                            par.Type = type; // SystemTypes.Object;
                            setter.Parameters.Add(par);

                            cls.Members.Add(setter);
                            // if ( module ) 
                            property.Setter = setter;
                        }
                    }
 */
 
                    continue;
                    #endregion
                }

/* TODO: Implement this
                if (declaration is PROCEDURE_DECL)
                {
                    #region ProcedureDecl
                    NODE decl = unit.find_in_scope(declaration.name);
                    if (decl != null)
                    {
                        if (decl is UNKNOWN_DECL) decl = decl.resolve();
                        PROCEDURE_DECL proc = decl as PROCEDURE_DECL;
                        if (proc.prototype == null) SomeProcExists = true;
                        if (proc.prototype != null //&& proc.prototype.enclosing == this - obsolete
                            ) continue;
                        // It's OK: procedure is implemented in object/module
                    }
                    // Otherwise, it is not implemented.
                    // Looking through the default implementation for it...

                    // Otherwise, implementation exists
                    DEFINITION_DECL fdef = def;
                    while (decl == null && fdef != null)
                    {
                        IMPLEMENTATION_DECL implementation = fdef.default_implementation as IMPLEMENTATION_DECL;
                        if (implementation == null) // no implementation
                            goto NoImplementation;
                        decl = implementation.find(declaration.name);
                        if (decl.enclosing is DEFINITION_DECL) decl = null;
                        fdef = (DEFINITION_DECL)fdef.base_definition;
                    }
                    if (decl == null)  // no such entity in the implementation
                        goto NoImplementation;

                    // Entity exists
                    if (decl.enclosing is DEFINITION_DECL)  // the same situation as before
                        goto NoImplementation;

                    // Otherwise, 'implementation' unit contains (default)
                    // implementation of the procedure. Generating the "equivalent"
                    // in the module/object according the following scheme:
                    //
                    // definition D;             <== interface D {
                    //     procedure P;          <==     void P();
                    // end D.                    <== }
                    //
                    // implementation D;
                    //     procedure P implements D.P; begin ... end P;
                    // end D.
                    //                           <== class D_implem : D {
                    //                           <==     override void D.P () { ... }
                    //                           <== }
                    //
                    // object O implements D;    <== public sealed class O : D {
                    //                           <==     private D_implem D_mixed;
                    //                           <==     public void D.P() { D_mixed.P(); }
                    // end O.                    <== }

                    //  Method method = (Method)declaration.node.Clone();
                    PROCEDURE_DECL p = declaration as PROCEDURE_DECL;

                    Method method = new Method();
                    if (module)
                        method.CallingConvention = CallingConventionFlags.Default;
                    else
                        method.CallingConvention = CallingConventionFlags.HasThis;
                    method.DeclaringType = (TypeNode)unit.convert();
                    if (module)
                        method.Flags = MethodFlags.Public | MethodFlags.Static;
                    else
                        method.Flags = MethodFlags.NewSlot | MethodFlags.Public | MethodFlags.Virtual |
                                       MethodFlags.HideBySig | MethodFlags.Final;
                    if (!module)
                    {
                        method.ImplementedInterfaceMethods = new MethodList();
                        method.ImplementedInterfaceMethods.Add((Method)declaration.convert());
                        method.OverriddenMethod = (Method)declaration.convert();
                    }
                    method.Name = declaration.name;
                    method.Parameters = new ParameterList();
                    for (int j = 0, m = p.paramCount; j < m; j++)
                    {
                        Parameter tpar = (Parameter)p.parameters[j].convert();
                        if (tpar != null)
                        {
                            Parameter par = (Parameter)tpar.Clone();
                            par.DeclaringMethod = method;
                            method.Parameters.Add(par);
                        }
                        else
                        {
                            ERROR.UndeclaredUnit(sourceContext, "argument");
                        }
                    }
                    method.ReturnType = (TypeNode)p.return_type.convert();
                    method.SourceContext = decl.sourceContext;

                    method.Body = new Block(new StatementList());
                    MethodCall call = new MethodCall();
                    call.Callee = new QualifiedIdentifier(Identifier.For(mixedName),
                                                          Identifier.For(method.Name.Name));
                    call.Operands = new ExpressionList();
                    for (int j = 0, m = method.Parameters.Length; j < m; j++)
                        call.Operands.Add(Identifier.For(method.Parameters[j].Name.Name));
                    // TODO: take into account the passing rules like value/reference etc.
                    if (method.ReturnType == SystemTypes.Void)
                    {
                        ExpressionStatement call_stmt = new ExpressionStatement();
                        call_stmt.Expression = call;
                        call_stmt.SourceContext = decl.sourceContext;
                        method.Body.Statements.Add(call_stmt);
                    }
                    else
                    {
                        Return ret = new Return();
                        ret.Expression = call;
                        ret.SourceContext = decl.sourceContext;
                        method.Body.Statements.Add(ret);
                    }
                    cls.Members.Add(method);
                    continue;
                    #endregion
                }
                else
*/
                    continue;

            NoImplementation:
                ERROR.NoEntityImplementation(declaration.SourceContext,
                                             unit_kind, unit.name.Name, declaration.Name.Name);
                // Create dummy code for the entity - just to prevent
                // duplicated CCI message.
                if (SomeProcExists) continue;
                // Without this condition, two methods with the same name
                // are in the class, and I don't understand why CCI doesn't like this...
/*
                Method dummy = (Method)declaration.node.Clone();
                dummy.CallingConvention = CallingConventionFlags.HasThis;
                dummy.DeclaringType = (TypeNode)unit.convert();
                if (module)
                    dummy.Flags = MethodFlags.NewSlot | MethodFlags.Public | MethodFlags.HideBySig |
                                  MethodFlags.Final | MethodFlags.Static;
                else // object
                    dummy.Flags = MethodFlags.NewSlot | MethodFlags.Public | MethodFlags.Virtual |
                                  MethodFlags.HideBySig | MethodFlags.Final;
                dummy.ImplementedInterfaceMethods = new MethodList();
                dummy.ImplementedInterfaceMethods.Add((Method)declaration.convert());
                dummy.OverriddenMethod = (Method)declaration.convert();
                // dummy.Name        -- remains untouched
                // dummy.Parameters  -- remains untouched
                // dummy.ReturnType  -- remains untouched
                // dummy.SourceContext -- doesn't make any sense because this is just dummy
                dummy.Body = new Block(new StatementList());  // empty body

                cls.Members.Add(dummy);
                */
                continue;
            }

        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("EXTERNAL DECLARATION {0}:{1}",unique,base.name.Name);
            report_extra();

            base.report(shift+reportShift);
        }

        public override void report_short() {
            System.Console.Write("EXTERNAL DECLARATION {0}:{1}",unique,base.name.Name);
        }
#endif
    }

    // NAMESPACE_DECL
    // ==============
    // For a namespace which has been declared explicitly or
    // resolved to NAMESPACE (from UNKNOWN_DECL) during resolution.
    //
    // MODULE A.B.m;  <== Here A and B are represented as NAMESPACEs.
    //  ...
    //
    // MODULE m;
    //    IMPORT A.B;
    // END m.
    //
    // MODULE A.B.m2;  <== Here A and B are resolved to NAMESPACEs.
    //  ...
    //
    public sealed class NAMESPACE_DECL : UNIT_DECL {
        public NAMESPACE_DECL ( Identifier name ) : base(ASTNodeType.NAMESPACE_DECL, name) { }

        //--------------------------------------------------------------

        // FROM THE BASE:
        // public DECLARATION_LIST  locals; -- only UNIT_DECLs
        // public BLOCK             body;   -- doesn't exist

        //--------------------------------------------------------------

        // Creates new (empty) namespace and adds it to the program tree.
        // Notice that namespaces are created only while processing qualified-ids;
        // there is no way to explicitly define namespace in the language.
        //
        public static NAMESPACE_DECL create(Identifier id, NAMESPACE_DECL enclosing) {
            NAMESPACE_DECL ns = new NAMESPACE_DECL(id);

            ns.enclosing     = enclosing;
            // ns.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor
            enclosing.locals.Add(ns);  // 'enclosing' should be non-null

            return ns;
        }

        //---------------------------------------------------------------------

        public override NODE findExcludingDefs(Identifier name) {
            return this.find(name);
        }


        public override NODE find(Identifier name) {
         // if ( this != TREE.global ) // normal search
            NODE result = base.find(name);
            if ((result == null) && (enclosing != null))
                result = enclosing.find(name);
            return result;
        }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            for (int i = 0; i < locals.Length; i++)            
            {
                if (locals[i] == null) continue;
                NODE scope = locals[i].findScopeAtContext(line, col, documentName);
                if (scope != null)
                    return scope;
            }
            return null;
        }
        //---------------------------------------------------------------------

        public override NODE resolve() {
            if (this != CONTEXT.globalTree)
                if (!ErrorReported && (EXTERNALS.findType(NODE.generateFullName(this.enclosing), name) != null))
                {
                    ERROR.NamespaceAndTypeHaveSameName(this.sourceContext, Name);
                    ErrorReported = true;
                }

            for (int i = 0; i < locals.Length; i++) if (locals[i]!=null) locals[i].resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o ...
            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // makes no sense for namespaces
        {
            get { return null; }
            set { }
        }

        //------------------------------------------------------------------------------

        private bool visited = false;

        public override Node convert() {
            if (visited)
                return null;
            visited = true;

         // resolve(); -- no need
            if (!validate())
                return null;

         // // convert() for NAMESPACE_DECL works in the different way
         // // than other convert()s: it generates CCI nodes for all
         // // units from the namespace and puts them directly to the
         // // global tree which is CCI's CompilationUnit node.
         //
         // CompilationUnit cu = TREE.globalCU; ////////////////////
         //
         // for ( int i=0, n=locals.Length; i<n; i++ )
         // {
         //     DECLARATION local = locals[i];
         //
         //     if ( local == null ) continue;
         //
         //     if ( local is NAMESPACE_DECL )
         //     {
         //         local.convert();  // in fact, just recursive call
         //     }
         //     else  // UNKNOWN_DECL, or EXTERNAL_DECL, or another UNIT_DECL
         //     {
         //         Node unit = local.convert();
         //         if ( unit is Namespace ) // it's OK; adding
         //             cu.Namespaces.Add((Namespace)unit);
         //      // else
         //      //     -- can be Identifier for EXTERNAL_DECL; do nothing
         //     }
         // }
         // return null;

            Namespace ns = new Namespace();
            ns.Types = new TypeNodeList();
            ns.UsedNamespaces = new UsedNamespaceList();
            ns.NestedNamespaces = new NamespaceList();
            ns.Name = base.name;
            ns.FullNameId = Identifier.For(NODE.generateFullName(this));
            node = ns;

            for (int i = 0, n = locals.Length; i < n; i++) {
                DECLARATION local = locals[i];
                if (local == null)
                    continue;
                if (local is UNKNOWN_DECL) continue; // Should not care from here
                Node loc = local.convert();
                if (loc == null)
                    continue;
                if (loc is TypeNode)
                    ns.Types.Add((TypeNode)loc);
                else if (loc is Namespace)
                    ns.NestedNamespaces.Add((Namespace)loc);
            }
         // node = ns;
            return node;
        }

        //-----------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("NAMESPACE {0}, line={1}",base.name!=null ? base.name.ToString() : "GLOBAL", this.sourceContext.StartLine.ToString());
            report_extra();
            if ((comments != null) && (comments.Length > 0)) {
				for (int i = 0; i < comments.Length; i++)
					comments[i].report(shift + reportShift);
			}

            base.report(shift+reportShift);
        }

        public override void report_short() {
            System.Console.Write("NAMESPACE {0}:{1}",unique,base.name.Name);
        }
#endif
    }

    // IMPORTSPACE_DECL
    // ==============
    // A helper for qualified import names
    
    // MODULE A.B.m;  <== Here A and B are represented as NAMESPACEs.
    //  ...
    //
    // MODULE m;
    //    IMPORT A.B.m; <== Here A and B are represented as IMPORTSPACEs.
    // END m.
    //
    //  ...
    //

    public sealed class IMPORTSPACE_DECL : UNIT_DECL {
        public IMPORTSPACE_DECL(Identifier name) : base(ASTNodeType.NAMESPACE_DECL, name) { }

        //--------------------------------------------------------------

        // FROM THE BASE:
        // public DECLARATION_LIST  locals; -- contain IMPORTSPACE_DECL or IMPORT_DECL
        // public BLOCK             body;   -- doesn't exist

        //---------------------------------------------------------------------

        public override NODE findExcludingDefs(Identifier name) {
            return locals.find(name);
        }

        public override NODE find(Identifier name) {
            NODE result = locals.find(name);
            return result;
        }

        //---------------------------------------------------------------------

        public override NODE resolve() {
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            // o ...
            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // makes no sense for namespaces
        {
            get { return null; }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null) return node;
            // Import declaration can return Field
            // Collect all and create a member list to return to parent            
            NameBinding list = new NameBinding(); // Use class to pass members
            node = list;
            list.BoundMembers = new MemberList();
            //TODO: When refactoring remove this misuse of NameBinding
            
            for (int i = 0; i < locals.Length; i++) {
                Node ls = locals[i].convert();
                // It can be null, Field or MemberList
                if (ls == null)
                    continue;
                if (ls is NameBinding) // Process each element of Members
                {
                    foreach (Field n in ((NameBinding)ls).BoundMembers) {
                        //Extend name
                        n.Name = new Identifier(name + "_" + n.Name.Name);
                        list.BoundMembers.Add(n);
                    }
                }
                if (ls is Field) {
                    //Extend name
                    Field n = ls as Field;
                    n.Name = new Identifier(name + "_" + n.Name.Name);
                    list.BoundMembers.Add(n);
                }
            }

            return list;
        }

        //-----------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("IMPORTSPACE {0}, line={1}", base.name != null ? base.name.ToString() : "GLOBAL", this.sourceContext.StartLine.ToString());
            report_extra();
            if ((comments != null) && (comments.Length > 0)) {
                for (int i = 0; i < comments.Length; i++)
                    comments[i].report(shift + reportShift);
            }

            base.report(shift + reportShift);
        }

        public override void report_short() {
            System.Console.Write("IMPORTSPACE {0}:{1}", unique, base.name.Name);
        }
#endif
    }

    // MODULE_DECL
    // ===========
    //
    // Module = MODULE ModuleName [ ImplementationClause ] ";"
    //            [ ImportDeclaration ]
    //              ModuleDeclarations
    //            ( BlockStatement | END ) SimpleName.
    //
    // ImplementationClause = IMPLEMENTS DefinitionName { "," DefinitionName }.
    //
    // ModuleDeclarations = { SimpleDeclarations | NestedUnit ";" }
    //                      { ProcedureDeclaration | OperatorDeclaration }
    //                      { ActivityDeclaration }.
    //
    // NestedUnit = ( Definition | Implementation | Object ).
    //
    // ImportList = IMPORT Import { "," Import } ";".
    //
    public sealed class MODULE_DECL : UNIT_DECL {
        // Constructor
        public MODULE_DECL(Identifier name)
            : base(ASTNodeType.MODULE_DECL, name) {
            definitions = new UNIT_DECL_LIST();
        }

        //--------------------------------------------------------------

     // FROM THE BASE:
     // public DECLARATION_LIST  locals; -- imports, members, procedures, activities,
     //                                     nested units - all kinds of DECLARATIONs
     // public BLOCK             body;   -- module body

        public UNIT_DECL_LIST    definitions;  // definitions implemented by this module

        //---------------------------------------------------------------

        public override NODE findExcludingDefs(Identifier name) {
            return base.find(name);
        }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            for (int i = 0; i < locals.Length; i++) {
                if (locals[i] == null)
                    continue;
                scope = locals[i].findScopeAtContext(line, col, documentName);
                if (scope != null)
                    break;
            }
            if(scope == null && body != null)
                scope = body.findScopeAtContext(line, col, documentName);
            
            return scope;
        }

        public override NODE find(Identifier name) {
            NODE result = base.find(name);

            if ( result is UNKNOWN_DECL && !CONTEXT.firstPass )
                result = null; // Try to find member in implemented definitions

            if ( result == null && definitions != null && definitions.Length > 0 )
                for ( int i=0, n=definitions.Length; i<n; i++ )
                    if ((result = definitions[i].find(name)) != null)
                        return result;

            return result;
        }

        //--------------------------------------------------------------

        // The function creates the structure for a new module
        // (its name is taken from the last name of the 'name' parameter)
        // and adds it to the current context.
        //
        // Also the function calls UNIT_DECL.processName() to build all
        // necessary namespaces "around" the module. The names are taken
        // from the 'name' parameter.
        //
        public static MODULE_DECL create(IDENT_LIST name, MODIFIERS modifiers) {
            Identifier id = name[name.Length-1];

            // First, create module itself.
            MODULE_DECL module = new MODULE_DECL(id);
         // module.body        -- will be filled later
         // module.definitions -- will be filled later
         // module.enclosing   -- will be set by processName()
         // module.full_name
         // module.locals      -- will be filled later
         // module.sourceContext
            module.modifiers = modifiers;            

            // Second, build the context; in particular,
            // 'enclosing' field will be set.
            DECLARATION anotherUnit = UNIT_DECL.processName(module,name);

            // Then, check the nesting
            NODE context = CONTEXT.current;
            if ( context != null && !(context is NAMESPACE_DECL) )
                // Cannot declare module in any compilation unit
                ERROR.IllegalNesting("module within any compilation unit");

            // Set access rules
            if (!module.modifiers.Public && !module.modifiers.Private) {
                // There were no explicit modifiers; set them.
                module.modifiers.Public = true;  // I am not sure...
            }

            // Check the uniqueness of the module name.
            if (anotherUnit != null) {
///////         bool err = true;

                // There IS a unit or namespace with the same name
                // in the same scope!
                if (anotherUnit is NAMESPACE_DECL) {
                    // 'anotherUnit' is NOT a real unit (i.e., it is a NAMESPACE)
                    // Message:
                    // cannot declare <unit> <name>: there is <namespace> with the same name in the current scope
                    ERROR.IncorrectUnitName("module",anotherUnit.name.Name,"namespace");
                } else if (anotherUnit is MODULE_DECL) {
                    // Message:
                    // duplicate declaration of <unit_name> <name>
                    ERROR.DuplicateUnit("module",anotherUnit.name.Name);
                } else if (anotherUnit is UNKNOWN_DECL) {
                    // There is unresolved external unit with the same name; resolve it!
                    UNKNOWN_DECL anotherModule = anotherUnit as UNKNOWN_DECL;
                    anotherModule.name = null;
                    anotherModule.RealDeclaration = module;
///////             err = false;
                } else // anotherUnit is an object, definition or implementation
                {
                    // cannot declare <unit> <name>: there is <another unit> with the same name in the current scope
                    ERROR.IncorrectUnitName("module",anotherUnit.name.Name,"another unit");
                }
////////        if ( err ) module.name = ERROR.errUnitName; // null;  // now nobody finds this module :-)
            }
            // else -- NO unit with given name; that's OK.

            // Add new module to the current context.
            CONTEXT.enter(module);
            return module;
        }

        //--------------------------------------------------------------

        public override NODE resolve() {
            if (resolved()) return this;
            if (modifiers.Actor) modifiers.Protected = true;
            for (int i = 0, n = this.definitions.Length; i < n; i++) {
                UNIT_DECL resvd = this.definitions[i].resolve() as UNIT_DECL;
                if (resvd == null) {
                    // Error will be reported later
                } else {
                    this.definitions[i] = resvd;
                    /* WE DO NOT DO THAT
                    UNIT_DECL curdef = this.definitions[i];
                    while (curdef != null)
                    {
                        IDENT_LIST idl = new IDENT_LIST();
                        string s = NODE.generateFullName(curdef);
                        string[] ss = s.Split('.');
                        foreach (string nm in ss) idl.Add(Identifier.For(nm));

                        this.addImportedUnit(idl, curdef, null, true);

                        UNIT_DECL basedef = null;
                        if (curdef is DEFINITION_DECL)
                        {
                            DEFINITION_DECL def = (DEFINITION_DECL)curdef;
                            basedef = def.base_definition; // There is a base def. Need to add import                    
                        }
                        else if (curdef is EXTERNAL_DECL)
                        {
                            EXTERNAL_DECL def = (EXTERNAL_DECL)curdef;
                            if (def.entity is Interface && ((Interface)(def.entity)).Interfaces.Length > 0)
                            {
                                // definition can refine only one definition
                                basedef = new EXTERNAL_DECL(((Interface)(def.entity)).Interfaces[0]);
                            }
                        }
                        curdef = basedef;
                    }
                     * */
                }
            }

            for (int i = 0, n = this.locals.Length; i < n; i++)
                if (this.locals[i] is PROCEDURE_DECL)
                    if (((PROCEDURE_DECL)locals[i]).modifiers.Shared)
                        this.modifiers.Shared = true;
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check that there is no external type that already declares this top level unit
            if(!ErrorReported)
            if (EXTERNALS.findType(NODE.generateFullName(enclosing), this.name) != null)
            {
                ERROR.DuplicateDeclaration(this.sourceContext, NODE.generateFullName(this));
                ErrorReported = true;
            }
            for (int i = 0, n = this.locals.Length; i < n; i++)
                if (this.locals[i] is TYPE_DECL) this.locals[i].validate();
            return true;
        }

        //------------------------------------------------------------------------------

        public override TYPE type  // makes no sense for modules
        {
            get { return null; }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve(); 
            if (!validate())
                return null;

            if ( base.name == null ) // there were errors; don't generate the tree...
                return null;

            Class cls = new Class();      // Zonnon module is mapped to CLI class
            node = cls;   // assigning immediately; otherwise infinite recursion!

            UNIT_DECL saved = CONTEXT.current_unit;
            ROUTINE_DECL saved2 = CONTEXT.current_routine;
            CONTEXT.current_unit = this;
            CONTEXT.current_routine = null;

            // Creating FieldInitializerBlock.
            // This is the special structure for collecting members' initializers.
            // Later (see below) this structure will become a part of the static ctor's body.
            // The idea is that CCI will collect field initializers in it.
            // So we leave it empty assuming that CCI will fill it by its own.
            FieldInitializerBlock initializers = new FieldInitializerBlock();
            initializers.Statements = new StatementList();
            initializers.IsStatic = true;
            initializers.Type = cls;

            // Actually we will collect initializers to this list,
            // and after completing member processing we will move
            // the contents of the list to the static ctor's body.
            StatementList init_statements = new StatementList();

            bool isMainModule = CONTEXT.options!=null && CONTEXT.options.MainModule==this.name.Name;
            if (isMainModule)
                ((ZonnonCompilation)CONTEXT.compilation).wasMainModule = true;

          //  cls.Attributes;
         // cls.BaseClass =
         // cls.BaseType
         // cls.ClassSize
            cls.DeclaringModule = CONTEXT.symbolTable;
            if ( enclosing != null && !(enclosing is NAMESPACE_DECL) )
                cls.DeclaringType = (TypeNode)enclosing.convertAndGetType();
            CONTEXT.symbolTable.Types.Add(cls);
         // cls.DefaultMembers
         // cls.ExplicitCoercionMethods
            cls.Flags = TypeFlags.Sealed;
            if (modifiers.Public)
                cls.Flags |= TypeFlags.Public;  // public sealed class ...
            else
                cls.Flags |= TypeFlags.NotPublic;
         // cls.ImplicitCoercionMethods
         // cls.FullName
            cls.Name = Identifier.For(base.name.Name);
            cls.Namespace = Identifier.For(NODE.generateFullName(enclosing));
         // cls.NodeType -- already set
         // cls.PackingSize
            cls.SourceContext = base.sourceContext;
         // cls.Template
         // cls.TemplateArguments
         // cls.TemplateParameters
         // cls.TypeCode

            // Converting implemented definitions
            // Notice that we don't generate interfaces for modules 
            // because it just doesn't make any sense...
            //
            // YES and NO: in general it doesn't, but if a module uses something
            // from definition we should be sure it uses exactly that entity...
            // Anyway now I still add interface to the module (see the end of the loop body).

            cls.Interfaces = new InterfaceList();
            for (int i = 0, n = definitions.Length; i < n; i++) {
                DECLARATION unit = (DECLARATION)definitions[i].resolve();
                if ( unit == null ) continue;
                if (!(unit is EXTERNAL_DECL))
                {
                    if (!(unit is DEFINITION_DECL) && !(unit is IMPLEMENTATION_DECL))
                    {
                        if (!unit.ErrorReported)
                        {
                            unit.ErrorReported = true;
                            ERROR.WrongDefinitionName(this.sourceContext, unit.name.Name);
                        }
                        continue;
                    }
                if (unit is IMPLEMENTATION_DECL) {
                        string impl_name = unit.name.Name;
                        SourceContext context = unit.sourceContext;

                        unit = ((IMPLEMENTATION_DECL)unit).implemented_definition;
                    if (unit == null) {
                            ERROR.NoDefinition(context, impl_name);
                            continue;
                        }
                    }

                    // Adding items from the implemented definition and/or default implementation
                    ((DEFINITION_DECL)unit).convertSatellite(this, true);

                    unit.convert();
                }
                //Node result = unit.convertAndGetType();
                //if ( result is Interface ) cls.Interfaces.Add((Interface)result);
            }

            // Converting members.
            // If there are initializers for members then we collect them
            // in our own init-statements list and later move them all to
            // static ctor's body. Notice that we do not use FieldInitializerBlock structure
            // for those initializers because CCI expects this structure is empty.

            if (cls.Members == null)
                cls.Members = new MemberList();
            for (int i = 0, n = locals.Length; i < n; i++) {
                DECLARATION local = locals[i];
                if (local is UNKNOWN_DECL)
                    continue;

                if (local is PROCEDURE_DECL) {
                    PROCEDURE_DECL procedure = local as PROCEDURE_DECL;
                    if ( procedure.prototype != null &&
                         ( procedure.modifiers.Getter || procedure.modifiers.Setter ) )
                        // This procedure has been already converted while processing interfaces
                        // (see above)
                        continue;
                }

                Node member = local.convert();
                if ((member is Member) && (local.type is ARRAY_TYPE)) {
                    //adding metadata
                    InstanceInitializer ii_v = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
                    MemberBinding attrBinding_v = new MemberBinding(null, ii_v);
                    ExpressionList args_v = new ExpressionList();
                    if ((local.type as ARRAY_TYPE).isMath)
                        args_v.Add(new Literal("math array", SystemTypes.String));
                    else
                        args_v.Add(new Literal("simple array", SystemTypes.String));
                    AttributeNode attrNode_v = new AttributeNode(attrBinding_v, args_v, AttributeTargets.All);
                    (member as Member).Attributes.Add(attrNode_v);
                }

                if (local is VARIABLE_DECL) {
                    Block array_initializers = ((VARIABLE_DECL)local).createElementInitializer();
                    // ROTOR problem
                    if ( array_initializers != null )
                        init_statements.Add(array_initializers);
                } else if (locals[i] is ACTIVITY_DECL) {
                    // Take activity launcher from 'node1' field
                    cls.Members.Add((locals[i] as ACTIVITY_DECL).node1);
                    // Take activity body image
                    cls.Members.Add((Member)member);
                    continue; // to prevent duplicating (see the Add call below)
                }else
                    if (locals[i] is IMPORTSPACE_DECL) {
                    foreach (Member m in ((NameBinding)member).BoundMembers)
                        cls.Members.Add(m);
                }
                
                if (member is Member) {
                    cls.Members.Add((Member)member);
                } else if (member is Interface) // nested definition
                {
                    cls.Members.Add((Interface)member);
                }
            }

            // Generate private constructor
            // (to prevent creating module instances):
            //
            //        private M ( )
            //        {
            //        }

            InstanceInitializer privateCtor = new InstanceInitializer();

            privateCtor.Body = new Block();
            privateCtor.Body.Statements = new StatementList(); // empty body
            privateCtor.Body.HasLocals = false;
            privateCtor.DeclaringType = cls;
            privateCtor.Flags = MethodFlags.Private | MethodFlags.SpecialName | MethodFlags.RTSpecialName;
         // privateCtor.FullName
            privateCtor.InitLocals = false;
         // privateCtor.Name -- no name for ctor!
            privateCtor.Parameters = new ParameterList();  // empty list (no params)
            privateCtor.ReturnType = SystemTypes.Void;
            privateCtor.SourceContext = this.sourceContext;

            cls.BaseClass = SystemTypes.Object;
            //TODO: To figure out why we need that at all
            MethodCall superCtorCall =
                new MethodCall(new QualifiedIdentifier(new Base(), StandardIds.Ctor), null, NodeType.Call); 
            privateCtor.Body.Statements.Add(new ExpressionStatement(superCtorCall));

            cls.Members.Add(privateCtor);

            // Generate static constructor.
            // For "main" module static constructor contains only static initializers:
            //
            //        public static M ( )
            //        {
            //            ---------------------------------
            //            initializations of the module local declarations
            //            ---------------------------------
            //        }
            //
            // For other modules static constructor contains static initializers
            // and statements from the module's body.
            //
            //        public static M ( )
            //        {
            //            ---------------------------------
            //            Initializations of the module local declarations;
            //            Statements from the module's body
            //            ---------------------------------
            //        }

            StaticInitializer staticCtor = new StaticInitializer();

            staticCtor.Body = new Block();
            staticCtor.Body.Checked = false;  // ???
            staticCtor.Body.HasLocals = false;
            staticCtor.Body.Statements = new StatementList();
         // staticCtor.Body.NodeType;

            // Adding field initializers - in fact, nothing...
            staticCtor.Body.Statements.Add(initializers);
            // Adding "real" field initializers
            for ( int i=0, n=init_statements.Length; i<n; i++ )
                staticCtor.Body.Statements.Add(init_statements[i]);

            if (!isMainModule) {
                if ( base.body.statements.Length > 0 ) // can be 0 because of pasre errors
                    staticCtor.Body.SourceContext = base.body.statements[0].sourceContext;
                                

                // First convert the body to make sure the flag is set.
                Statement objectBody = (Statement)(base.body.convert());
                //
                if (activeBody)
                { // Create a method and call it in a new thread
                    //CRATE A METHOD
                    Method activity = new Method();
                    activity.Body = new Block();
                    activity.Body.Checked = false;  // ???
                    activity.Body.HasLocals = true;
                    // activity.Body.NodeType;
                    activity.Body.SourceContext = this.sourceContext;
                    activity.Parameters = new ParameterList(0);
                    activity.Body.Statements = new StatementList();                                        

                    Block abody = new Block();
                    abody.Statements = new StatementList();
                    abody.HasLocals = true;
                    abody.SourceContext = sourceContext;

                    bool RWL = enclosing.modifiers.Protected && enclosing.modifiers.Shared;
                    bool Shared = this.modifiers.Shared;

                    Try try_catch = new Try();
                    try_catch.TryBlock = new Block();
                    try_catch.TryBlock.Statements = new StatementList();

                    // Acquire the lock and let the constructor finish
                    try_catch.TryBlock.Statements.Add(AWAIT.EvictLockEnter(RWL, Shared));
                    // TODO: Add auto reset to let the constructor finish

                    try_catch.TryBlock.Statements.Add(objectBody);

                    ///=====
                    try_catch.Finally = new Finally();
                    try_catch.Finally.Block = new Block();
                    try_catch.Finally.Block.Statements = new StatementList();
                    try_catch.Finally.Block.Statements.Add(AWAIT.EvictLockLeave(RWL, Shared));

                    activity.Body.Statements.Add(try_catch);
                    activity.DeclaringType = (TypeNode)node;
                    activity.Flags = MethodFlags.Private | MethodFlags.Static;                    
                    activity.InitLocals = true;
                    activity.Name = Identifier.For("_activeBody");
                    activity.ReturnType = SystemTypes.Void;
                    activity.SourceContext = this.sourceContext;
                    cls.Members.Add(activity);

                    // CALL THE METHOD
                    AssemblyNode system = AssemblyNode.GetAssembly(typeof(System.String).Assembly);
                    TypeNode thread = system.GetType(Identifier.For("System.Threading"), Identifier.For("Thread"));
                    TypeNode threadStartD = system.GetType(Identifier.For("System.Threading"), Identifier.For("ThreadStart"));

                    // new Thread(new Delegate(_activeBody)).Start();
                    ConstructDelegate delg = new ConstructDelegate();
                    delg.DelegateType = threadStartD;
                    delg.MethodName = Identifier.For("_activeBody");
                    delg.TargetObject = new This();
                    delg.TargetObject.Type = cls;

                    Construct construct = new Construct();
                    construct.Constructor = new MemberBinding(null, thread); // Hope they won't change the order
                    construct.Constructor.Type = SystemTypes.Type;
                    construct.SourceContext = this.sourceContext;
                    construct.Type = thread;
                    construct.Operands = new ExpressionList();
                    construct.Operands.Add(delg);

                    MethodCall mf = new MethodCall();

                    mf.Callee = new MemberBinding(null, thread.GetMethod(Identifier.For("MemoryBarrier"), new TypeNode[] { }));
                    mf.GiveErrorIfSpecialNameMethod = false; // ??
                    mf.IsTailCall = false;
                    mf.Operands = new ExpressionList();
                    mf.SourceContext = this.sourceContext;
                    mf.Type = SystemTypes.Void;

                    staticCtor.Body.Statements.Add(new ExpressionStatement(mf, this.sourceContext));

                    MethodCall invoke = new MethodCall();

                    invoke.Callee = new MemberBinding(construct, thread.GetMethod(Identifier.For("Start"), new TypeNode[] { }));
                    invoke.GiveErrorIfSpecialNameMethod = false; // ??
                    invoke.IsTailCall = false;
                    // invoke.NodeType
                    invoke.Operands = new ExpressionList();
                    invoke.SourceContext = this.sourceContext;
                    invoke.Type = SystemTypes.Void;

                    staticCtor.Body.Statements.Add(new ExpressionStatement(invoke, this.sourceContext));

                }
                else
                { //Noraml body -> part of the constructor
                    staticCtor.Body.Statements.Add(objectBody);
                }
            }
         // staticCtor.Body.UniqueKey
         // staticCtor.CallingConvention;
            staticCtor.DeclaringType = cls;
         // staticCtor.Ensures;
         // staticCtor.ExceptionHandlers;
            staticCtor.Flags = MethodFlags.Public | MethodFlags.Static |
                               MethodFlags.SpecialName | MethodFlags.RTSpecialName;
         // staticCtor.ImplementedInterfaceMethod;
         // staticCtor.ImplementedInterfaceMethods;
         // staticCtor.ImplementedTypes;
         // staticCtor.ImplFlags;
            staticCtor.InitLocals = true;
         // staticCtor.Name -- no name for ctor!
         // staticCtor.NodeType;
            staticCtor.Parameters = null;  // no params for static ctor
         // staticCtor.PInvokeFlags;
         // staticCtor.PInvokeImportName;
         // staticCtor.PInvokeModule;
         // staticCtor.Requires;
         // staticCtor.ReturnAttributes;
            staticCtor.ReturnType = SystemTypes.Void;
         // staticCtor.Scope;
            staticCtor.SourceContext = base.sourceContext;
         // staticCtor.Template;
         // staticCtor.TemplateArguments;
         // staticCtor.TemplateParameters;
         // staticCtor.UniqueKey;

            cls.Members.Add(staticCtor);

            if (isMainModule) {
                // This module is the MAIN program module; so, we generate
                // the following two methods:
                //
                //        public static void _body ( )
                //        {
                //            ---------------------------------
                //            statements from the module's body
                //            ---------------------------------
                //        }
                //
                //        public static int Main ( )
                //        {
                //            try {
                //                _body();
                //                return 0;
                //            }
                //            catch ( Zonnon.RTL.Halt h ) {
                //                return h.returnCode;
                //            }
                //        }

                Method body = new Method();

             // body.Attributes;
                body.Body = new Block();

                body.Body.Checked = false;  // ???
                body.Body.HasLocals = false;
             // body.Body.NodeType;
                if ( base.body.statements.Length > 0 ) // can be 0 because of pasre errors
                    body.Body.SourceContext = base.body.statements[0].sourceContext;
                body.Body.Statements = new StatementList();

                if (modifiers.Protected)
                {                    
                    bool RWL = enclosing.modifiers.Protected && enclosing.modifiers.Shared;
                    bool Shared = this.modifiers.Shared;

                    Try try_catch = new Try();
                    try_catch.TryBlock = new Block();
                    try_catch.TryBlock.Statements = new StatementList();

                    // Acquire the lock and let the constructor finish
                    try_catch.TryBlock.Statements.Add(AWAIT.EvictLockEnter(RWL, Shared));
                    // Add auto reset to let the constructor finish

                    try_catch.TryBlock.Statements.Add((Statement)(base.body.convert()));

                    ///=====
                    try_catch.Finally = new Finally();
                    try_catch.Finally.Block = new Block();
                    try_catch.Finally.Block.Statements = new StatementList();
                    try_catch.Finally.Block.Statements.Add(AWAIT.EvictLockLeave(RWL, Shared));
                    body.Body.Statements.Add(try_catch);
                }
                else
                {
                    body.Body.Statements.Add((Statement)base.body.convert());
                }

             // body.Body.UniqueKey

             // body.CallingConvention;
                body.DeclaringType = cls;
             // body.Ensures;
             // body.ExceptionHandlers;
                body.Flags = MethodFlags.Public | MethodFlags.Static;
             // body.ImplementedInterfaceMethod;
             // body.ImplementedInterfaceMethods;
             // body.ImplementedTypes;
             // body.ImplFlags;
                body.InitLocals = true;
                body.Name = Identifier.For("_body"); // _"+base.name.Name);
             // body.NodeType;
                body.Parameters = null;  // no params
             // body.PInvokeFlags;
             // body.PInvokeImportName;
             // body.PInvokeModule;
             // body.Requires;
             // body.ReturnAttributes;
                body.ReturnType = SystemTypes.Void;

             // body.Scope;
                body.SourceContext = base.sourceContext;
             // body.Template;
             // body.TemplateArguments;
             // body.TemplateParameters;
             // body.UniqueKey;

                cls.Members.Add(body);

                Method main = new Method();

             // main.Attributes;
                main.Body = new Block();
                main.Body.Checked = false;  // ???
                main.Body.HasLocals = false;
                main.Body.Statements = new StatementList();  // otherwise, CCI crashes

                // try { ... } catch (...) {...}
                //
                Try try_statement = new Try();
                try_statement.TryBlock = new Block();
                try_statement.TryBlock.Statements = new StatementList();

                // try { _body(); ... } catch (...) {...}
                //       =======
                MethodCall body_call = new MethodCall(Identifier.For("_body"),new ExpressionList());
                ExpressionStatement body_call_statement = new ExpressionStatement(body_call);
                try_statement.TryBlock.Statements.Add(body_call_statement);

                // try { _body(); return 0; } catch (...) {...}
                //                ========
                Return return_statement = new Return();
                return_statement.Expression = new Literal(0,SystemTypes.Int32);
                try_statement.TryBlock.Statements.Add(return_statement);

                // try { _body(); return 0; } catch (...) {...}
                //
                try_statement.Catchers = new CatchList();
                Catch catch_handler = new Catch();

                // try { _body(); return 0; } catch (Zonnon.RTL.Halt h) {...}
                //                                   =================
                catch_handler.TypeExpression = null; //////////////////////////////???;
                catch_handler.Type = STANDARD.HaltException;
                catch_handler.Variable = Identifier.For("h");

                // try { _body(); return 0; } catch (Zonnon.RTL.Halt h) { return h.returnCode;}
                //                                                        ===================
                catch_handler.Block = new Block(new StatementList());

                return_statement = new Return();
                return_statement.Expression = new QualifiedIdentifier(Identifier.For("h"),
                                                                      Identifier.For("returnCode"));
                catch_handler.Block.Statements.Add(return_statement);

                try_statement.Catchers.Add(catch_handler);

                main.Body.Statements.Add(try_statement);
             // main.Body.UniqueKey

             // main.CallingConvention;
                main.DeclaringType = cls;
             // main.Ensures;
             // main.ExceptionHandlers;
                main.Flags = MethodFlags.Public | MethodFlags.Static;
             // main.ImplementedInterfaceMethod;
             // main.ImplementedInterfaceMethods;
             // main.ImplementedTypes;
             // main.ImplFlags;
                main.InitLocals = true;
                main.Name = Identifier.For("Main");
             // main.NodeType;
                main.Parameters = new ParameterList(0);  // no params
             // main.PInvokeFlags;
             // main.PInvokeImportName;
             // main.PInvokeModule;
             // main.Requires;
             // main.ReturnAttributes;

                main.ReturnType = SystemTypes.Int32;
             // main.Scope;
                main.SourceContext = base.sourceContext;
             // main.Template;
             // main.TemplateArguments;
             // main.TemplateParameters;
             // main.UniqueKey;
                cls.Members.Add(main);

                AssemblyNode system = AssemblyNode.GetAssembly(typeof(System.String).Assembly);
                TypeNode stastr = system.GetType(Identifier.For("System"), Identifier.For("STAThreadAttribute"));

                //adding metadata

                MemberBinding aBinding = new MemberBinding(null, stastr.GetConstructor());                
                AttributeNode aNode = new AttributeNode(aBinding, new ExpressionList(), AttributeTargets.All);
                main.Attributes.Add(aNode);
            }

            if (!isMainModule) {
                // Add
                // public static void _empty ( ) { }

                Method empty = new Method();

                empty.Body = new Block(new StatementList());
                empty.DeclaringType = cls;
                empty.Flags |= MethodFlags.Static | MethodFlags.Public;
                empty.Parameters = new ParameterList();
                empty.ReturnType = SystemTypes.Void;
                empty.Name = Identifier.For("_empty");

                cls.Members.Add(empty);

                // 'modules' list (see NODE) contains all modules (= classes) 
                // generated by the compiler; we need it to create the dialogue
                // function in case of 'EmbeddeDialogue' mode 
                // (see TREE.prepare() method in Context.cs).
                NODE.modules.Add(cls);
            }

            // Owner thread
            if (modifiers.Protected)
            {
                Field field = new Field();
                field.DeclaringType = (TypeNode)this.convertAndGetType();
                field.DefaultValue = null;
                field.Flags = FieldFlags.Private | FieldFlags.Static;
                field.IsVolatile = true;
                field.Name = Identifier.For("_ctowner");
                field.SourceContext = sourceContext;

                field.Type = SystemTypes.Int32;
     
                field.Initializer = new Literal((int)0, SystemTypes.Int32);

                cls.Members.Add((Member)field);
            }
            /* Only for RWL which we do not use
            // Generating _lock property for protected objects
            // (this piece of code copied from convert() for OBJECT_DECL).
            if (modifiers.Protected && modifiers.Shared) {
                Field field = new Field();
                field.DeclaringType = (TypeNode)this.convertAndGetType();
                field.DefaultValue = null;
                field.Flags = FieldFlags.Private | FieldFlags.Static;
                field.IsVolatile = true;
                field.Name = Identifier.For("_lock");
                field.SourceContext = sourceContext;

                field.Type = (TypeNode)STANDARD.objectLock.type.convert();				

                Construct construct = new Construct();
                construct.Constructor = new MemberBinding(null,field.Type);
                construct.Constructor.Type = SystemTypes.Type;
                construct.Type = field.Type;
                construct.Operands = new ExpressionList();

                field.Initializer = construct;

                cls.Members.Add((Member)field);
            }
            */

            // Now we perform the last action: we scan all definitions
            // implemented by this module and check whether all their
            // entities are actually implemented by the object.
            // If there are unimplemented entities we try to find
            // the implementation in the implementation unit associated
            // with this definition.
            for (int i = 0, n = this.definitions.Length; i < n; i++) {
                DECLARATION def = (DECLARATION)definitions[i].resolve();
                DEFINITION_DECL definition = null;
                if ( def is DEFINITION_DECL )
                    definition = (DEFINITION_DECL)def;
                else if ( def is IMPLEMENTATION_DECL )
                    definition = (DEFINITION_DECL)((IMPLEMENTATION_DECL)def).implemented_definition.resolve();

                if (definition == null)
                    continue;
                definition.addUnimplementedEntities(this,true, this.prefixesForMixed[i]);
            }

            //adding metadata
            InstanceInitializer ii = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
            MemberBinding attrBinding = new MemberBinding(null, ii);
            ExpressionList args = new ExpressionList();
            args.Add(new Literal("module", SystemTypes.String));
            AttributeNode attrNode = new AttributeNode(attrBinding, args, AttributeTargets.All);
            cls.Attributes.Add(attrNode);

            CONTEXT.current_unit = saved;
            CONTEXT.current_routine = saved2;
            return node;
        }

        //------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            if (modifiers.Public)
                System.Console.Write("PUBLIC ");
            else
                System.Console.Write("PRIVATE ");
            System.Console.Write("MODULE ");
            if (base.name == null)
                System.Console.Write("<UNNAMED>");
            else
                System.Console.Write("{0}", base.name.Name);
			System.Console.Write(" line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            if ((comments != null) && (comments.Length > 0)) {
				for (int i = 0; i < comments.Length; i++)
					comments[i].report(shift + reportShift);
			}

            base.report(shift+reportShift);
        }

        public override void report_short() {
            System.Console.Write("MODULE {0}:",unique);
            if (name == null)
                System.Console.Write("<UNNAMED>");
            else
                System.Console.Write("{0}", name.Name);
        }
#endif
    }

    // OBJECT_DECL
    // ===========
    //
    // Object = OBJECT [ ObjModifier ] ObjectName [ FormalParameters ] [ ImplementationClause ] ";"
    //             [ ImportDeclaration ]
    //               Declarations
    //             { ActivityDeclaration }
    //             ( BlockStatement | END ) SimpleName.
    //
    // ObjModifier = "{" ( VALUE | REF ) "}".
    //
    public sealed class OBJECT_DECL : UNIT_DECL {
        // Constructor
        public OBJECT_DECL(Identifier name)
            : base(ASTNodeType.OBJECT_DECL, name) {
            definitions = new UNIT_DECL_LIST(); 
        }

        //------------------------------------------------------------------------

        // FROM THE BASE:
     // public DECLARATION_LIST  locals; -- imports, members, procedures, activities
     // public BLOCK             body;   -- object body

        public UNIT_DECL_LIST    definitions;  // definitions implemented by this object
        public bool              reference;    // true for REF, false for VALUE
        public int               paramCount;   // number of object parameters

        // For object that implements indexer definition []
        public class INDEXER_DECL {
            private Node node = null;
            public PROCEDURE_DECL Set = null;
            public PROCEDURE_DECL Get = null;
            public bool validate() {
                return Set != null || Get != null;
            }

            // returns indexer operator
            public Node convert() {
                if (node != null)
                    return node;
                if ((Get == null) && (Set == null))
                    return null;
                TypeNode declaringType = null;
                ParameterList parlist = new ParameterList();
                if (Get != null) {
                    declaringType = Get.enclosing.convert() as TypeNode;
                    for(int k =0; k< Get.paramCount; k++){
                        Parameter par = Get.parameters[k].convert() as Parameter;
                        parlist.Add(par);
                    }
                } else if (Set != null) {
                    declaringType = Set.enclosing.convert() as TypeNode;
                    for(int k = 0; k< Set.paramCount - 1; k++){
                        Parameter par = Set.parameters[k].convert() as Parameter;
                        parlist.Add(par);
                    }

                }

                AttributeList attributes = new AttributeList();
                PropertyFlags flags = PropertyFlags.None;
                Identifier name = new Identifier("Item");
                Method getter = (Get != null) ? Get.convert() as Method : null;
                Method setter = (Set != null) ? Set.convert() as Method : null;
                Property indexer = new Property(declaringType, attributes, flags, name, getter, setter);                
                indexer.Parameters = parlist;
                node = indexer;
                return node;
            }
        }

        public INDEXER_DECL indexer = null;
        //------------------------------------------------------------------------

        public override NODE findExcludingDefs(Identifier name) {
            return base.find(name);
        }

        public override NODE findLocal(Identifier name) {
            NODE result = base.find(name);

            if (result is UNKNOWN_DECL && !CONTEXT.firstPass)
                result = null; // Try to find member in implemented definitions

/* Definitions do not expose their namespace not qualified
            if (result == null && definitions.Length > 0)
                for (int i = 0, n = definitions.Length; i < n; i++)
                    if ((result = definitions[i].find(name)) != null)
                        return result;
*/            
            return result;
        }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            for (int i = 0; i < locals.Length; i++) {
                if (locals[i] == null)
                    continue;
                scope = locals[i].findScopeAtContext(line, col, documentName);
                if (scope != null)
                    break;
            }

            if (scope == null && body != null)
                scope = body.findScopeAtContext(line, col, documentName);

            return scope;
        }

        public override NODE find(Identifier name) {
            NODE result = base.find(name);

            if ( result is UNKNOWN_DECL && !CONTEXT.firstPass )
                result = null; // Try to find member in implemented definitions

            if ( result == null && definitions.Length > 0 )
                for ( int i=0, n=definitions.Length; i<n; i++ )
                    if ((definitions[i].Name != name.Name) && ((result = definitions[i].find_in_scope(name)) != null)) return result;

                //Attemp to find in the enclosing namespace
            if ((result == null)
                // Do not go to enclosing space for top-most objects since they are combinations
                // of objects and modules            
                &&(! IsTopLevelUnit())                
                && (enclosing != null)) {
                result = enclosing.find(name);
            }

            return result;
        }

        //-------------------------------------------------------------------------

        public static OBJECT_DECL create(IDENT_LIST name, MODIFIERS modifiers) {
            Identifier id = name[name.Length-1];

            // First, create object itself.
            OBJECT_DECL obj = new OBJECT_DECL(id);
         // obj.body         -- will be filled later
         // obj.definitions  -- will be filled later
         // obj.enclosing
            obj.modifiers = modifiers;
         // obj.full_name
         // obj.locals
            obj.reference = modifiers.Reference;
            if (!obj.reference) {
                // If no explicit REF modifier then treat object
                // as VALUE by default
                obj.modifiers.Value = true;
            }
         // obj.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor

            // Second, build the context; in particular,
            // 'enclosing' field will be set.
            DECLARATION anotherUnit = UNIT_DECL.processName(obj,name);

            // Then, check the nesting
            NODE context = CONTEXT.current;
            if ( context != null && !(context is NAMESPACE_DECL) && !(context is MODULE_DECL) )
                // Cannot declare module in any compilation unit
                ERROR.IllegalNesting("object in a compilation unit other than module");

            // Set access
            if (!obj.modifiers.Public && !obj.modifiers.Private) {
                // There were no explicit modifiers; set them.
                if (context == null || context is NAMESPACE_DECL)
                    obj.modifiers.Public = true;
                else if (context is MODULE_DECL)
                    obj.modifiers.Private = true;
            }

            // Check the uniqueness of the object name.
            if (anotherUnit != null) {
                // There IS a unit or namespace with the same name in the same scope!
///////         bool err = true;
                if (anotherUnit is NAMESPACE_DECL) {
                    // 'unit' is NOT a real unit (i.e., it is a NAMESPACE)
                    // Message:
                    // cannot declare <unit> <name>:
                    // there is <namespace> with the same name in the current scope
                    ERROR.IncorrectUnitName("object",anotherUnit.name.Name,"namespace");
                } else if (anotherUnit is OBJECT_DECL) {
                    // Message:
                    // duplicate declaration of <object> <name>
                    ERROR.DuplicateUnit("object",anotherUnit.name.Name);
                } else if (anotherUnit is UNKNOWN_DECL) {
                    UNKNOWN_DECL external = anotherUnit as UNKNOWN_DECL;
                    external.RealDeclaration = obj;
                    external.name = null;
                    // Copying locals from UNKNOWN_DECL
                    // (all of them are in turn UNKNOWN_DECLs).
                    obj.locals = external.locals;
                    // Correcting 'enclosing' field
                    for ( int i=0, n=obj.locals.Length; i<n; i++ )
                        obj.locals[i].enclosing = obj;
///////             err = false;
                } else {
                    // The existing compilation unit is NOT object.
                    // Message:
                    // cannot declare <object> <name>:
                    // there is <another unit> with the same name in the current scope
                    ERROR.IncorrectUnitName("object",anotherUnit.name.Name,"another unit");
                }
///////         if ( err ) obj.name = ERROR.errUnitName; // null;
            }
         // else -- NO unit with the given name; that's OK.

            // Add new object to the current context.
            CONTEXT.enter(obj);
            return obj;
        }

        //------------------------------------------------------------------------
        
        public override NODE resolve() {
            if (resolved()) return this;
            if (modifiers.Actor) modifiers.Protected = true;
            for (int i = 0, n = this.definitions.Length; i < n; i++)
            {
                this.definitions[i] = (UNIT_DECL)this.definitions[i].resolve();
               /* WE DO NOT DO THAT
                // If definition refines another definition we should ann an import clause.
                UNIT_DECL curdef = this.definitions[i];
                while (curdef != null)
                {
                    IDENT_LIST idl = new IDENT_LIST();
                    string s = NODE.generateFullName(curdef);
                    string[] ss = s.Split('.');
                    foreach (string nm in ss) idl.Add(Identifier.For(nm));

                    this.addImportedUnit(idl, curdef, null, true);

                    UNIT_DECL basedef = null;
                    if (curdef is DEFINITION_DECL)
                    {
                        DEFINITION_DECL def = (DEFINITION_DECL)curdef;
                        basedef = def.base_definition; // There is a base def. Need to add import                    
                    }
                    else if (curdef is EXTERNAL_DECL)
                    {
                        EXTERNAL_DECL def = (EXTERNAL_DECL)curdef;
                        if (def.entity is Interface && ((Interface)(def.entity)).Interfaces.Length > 0)
                        {
                            // definition can refine only one definition
                            basedef = new EXTERNAL_DECL(((Interface)(def.entity)).Interfaces[0]);
                        }
                    }                    
                    curdef = basedef;
                }
                * */
            }

            for (int i = 0, n = this.locals.Length; i < n; i++)
                if (this.locals[i] is PROCEDURE_DECL)
                    if (((PROCEDURE_DECL)locals[i]).modifiers.Shared)
                        this.modifiers.Shared = true;
       
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if(IsTopLevelUnit()&&!ErrorReported)
            if (EXTERNALS.findType(NODE.generateFullName(enclosing), this.name) != null)
            {
                ERROR.DuplicateDeclaration(this.sourceContext, NODE.generateFullName(this));
                ErrorReported = true;
            }

            // o ...
            if (modifiers.Protected && !modifiers.Reference&& !ErrorReported)
            {
                ErrorReported = true;
                ERROR.IllegalUseOfModifier("protected","value objects", sourceContext);
                return false;
            }
            for(int i=0; i<definitions.Length; i++)
            {
                definitions[i] = definitions[i].resolve() as UNIT_DECL;
            }
            if (indexer != null && !indexer.validate()&& !ErrorReported)
            {
                ERROR.NotImplementedIndexer(name.Name, sourceContext);
                ErrorReported = true;
                return false;
            }
            return true;
        }

        //------------------------------------------------------------------------------

        public override TYPE type  // evaluates object type
        {
            // "Type" of object declaration is an OBJECT_TYPE which refers
            // to the declaration. Here we just construct such a type.
            get {
                if (internal_type != null)
                    return internal_type;

                OBJECT_TYPE object_type = new OBJECT_TYPE();
                object_type.ObjectUnit = this;

                internal_type = object_type;
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            TypeNode cls = null;
            if ( this.modifiers.Reference )
                cls = new Class();  // Zonnon object is mapped to CLI sealed class
            else
                cls = new Struct();

            node = cls;

            UNIT_DECL saved = CONTEXT.current_unit;
            ROUTINE_DECL saved2 = CONTEXT.current_routine;
            CONTEXT.current_unit = this;
            CONTEXT.current_routine = null;

            // Creating FieldInitializerBlock.
            // This is the special structure for collecting members' initializers.
            // Later (see below) this structure will become a part of ctor's body.
            // The idea is that CCI will collect filed initializer in it.
            // So we leave it empty assuming that CCI will fill it by its own.
            //
            // (Notice that for value objects (and records) I collect initializers
            // in ctor body myself.)
            FieldInitializerBlock initializers = new FieldInitializerBlock();
            initializers.Statements = new StatementList();
            initializers.IsStatic = false;
            initializers.Type = cls;

         // cls.Attributes;
         // cls.BaseClass;
         // cls.BaseType;
         // cls.ClassSize;
            cls.DeclaringModule = CONTEXT.symbolTable;
            if (enclosing != null) {
                if ( enclosing is NAMESPACE_DECL)  // global object
                    CONTEXT.symbolTable.Types.Add(cls);
                else  // local object
                    cls.DeclaringType = (TypeNode)enclosing.convertAndGetType();
            }
         // cls.ExplicitCoercionMethods;
            cls.Flags = TypeFlags.Sealed;
            if (enclosing is NAMESPACE_DECL) {
                if (modifiers.Public)
                    cls.Flags |= TypeFlags.Public;
            else
                    cls.Flags |= TypeFlags.NotPublic;
            } else {
                if (modifiers.Public)
                    cls.Flags |= TypeFlags.NestedPublic;
                else
                    cls.Flags |= TypeFlags.NestedPrivate;
            }
         // cls.FullName;
         // cls.HidesBaseClassMember;
         // cls.ImplicitCoercionMethods;
            if (cls.Members == null)
                cls.Members = new MemberList();

            // Generating object constructor
            InstanceInitializer ctor = new InstanceInitializer();
            // Immediately initializing its fields, otherwise possible crash 
            // because of recursive call.
         // ctor.Body.UniqueKey

            ctor.CallingConvention |= CallingConventionFlags.HasThis;
            ctor.DeclaringType = cls;
         // ctor.Ensures;
         // ctor.ExceptionHandlers;
            ctor.Flags |= MethodFlags.Public | MethodFlags.SpecialName | MethodFlags.RTSpecialName;
            ctor.Flags |= MethodFlags.HideBySig;
            ctor.HasCompilerGeneratedSignature = false;
         // ctor.ImplementedInterfaceMethod;
         // ctor.ImplementedInterfaceMethods;
         // ctor.ImplementedTypes;
         // ctor.ImplFlags;
            ctor.InitLocals = true;
         //          ctor.Name = Identifier.For("_body"); // _"+base.name.Name);
         // ctor.NodeType;
         // ctor.Parameters = null; -- already generated
         // ctor.PInvokeFlags;
         // ctor.PInvokeImportName;
         // ctor.PInvokeModule;
         // ctor.Requires;
         // ctor.ReturnAttributes;
            ctor.ReturnType = SystemTypes.Void;
         // ctor.Scope;
            ctor.SourceContext = base.sourceContext;
         // ctor.Template;
         // ctor.TemplateArguments;
         // ctor.TemplateParameters;
         // ctor.UniqueKey;

            cls.Members.Add(ctor);


            ctor.Parameters = new ParameterList();
            if (paramCount > 0) {
                int i = 0, n = 0;
                while (n < paramCount) {
                    if (!(locals[i] is FIELD_DECL)) { i++; continue; }
                    Parameter par = new Parameter();

                    TYPE type = locals[i].type;
                    if (type == null) {
                        locals[i].ErrorReported = true;
                        i++;
                        n++;
                        continue;
                    } // an error was detected earlier

                    par.Type = (TypeNode)type.convert();
                    if (par.Type == null) {
                        locals[i].ErrorReported = true;
                        i++;
                        n++;
                        continue;
                    }  // an error was detected earlier
                    par.Name = Identifier.For("_" + locals[i].name.Name);
                    par.Flags = ParameterFlags.In;
                    // par.Index = i;
                    par.SourceContext = locals[i].sourceContext;

                    ctor.Parameters.Add(par);
                    i++;
                    n++;
                }
            } else if (this.modifiers.Value) {
                // Adding "virtual" integer parameter
                Parameter par = new Parameter();
                par.Type = SystemTypes.Int32;
                par.Name = Identifier.For("_fict");
                par.Flags = ParameterFlags.In;
                ctor.Parameters.Add(par);
            }

         // ctor.Attributes
            ctor.Body = new Block();

            ctor.Body.Checked = false;  // ???
            ctor.Body.HasLocals = false;  // ??????????????????????????
         // ctor.Body.NodeType;
            if ( base.body.statements.Length > 0 ) // can be 0 because of pasre errors
                ctor.Body.SourceContext = base.body.statements[0].sourceContext;

            // Generating ctor's body
            ctor.Body.Statements = new StatementList();
            // First generate base class ctor's invokation;
            // that is, System.Object::.ctor(),
            // and also generate the call to its constructor
            if (this.modifiers.Reference) {
                ((Class)cls).BaseClass = SystemTypes.Object;
                MethodCall superCtorCall =
                    new MethodCall(new QualifiedIdentifier(new Base(),StandardIds.Ctor),null,NodeType.Call);

                ctor.Body.Statements.Add(new ExpressionStatement(superCtorCall));
                // Notice that if I see an _external_ (eg, system) base class
                // (when I process object's definitions, see below)
                // I will have to remove Object base class and the call...

            }
            // Adding field initializers - in fact, nothing...
            ctor.Body.Statements.Add(initializers);

            // Then generating "parameter" initializations (if any)
            if (paramCount > 0) {
                int i=0, n=0;
                while (n < paramCount) {
                    if ( !(locals[i] is FIELD_DECL) ) { i++; continue; }
                    if ( locals[i].ErrorReported ) { i++; n++; continue; }
                    AssignmentStatement assignment = new AssignmentStatement();
                    assignment.Operator = NodeType.Nop;
                    assignment.Target = Identifier.For(locals[i].name.Name);
                    assignment.Source = Identifier.For("_"+locals[i].name.Name);
                    ctor.Body.Statements.Add(assignment);
                    i++;
                    n++;
                }
            }

            // Now continue generating class...
            cls.Name = base.name;
            if ( enclosing != null && enclosing is NAMESPACE_DECL )
                cls.Namespace = Identifier.For(NODE.generateFullName(enclosing));
         // cls.NodeType;
         // cls.OverridesBaseClassMember;
         // cls.PackingSize;
            cls.SourceContext = base.sourceContext;

            // Converting implemented definitions
            cls.Interfaces = new InterfaceList();
            for (int i = 0, n = definitions.Length; i < n; i++) {
                DECLARATION unit = (DECLARATION)definitions[i].resolve();
                if ( unit == null ) continue;
                if (!(unit is EXTERNAL_DECL))
                {

                if (unit is IMPLEMENTATION_DECL) {
                        string impl_name = unit.name.Name;
                        SourceContext context = unit.sourceContext;

                        unit = ((IMPLEMENTATION_DECL)unit).implemented_definition;
                    if (unit == null) {
                            ERROR.NoDefinition(context, impl_name);
                            continue;
                        }
                } else if (!(unit is DEFINITION_DECL)) {
                    if (!unit.ErrorReported) {
                            unit.ErrorReported = true;
                            ERROR.WrongDefinitionName(unit.sourceContext, unit.name.Name);
                        }
                        continue;
                    }

                    //// Import refind definitions ==> DONE IN resolve()
                    //DEFINITION_DECL def = unit as DEFINITION_DECL;
                    //if (def.base_definition as DEFINITION_DECL != null)
                    //{
                    //    DEFINITION_DECL base_def = def.base_definition as DEFINITION_DECL;
                    //    //definitions.Add(base_def);

                    //    IMPORT_DECL imported_by_default = new IMPORT_DECL(base_def.name, true);
                    //    imported_by_default.enclosing = this;
                    //    imported_by_default.imported_unit = base_def;
                    //    this.locals.Add(imported_by_default);
                    //}

                    unit.convert();
                    //
                    //              // Adding items from the implemented definition and/or default implementation
                    //              ((DEFINITION_DECL)unit).convertSatellite(this,false);
                    //
                }

                Node result = unit.convertAndGetType();
                if (result is Interface) {
                    cls.Interfaces.Add((Interface)result);
                    continue;
                } else if (result is Class) {
                    if (!this.modifiers.Reference) {
                        // This object is value object and has "true" base class.
                        // This is the error.
                        ERROR.CannotDeriveFromSystem(unit.sourceContext,this.name.Name);
                        continue;
                    }
                    if (((Class)cls).BaseClass == SystemTypes.Object) {
                        ((Class)cls).BaseClass = (Class)result;
                    //  -- This is already prepared (see above)
                    //  MethodCall superCtorCall =
                    //      new MethodCall(new QualifiedIdentifier(new Base(),StandardIds.Ctor),null,NodeType.Call);
                    //  ctor.Body.Statements[0] = new ExpressionStatement(superCtorCall);
                    } else {
                        // Error: two base classes!
                        ERROR.SystemErrorIn("OBJECT_DECL.convert","more than one base class");
                    }
                    continue;
                }

                // Otherwise - error.
                string name;
                if      ( unit.name != null )    name = unit.name.Name;
                else if ( unit is UNKNOWN_DECL ) name = ((UNKNOWN_DECL)unit).RealDeclaration.name.Name;
                else                             name = "<noname>";
                ERROR.WrongDefinitionName(unit.sourceContext,name);
            }

            // Converting members (almost the same as for modules).
            // If there are initializers for members then we collect them
            // in our own init-statements list and later move them all to
            // static ctor's body. Notice that we do not use FieldInitializerBlock structure
            // for those initializers because CCI expects this structure is empty.
            for (int i = 0, n = locals.Length; i < n; i++) {
                if (locals[i] is UNKNOWN_DECL)
                    continue;

            //  if ( locals[i] is PROCEDURE_DECL )
            //  {
            //      PROCEDURE_DECL procedure = locals[i] as PROCEDURE_DECL;
            //      if ( procedure.prototype != null &&
            //           ( procedure.modifiers.Getter || procedure.modifiers.Setter ) )
            //          // This procedure has been already converted while processing interfaces
            //          // (see above)
            //          continue;
            //  }
                Node member = locals[i].convert();
                if (member == null)
                    continue;

                if ((member is Member) && (locals[i].type is ARRAY_TYPE)) {
                    //adding metadata
                    InstanceInitializer ii_v = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
                    MemberBinding attrBinding_v = new MemberBinding(null, ii_v);
                    ExpressionList args_v = new ExpressionList();
                    if ((locals[i].type as ARRAY_TYPE).isMath)
                        args_v.Add(new Literal("math array", SystemTypes.String));
                    else
                        args_v.Add(new Literal("simple array", SystemTypes.String));
                    AttributeNode attrNode_v = new AttributeNode(attrBinding_v, args_v, AttributeTargets.All);
                    (member as Member).Attributes.Add(attrNode_v);
                }

                if (locals[i] is IMPORT_DECL && member != null) {
                    // If we had generated "mix-in" with initializer,
                    // then for value objects we should move it to the ctor body.
                    if (this.modifiers.Value) {
                        Field field = member as Field;
                        if (field != null && field.Initializer != null) {
                            Expression initializer = field.Initializer;
                            field.Initializer = null;

                            AssignmentStatement assignment = new AssignmentStatement();
                            assignment.Operator = NodeType.Nop;
                            assignment.Target = new MemberBinding(new This(),field);
                            assignment.Source = initializer;
                            ctor.Body.Statements.Add(assignment);
                        }
                    }
                } else if (locals[i] is VARIABLE_DECL) {
                    // For value objects, take field initializers from the field declaration
                    // and put them (as assignment) to the ctor body
                    if (this.modifiers.Value) {
                        Field field = member as Field;
                        if (field != null) {
                            if (field.Initializer != null) {
                                Expression initializer = field.Initializer;
                                field.Initializer = null;

                                AssignmentStatement assignment = new AssignmentStatement();
                                assignment.Operator = NodeType.Nop;
                                assignment.Target = new MemberBinding(new This(), field);
                                assignment.Source = initializer;
                                ctor.Body.Statements.Add(assignment);
                            } else if (field.Type != null && field.Type.ConstructorName != null)
                            // Use field.Type.ConstructorName
                            {
                                /* RM: I doubt that we should be creating reference type aggregates of a value type object
                                 */
                                if (field.Type.IsValueType) {
                                    Construct construct = new Construct();
                                    construct.Constructor = new MemberBinding(null, field.Type);
                                    construct.Constructor.Type = SystemTypes.Type;
                                    construct.SourceContext = this.sourceContext;
                                    construct.Type = field.Type;

                                    AssignmentStatement assignment = new AssignmentStatement();
                                    assignment.Operator = NodeType.Nop;
                                    assignment.Target = new MemberBinding(new This(), field);
                                    assignment.Source = construct;
                                    ctor.Body.Statements.Add(assignment);
                                } else {
                                    // Do nothing. References should be assigned by a user.
                                }
                            } else if (field.Type is ArrayType) {
                                // Do nothing if it is an open array
                                // TODO: We should add initializers for non open arrays
                            } else {
                                ERROR.SystemErrorIn("OBJECT_DECL.convert", "type of a component of a value object was not resolved");
                            }
                        }
                    }
                    // Create "real" field element initializers and put them into the ctor body.
                    Block array_initializers = ((VARIABLE_DECL)locals[i]).createElementInitializer();
                    if ( array_initializers != null )
                        ctor.Body.Statements.Add(array_initializers);
                } else if (locals[i] is ACTIVITY_DECL) {
                    // Take activity launcher from 'node1' field
                    cls.Members.Add((locals[i] as ACTIVITY_DECL).node1);
                    // Take activity body image
                    cls.Members.Add((Member)member);
                    continue; // to prevent duplicating (see the Add call below)
                } else
                    if (locals[i] is IMPORTSPACE_DECL) {
                        foreach (Member m in ((NameBinding)member).BoundMembers) {
                        // If it is a value object move initializers to constructor
                            if ((!this.modifiers.Reference) && (m is Field)) {
                            AssignmentStatement assignment = new AssignmentStatement();
                            assignment.Operator = NodeType.Nop;
                            assignment.Target = new MemberBinding(new This(), m);
                            assignment.Source = ((Field)m).Initializer;
                            ctor.Body.Statements.Add(assignment);

                            ((Field)m).Initializer = null;
                        }

                        cls.Members.Add(m);

                    }
                }

                if (member is Member) {
                    cls.Members.Add((Member)member);
                }
             // else -- an error; the message is already issued
             //     continue;
            }
            if ((indexer != null) && (indexer.convert() as Member != null)) {
                cls.Members.Add((Member)indexer.convert());
                // We need to add special attribute                
                InstanceInitializer ctor2 = SystemTypes.DefaultMemberAttribute.GetConstructor(SystemTypes.String);
                MemberBinding attrBinding = new MemberBinding(null, ctor2);
                ExpressionList args = new ExpressionList();
                args.Add(new Literal("Item", SystemTypes.String));
                AttributeNode a = new AttributeNode(attrBinding, args, AttributeTargets.All);                
                cls.Attributes.Add(a);                
            }

            // Now we perform the last action: we scan all definitions
            // implemented by this object and check whether all their
            // entities are actually implemented by the object.
            // If there are unimplemented entities we try to find
            // the implementation in the implementation unit associated
            // with this definition.
            int Len = cls.Members.Length;
            for (int i = 0, n = this.definitions.Length; i < n; i++) {
                DECLARATION def = (DECLARATION)definitions[i].resolve();
                DEFINITION_DECL definition = null;
                if (def is DEFINITION_DECL)
                    definition = (DEFINITION_DECL)def;
                else if (def is IMPLEMENTATION_DECL)
                    definition = (DEFINITION_DECL)((IMPLEMENTATION_DECL)def).implemented_definition.resolve();
                else if (def is EXTERNAL_DECL)
                    ((EXTERNAL_DECL)def).addUnimplementedInterfaceEntities(this,false,prefixesForMixed[i]);

                if (definition == null)
                    continue;
                definition.addUnimplementedEntities(this,false, prefixesForMixed[i]);
            }
            // OK, we have added some members to the class.
            // There can be normal data members with initialiers among them.
            // If our object has 'value' modifier then we should move initialzers
            // to the ctor's body.
            if (this.modifiers.Value) {
                for (int i = Len, n = cls.Members.Length; i < n; i++) {
                    Field field = cls.Members[i] as Field;
                    if (field != null) {
                        if (field.Initializer != null) {

                            Expression initializer = field.Initializer;
                            field.Initializer = null;

                            AssignmentStatement assignment = new AssignmentStatement();
                            assignment.Operator = NodeType.Nop;
                            assignment.Target = new MemberBinding(new This(), field);
                            assignment.Source = initializer;
                            ctor.Body.Statements.Add(assignment);
                        }
                        else 
                        if (field.Type != null && field.Type.ConstructorName != null)
                        {
                            // Why would we initialize anything nested?
                            /*
                            Construct construct = new Construct();
                            construct.Constructor = new MemberBinding(null, field.Type);
                            construct.Constructor.Type = SystemTypes.Type;
                            construct.SourceContext = this.sourceContext;
                            construct.Type = field.Type;

                            AssignmentStatement assignment = new AssignmentStatement();
                            assignment.Operator = NodeType.Nop;
                            assignment.Target = new MemberBinding(new This(), field);
                            assignment.Source = construct;
                            ctor.Body.Statements.Add(assignment);
                             */
                        }
                        else
                        {
                            ERROR.SystemErrorIn("OBJECT_DECL.convert", "type of a component of a value object was not resolved");
                        }
                    }
                }

            }

            // Finally, generating constructor body itself
            // (_after_ all other ctor parts are generated).
            
            // First convert the body to make sure the flag is set.
            Statement objectBody = (Statement)(base.body.convert());
            //
            if (activeBody && !modifiers.Reference)
            {
                ERROR.NotImplemented(sourceContext, "active body (body with blocking constructs) in value objects is");
                ErrorReported = true;
                return null;
            }
            if (activeBody)
            { // Create a method and call it in a new thread
                //CRATE A METHOD
                Method activity = new Method();
                activity.Body = new Block();
                activity.Body.Checked = false;  // ???
                activity.Body.HasLocals = true;
                // activity.Body.NodeType;
                activity.Body.SourceContext = this.sourceContext;
                activity.Parameters = new ParameterList(0);
                activity.Body.Statements = new StatementList();

                Block abody = new Block();
                abody.Statements = new StatementList();
                abody.HasLocals = true;
                abody.SourceContext = sourceContext;

                abody.Statements.Add(PROCEDURE_DECL.generateUnlockVariable());

                bool RWL = enclosing.modifiers.Protected && enclosing.modifiers.Shared;
                bool Shared = this.modifiers.Shared;

                Try try_catch = new Try();
                try_catch.TryBlock = new Block();
                try_catch.TryBlock.Statements = new StatementList();

                // Acquire the lock and let the constructor finish
                try_catch.TryBlock.Statements.Add(AWAIT.EvictLockEnter(RWL, Shared));
                // Add auto reset to let the constructor finish

                try_catch.TryBlock.Statements.Add(objectBody);

                ///=====
                try_catch.Finally = new Finally();
                try_catch.Finally.Block = new Block();
                try_catch.Finally.Block.Statements = new StatementList();
                try_catch.Finally.Block.Statements.Add(AWAIT.EvictLockLeave(RWL, Shared));
                activity.Body.Statements.Add(try_catch);
                activity.DeclaringType = (TypeNode)node;
                activity.Flags = MethodFlags.Private;
                activity.CallingConvention = CallingConventionFlags.HasThis;
                activity.InitLocals = true;
                activity.Name = Identifier.For("_activeBody");
                activity.ReturnType = SystemTypes.Void;
                activity.SourceContext = this.sourceContext;
                cls.Members.Add(activity);

                // CALL THE METHOD
                AssemblyNode system = AssemblyNode.GetAssembly(typeof(System.String).Assembly);
                TypeNode thread = system.GetType(Identifier.For("System.Threading"), Identifier.For("Thread"));
                TypeNode threadStartD = system.GetType(Identifier.For("System.Threading"), Identifier.For("ThreadStart"));

                // new Thread(new Delegate(_activeBody)).Start();
                ConstructDelegate delg = new ConstructDelegate();
                delg.DelegateType = threadStartD;
                delg.MethodName = Identifier.For("_activeBody");
                delg.TargetObject = new This();
                delg.TargetObject.Type = (TypeNode)node;

                Construct construct = new Construct();
                construct.Constructor = new MemberBinding(null, thread); // Hope they won't change the order
                construct.Constructor.Type = SystemTypes.Type;
                construct.SourceContext = this.sourceContext;
                construct.Type = thread;
                construct.Operands = new ExpressionList();
                construct.Operands.Add(delg);

                MethodCall mf = new MethodCall();

                mf.Callee = new MemberBinding(null, thread.GetMethod(Identifier.For("MemoryBarrier"), new TypeNode[] { }));
                mf.GiveErrorIfSpecialNameMethod = false; // ??
                mf.IsTailCall = false;                
                mf.Operands = new ExpressionList();
                mf.SourceContext = this.sourceContext;
                mf.Type = SystemTypes.Void;

                ctor.Body.Statements.Add(new ExpressionStatement(mf, this.sourceContext));

                MethodCall invoke = new MethodCall();

                invoke.Callee = new MemberBinding(construct, thread.GetMethod(Identifier.For("Start"), new TypeNode[]{}));
                invoke.GiveErrorIfSpecialNameMethod = false; // ??
                invoke.IsTailCall = false;
                // invoke.NodeType
                invoke.Operands = new ExpressionList();
                invoke.SourceContext = this.sourceContext;
                invoke.Type = SystemTypes.Void;

                ctor.Body.Statements.Add(new ExpressionStatement(invoke, this.sourceContext));

            }
            else
            { //Noraml body -> part of the constructor
                ctor.Body.Statements.Add(objectBody);
            }

            // Owner thread
            if (modifiers.Protected)
            {
                Field field = new Field();
                field.DeclaringType = (TypeNode)this.convertAndGetType();
                field.DefaultValue = null;
                field.Flags = FieldFlags.Private;
                field.IsVolatile = true;
                field.Name = Identifier.For("_ctowner");
                field.SourceContext = sourceContext;

                field.Type = SystemTypes.Int32;

                if (!modifiers.Value)
                {
                    // For reference objects
                    field.Initializer = new Literal((int)0, SystemTypes.Int32);
                }
                else
                {
                    // For value object we have to do it the other way
                    // Instance fields of value types cannot have initializers
                    field.Initializer = null;

                    AssignmentStatement assignment = new AssignmentStatement();
                    assignment.Operator = NodeType.Nop;
                    assignment.Target = new MemberBinding(new This(), field);
                    assignment.Source = new Literal((int)0, SystemTypes.Int32);
                    ctor.Body.Statements.Add(assignment);
                }

                cls.Members.Add((Member)field);
            }

			// Generating _lock property for protected objects
            /* Only for RWL 
			if ( modifiers.Protected && modifiers.Shared)
			{
				Field field = new Field();
				field.DeclaringType = (TypeNode)this.convertAndGetType();
				field.DefaultValue = null;
				field.Flags = FieldFlags.Private;
				field.IsVolatile = true;
				field.Name = Identifier.For("_lock");
				field.SourceContext = sourceContext;

				field.Type = (TypeNode)STANDARD.objectLock.type.convert();				

				Construct construct = new Construct();
				construct.Constructor = new MemberBinding(null,field.Type);
				construct.Constructor.Type = SystemTypes.Type;
				construct.Type = field.Type;
				construct.Operands = new ExpressionList();
                if (!modifiers.Value) {
					// For reference objects
					field.Initializer = construct;
                } else {
					// For value object we have to do it the other way
					// Instance fields of value types cannot have initializers
					field.Initializer = null;

                    AssignmentStatement assignment = new AssignmentStatement();
                    assignment.Operator = NodeType.Nop;
				    assignment.Target = new MemberBinding(new This(),field);
					assignment.Source = construct;
					ctor.Body.Statements.Add(assignment);
				}
				cls.Members.Add((Member)field);
			}
            */

            //adding metadata
            InstanceInitializer ii = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
            MemberBinding attrBinding_ = new MemberBinding(null, ii);
            ExpressionList args_ = new ExpressionList();
            args_.Add(new Literal("object", SystemTypes.String));
            AttributeNode attrNode = new AttributeNode(attrBinding_, args_, AttributeTargets.All);
            cls.Attributes.Add(attrNode);

            CONTEXT.current_unit = saved;
            CONTEXT.current_routine = saved2;
            return node;
        }

        //----------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            if (modifiers.Public)
                System.Console.Write("PUBLIC ");
            else
                System.Console.Write("PRIVATE ");
            System.Console.Write("OBJECT {0}, line={1}",base.name!=null?base.name.ToString():"<NONAME>",this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("IMPLEMENTED DEFINITIONS: ");
            if ( definitions == null || definitions.Length == 0 )
                System.Console.WriteLine("MISSED");
            else {
                System.Console.WriteLine();
                for (int i = 0, n = definitions.Length; i < n; i++) {
                    NODE.doShift(shift+2*NODE.reportShift);
                    definitions[i].report_short();
                    System.Console.WriteLine();
                }
            }

            if ((comments != null) && (comments.Length > 0)) {
				for (int i = 0; i < comments.Length; i++)
					comments[i].report(shift + reportShift);
			}


            base.report(shift+reportShift);
        }

        public override void report_short() {
            System.Console.Write("OBJECT {0}:{1}",unique,name.Name);
        }
#endif
    }

    // DEFINITION_DECL
    // ===============
    //
    // Definition = DEFINITION DefinitionName [ RefinementClause ] ";"
    //                 [ ImportDeclaration ]
    //                   DefinitionDeclarations
    //              END SimpleName.
    //
    // RefinementClause = REFINES DefinitionName.
    //
    // Definitiondeclaration = { SimpleDeclaration }
    //                         { ProcedureHeading ";" }.
    //
    // NOTE for Alan: definitions are NOT types (objects)!
    // If you want to use polymorphism wrire smthng like object{D}
    // where D is a definition... Nothing to modify in the code!
    //

    public sealed class DEFINITION_DECL : UNIT_DECL {
        // Constructor
        public DEFINITION_DECL ( Identifier name ) : base(ASTNodeType.DEFINITION_DECL, name) { }

        //-------------------------------------------------------------------

        // FROM THE BASE:
     // public DECLARATION_LIST  locals; -- imports, members, procedure headings
     // public BLOCK             body;   -- doesn't exist for definitions

        public UNIT_DECL         base_definition;         // either UNKNOWN_DECL or DEFINITION_DECL
        public UNIT_DECL         default_implementation;  // either UNKNOWN_DECL or IMPLEMENTATION_DECL

        //--------------------------------------------------------------------

        public bool refines(DEFINITION_DECL d) {
            if (base_definition == null)
                return false;
            if (!(base_definition is DEFINITION_DECL))
                return false;

            if (base_definition == d)
                return true;
            return ((DEFINITION_DECL)base_definition).refines(d);
        }

        //-----------------------------------------------------------------

        public override NODE findExcludingDefs(Identifier name) {
            return base.find(name);
        }

        public override NODE find_in_scope(Identifier name)
        {
            bool excludeImportspace = true; // Find in scope means in scope only
            NODE result = locals.find(name, excludeImportspace);
            if (result== null && base_definition != null) result = base_definition.find_in_scope(name);
            return result;
        }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            for (int i = 0; i < locals.Length; i++)
            {
                if (locals[i] == null) continue;
                NODE scope = locals[i].findScopeAtContext(line, col, documentName);
                if (scope != null)
                    return scope;
            }
            return null;
        }

        public override NODE find(Identifier name) {
            NODE result = base.find(name);

            if ( result is UNKNOWN_DECL && !CONTEXT.firstPass )
                result = null; // Try to find member in implemented definitions

            if ( result == null && base_definition != null )
                result = base_definition.find_in_scope(name);

            return result;
        }

        //--------------------------------------------------------------------

        public static DEFINITION_DECL create(IDENT_LIST name, MODIFIERS modifiers) {
            Identifier id = name[name.Length-1];

            // First, create definition.
            DEFINITION_DECL definition = new DEFINITION_DECL(id);
         // definition.base_definition
         // definition.body                   -- will be filled later
         // definition.default_implementation
         // definition.enclosing
         // definition.full_name
         // definition.locals                 -- will be filled later
         // definition.sourceContext = Parser.LEXAN.getSourceContext();  -- already done in ctor
            definition.modifiers = modifiers;

            // Second, build the context; in particular,
            // definition's 'enclosing' field will be set.
            DECLARATION anotherUnit = UNIT_DECL.processName(definition,name);

            // Then, check the nesting
            NODE context = CONTEXT.current;
            if ( context != null && !(context is NAMESPACE_DECL) && !(context is MODULE_DECL) )
                // Cannot declare definition in any compilation unit
                ERROR.IllegalNesting("definition in a compilation unit other than module");

            // Set access
            if (!definition.modifiers.Public && !definition.modifiers.Private) {
                // There were no explicit modifiers; set them.
                definition.modifiers.Public = true;
               // if ( context == null || context is NAMESPACE_DECL ) definition.modifiers.Public = true;
               // else if ( context is MODULE_DECL ) definition.modifiers.Private = true;
            }

            // Check the uniqueness of the definition name.
            if (anotherUnit != null) {
                // There IS a unit or namespace with the same name in the same scope!
///////         bool err = true;
                if (anotherUnit is NAMESPACE_DECL) {
                    // 'unit' is NOT a real unit (i.e., it is a NAMESPACE)
                    // Message:
                    // cannot declare <definition> <name>:
                    // there is <namespace> with the same name in the current scope
                    ERROR.IncorrectUnitName("definition",anotherUnit.name.Name,"namespace");
                } else if (anotherUnit is DEFINITION_DECL) {
                    // Message:
                    // duplicate declaration of <unit_name> <name>
                    ERROR.DuplicateUnit("definition",anotherUnit.name.Name);
                } else if (anotherUnit is IMPLEMENTATION_DECL) {
                    // The default implementation (i.e. with the same name as new
                    // definition) exists. We will link both units together.
                    IMPLEMENTATION_DECL implementation = anotherUnit as IMPLEMENTATION_DECL;

                    // Additional check: perhaps there IS definition already linked with
                    // implementation just found?
                    if ( implementation.implemented_definition != null )
                        ERROR.SystemErrorIn("DEFINITION_DECL.create","implementation is already busy???");

                    definition.default_implementation = implementation;
                    implementation.implemented_definition = definition;
///////             err = false;
                } else if (anotherUnit is UNKNOWN_DECL) {
                    UNKNOWN_DECL unknown = anotherUnit as UNKNOWN_DECL;
                    unknown.RealDeclaration = definition;
                    unknown.name = null;
                    // COPYING !!!!!!
///////             err = false;
                } else {
                    // The existing compilation unit is NEITHER definition NOR implementation.
                    // Message:
                    // cannot declare <definition> <name>:
                    // there is <an unrelated unit> with the same name in the current scope
                    ERROR.IncorrectUnitName("definition",anotherUnit.name.Name,"an unrelated unit");
                }
////////        if ( err ) definition.name = ERROR.errUnitName; // null;
            }
            // else -- NO unit with the given name; that's OK.

            // Add new definition to the current context.
            CONTEXT.enter(definition);
            return definition;
        }

        //--------------------------------------------------------------------

        // addBaseDefinition
        // -----------------
        // The function processes REFINES clause for definitions:
        //
        //     DEFINITION d REFINES d0; ...
        //                          ==
        // The function evaluates the name (using the common rules as for IMPORT
        // and IMPLEMENTS) and adds the information about "base" definition
        //
        //   (a) to the corresponding unit's field,
        //   (b) to the list of definition's imported units ("default import").
        //
        public void addBaseDefinition(IDENT_LIST qualName) {
            INSTANCE context;
          //  if (IsTopLevelUnit())
          //      context = INSTANCE.create(CONTEXT.globalTree);
          //  else
                context = INSTANCE.create(this);

            DESIGNATOR entity = SELECTOR.processQualName(context, qualName);
                // SELECTOR.processImportName(qualName); //.processQualName(null,qualName);
            DECLARATION declaration;

            UNIT_DECL   base_definition;

            if (entity == null) {
                // The error message has been already issued by
                // processImportName() function; nothing to do...
                return;
            }

            declaration = (DECLARATION)entity.resolve();

            if ( declaration is DEFINITION_DECL ) // We have found the definition.
            {
                base_definition = (DEFINITION_DECL)declaration;
                goto ProcessBaseDefinition;
            }
            if (declaration is IMPLEMENTATION_DECL) {
                IMPLEMENTATION_DECL implementation = declaration as IMPLEMENTATION_DECL;
                base_definition = implementation.implemented_definition;
                // It is still unclear how to interpret the case if base_id names
                // an implementation, and this implementation doesn't have definition...
                if (base_definition == null)
                    goto WrongBaseDefinition;
                goto ProcessBaseDefinition;
            }

            if (declaration is UNKNOWN_DECL) {
                // This means that there wasn't definition with the given name,
                // and SELECTOR.processQualName() has created it.
                // Here we should use this unknown unit just as we've got a real definition...
                base_definition = (UNKNOWN_DECL)declaration;
                goto ProcessBaseDefinition;
            }

            // All other cases (e.g., module) are illegal.

        WrongBaseDefinition:

            // Name '{0}' does not denote a definition as expected
            ERROR.WrongDefinitionName(qualName.ToString());
            return;

        ProcessBaseDefinition:

            // Some semantic checks:
            // - The base definition doesn't have the current one as its base.
            if ( base_definition is DEFINITION_DECL &&
                ((DEFINITION_DECL)base_definition).base_definition == this) {
             // ERROR: base definition has the current one as its base!
                ERROR.MutualRefinement(this.name.Name,((DEFINITION_DECL)base_definition).name.Name);
                return;
            }
            // - The definition refines itself
            if (base_definition == this) {
                // ERROR: definition refines itself!
                ERROR.RefinesItself(this.name.Name);
                return;
            }
            // Set 'base_definition' as the base for the current one.
            this.base_definition = base_definition;

            addImportedUnit(qualName, null, true, sourceContext);
         //   // Add the base definition to the list of _imported_ units:
         //   // the definition is considered as imported by default.
         //   IMPORT_DECL imported_by_default = new IMPORT_DECL(qualName[qualName.Length-1]);
         //   imported_by_default.enclosing = this;
         //   imported_by_default.imported_unit = base_definition;
         //// imported_by_default.modifiers -- already initialized
         //// imported_by_default.name  -- already given
         //// imported_by_default.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor

         //   // Put the declaration to the unit's import list.
         //   this.locals.Add(imported_by_default);
         //   // See comments regarding the uniqueness in the UNIT_DECL.addImplementedDefinition()
        }

        //--------------------------------------------------------------------
        private static bool preventRcursion = false;
        public override NODE resolve ( )
        {
            if (resolved()) return this;
            if (preventRcursion) return this;
            preventRcursion = true;
            for (int i = 0; i < locals.Length; i++)
                locals[i].resolve();
            if (base_definition != null) {
                    NODE res = base_definition.resolve();
                    if (!(res is DEFINITION_DECL || (res is EXTERNAL_DECL && (((EXTERNAL_DECL)res).entity is Interface))))
                    {
                        if (!CONTEXT.firstPass && !ErrorReported)
                        {
                            ERROR.WrongDefinitionName(this.sourceContext, res.name.Name);
                            ErrorReported = true;
                        }
                        preventRcursion = false;
                        return this;
                    }
                    base_definition = res as UNIT_DECL;
                }
            if ( default_implementation != null )
                default_implementation = (UNIT_DECL)default_implementation.resolve();
            preventRcursion = false;
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (IsTopLevelUnit() && !ErrorReported)
                if (EXTERNALS.findType(NODE.generateFullName(enclosing), this.name) != null)
                {
                    ERROR.DuplicateDeclaration(this.sourceContext, NODE.generateFullName(this));
                    ErrorReported = true;
                }
            // o ...
            if (base_definition == null)
                return true;
            UNIT_DECL def = base_definition.resolve() as UNIT_DECL;
            bool ok = true;
            if (def == null) {
                if (!base_definition.ErrorReported) {
                    base_definition.ErrorReported = true;
                    ERROR.WrongDefinitionName(this.sourceContext, base_definition.Name);
                    return false;
                }
            }
            else
            {
                for (int i = 0, n = locals.Length; i < n; i++)
                {
                    if (((locals[i] is PROCEDURE_DECL) ||( locals[i] is FIELD_DECL )) && def.find(locals[i].name)!=null)
                    {
                        if (!locals[i].ErrorReported)
                        {
                            ERROR.DefinedInBaseDefinition(locals[i].sourceContext, locals[i].Name, def.Name);
                            locals[i].ErrorReported = true;
                            ok = false;
                        }
                    }
                }
            }

            return ok;
        }

        //------------------------------------------------------------------------------

        public override TYPE type  // evaluates definition
        {
            // Should we create an INTERFACE_TYPE here?
            get { return null; }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            Interface interfac  = new Interface();
            node = interfac;

            UNIT_DECL saved = CONTEXT.current_unit;
            ROUTINE_DECL saved2 = CONTEXT.current_routine;
            CONTEXT.current_unit = this;
            CONTEXT.current_routine = null;

         // interfac.Attributes
         // interfac.BaseType
         // interfac.ClassSize;
            interfac.DeclaringModule = CONTEXT.symbolTable;
            if ( enclosing != null && enclosing is MODULE_DECL )
                interfac.DeclaringType = (Class)enclosing.convertAndGetType();
            else
                CONTEXT.symbolTable.Types.Add(interfac);
         // interfac.DefaultMembers;
         // interfac.ExplicitCoercionMethods;
            if (enclosing is NAMESPACE_DECL) {
                if (modifiers.Public)
                    interfac.Flags |= TypeFlags.Public;
            else
                    interfac.Flags |= TypeFlags.NotPublic;
            } else {
                if (modifiers.Public)
                    interfac.Flags |= TypeFlags.NestedPublic;
                else
                    interfac.Flags |= TypeFlags.NestedPrivate;
            }

         // interfac.FullName -- read-only property
         // interfac.HidesBaseClassMember;
         // interfac.ImplicitCoercionMethods;
            interfac.Interfaces = new InterfaceList();

            if (base_definition != null && base_definition is DEFINITION_DECL) {
                Interface base_interface = (Interface)base_definition.convertAndGetType();
                interfac.Interfaces.Add(base_interface);
            }
            if (base_definition != null && base_definition is EXTERNAL_DECL)
            {
                Interface base_interface = ((EXTERNAL_DECL)base_definition).entity as Interface;
                if (base_interface != null) interfac.Interfaces.Add(base_interface);
                else ERROR.InternalCompilerError("an external definition expected in refines clause");
            }

            interfac.Members = new MemberList();

            interfac.Name = base.name;
            if ( enclosing != null && enclosing is NAMESPACE_DECL )
                interfac.Namespace = Identifier.For(NODE.generateFullName(enclosing));
         // interfac.NodeType;
         // interfac.OverridesBaseClassMember;
         // interfac.PackingSize;
            interfac.SourceContext = base.sourceContext;

            for (int i = 0, n = locals.Length; i < n; i++) {
                DECLARATION declaration = locals[i];
                if (declaration.type == null)
                    continue;

                if (declaration is VARIABLE_DECL) {
                    string   name = declaration.name.Name;
                    TypeNode type = (TypeNode)((VARIABLE_DECL)declaration).type.convert();

                    bool getter = declaration.modifiers.Getter;
                    bool setter = declaration.modifiers.Setter;

                    // If no getter/setter modifiers then the varibale is "free",
                    // that is, all kinds of access is possible.
                    if ( !getter && !setter ) { getter = true; setter = true; }

                    Property property = new Property();
                 // property.Attributes;
                    property.DeclaringType = interfac;
                    property.Flags = PropertyFlags.None;
                 // property.Getter;  -- see below
                 // property.HidesBaseClassMember;
                 // property.ImplementedTypes;
                    property.Name = Identifier.For(name);
                 // property.NodeType;
                 // property.OtherMethods;
                 // property.OverridesBaseClassMember;
                 // property.Parameters = new ParameterList();
                 // property.Setter; -- see below
                    property.SourceContext = base.sourceContext;
                    property.Type = type;

                    if (getter) {
                        property.Getter = new Method();
                        property.Getter.Body = null;
                        property.Getter.DeclaringType = interfac;
                        property.Getter.Flags = MethodFlags.Abstract | MethodFlags.Public | MethodFlags.SpecialName |
                                                MethodFlags.NewSlot  | MethodFlags.Virtual;
                        property.Getter.CallingConvention = CallingConventionFlags.HasThis;
                        property.Getter.Name = Identifier.For("get_"+name);
                        property.Getter.ReturnType = type;
                        property.Getter.Parameters = new ParameterList(); //null;
                    }
                    if (setter) {
                        property.Setter = new Method();
                        property.Setter.Body = null;
                        property.Setter.DeclaringType = interfac;
                        property.Setter.Flags = MethodFlags.Abstract | MethodFlags.Public | MethodFlags.SpecialName |
                                                MethodFlags.NewSlot  | MethodFlags.Virtual;
                        property.Setter.CallingConvention = CallingConventionFlags.HasThis;
                        property.Setter.Name = Identifier.For("set_"+name);
                        property.Setter.ReturnType = SystemTypes.Void; // type;
                        property.Setter.Parameters = new ParameterList();

                        Parameter par = new Parameter();
                     // par.Attributes;
                        par.DefaultValue = null;
                        par.Flags = ParameterFlags.In;
                     // par.MarshalType;
                        par.Name = Identifier.For("value");
                     // par.NodeType;
                        par.ParameterListIndex = 0;
                        par.SourceContext = base.sourceContext;
                        par.Type = type; // SystemTypes.Object;
                        property.Setter.Parameters.Add(par);
                    }
                    interfac.Members.Add(property);
                    if (getter)
                        interfac.Members.Add(property.Getter);  // otherwise 'internal error in compiler'
                    if (setter)
                        interfac.Members.Add(property.Setter);  // otherwise 'internal error in compiler'

                    locals[i].node = property;

                    if (locals[i].type is ARRAY_TYPE) {
                        //adding metadata
                        InstanceInitializer ii_v = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
                        MemberBinding attrBinding_v = new MemberBinding(null, ii_v);
                        ExpressionList args_v = new ExpressionList();
                        if ((locals[i].type as ARRAY_TYPE).isMath)
                            args_v.Add(new Literal("math array", SystemTypes.String));
                        else
                            args_v.Add(new Literal("simple array", SystemTypes.String));
                        AttributeNode attrNode_v = new AttributeNode(attrBinding_v, args_v, AttributeTargets.All);
                        property.Attributes.Add(attrNode_v);
                    }
                } else if (declaration is PROCEDURE_DECL) {
                    Method method = (Method)(((PROCEDURE_DECL)declaration).convert());
                    if (method != null) {
                        if (method.Name.Name == "Finalize") {
                            ERROR.NotAllowedName("Finalize", "definitions due to it's special meaning for object's finalization", declaration.sourceContext);
                            ErrorReported = true;
                            continue;
                        }
                        interfac.Members.Add(method);
                    }
                } else
                    if (declaration is IMPORTSPACE_DECL) {
                    foreach (Member m in ((NameBinding)(declaration.convert())).BoundMembers)
                        interfac.Members.Add(m);
                    } else  // ANY OTHER DEFINITION MEMBERS????
                {
                }
            }

            //adding metadata
            InstanceInitializer ii = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
            MemberBinding attrBinding = new MemberBinding(null, ii);
            ExpressionList args = new ExpressionList();
            string metadata = "definition";
            foreach (string s in imports)
            {
                metadata += "\nimport:" + s;
            }
            args.Add(new Literal(metadata, SystemTypes.String));
            
            AttributeNode attrNode = new AttributeNode(attrBinding, args, AttributeTargets.All);
            interfac.Attributes.Add(attrNode);

            CONTEXT.current_unit = saved;
            CONTEXT.current_routine = saved2;
            return node;
        }

        // convertSatellite
        // ----------------
        // The function generates "companion" code for definition
        // directly inside module/object implementing that definition.
        //
        // The function is called from MODULE_DECL.convert() and OBJECT_DECL.convert().
        //
        public void convertSatellite(UNIT_DECL unit, bool module) {
            Class cls = (Class)unit.node;

            IMPLEMENTATION_DECL implementation = this.default_implementation as IMPLEMENTATION_DECL;

            if (cls.Members == null)
                cls.Members = new MemberList();

            for (int i = 0, n = locals.Length; i < n; i++) {
                DECLARATION declaration = locals[i];

                if (declaration is VARIABLE_DECL) {
                    // Moved to addUnimplementedEntities
                } else if (declaration is TYPE_DECL) {
                    TypeNode t = (TypeNode)declaration.convert();
                    if ( t != null )
                        t.Flags |= TypeFlags.NestedPublic;
                    cls.Members.Add(t);
                } else  // ANY OTHER DEFINITION MEMBERS????
                {
                }
            }
        }

        public void addUnimplementedEntities(UNIT_DECL unit, bool module, string mixedName) {
            
            string unit_kind = module?"module":"object";

            TypeNode cls = (TypeNode)unit.node;            

            if (cls.Members == null)
                cls.Members = new MemberList();

            DEFINITION_DECL def = this;
         //   while(def != null)
         //   {
                #region ForEachDefinition
            for (int i = 0, n = def.locals.Length; i < n; i++) {
                    DECLARATION declaration = def.locals[i];
                    bool SomeProcExists = false;  // for procedures in definition (not for variables)

                if (declaration is VARIABLE_DECL) {
                        #region VariableDeclaration
                        IMPLEMENTATION_DECL implementation = def.default_implementation as IMPLEMENTATION_DECL;
                        TypeNode type = (TypeNode)declaration.type.convert();
                        string   name = declaration.name.Name;

                        // First of all, generate the property itself for MODULES
                        Property property = null;

                    //  if ( module )
                    //  {
                            // Generating property which corresponds to the variable
                            property = new Property();
                         // property.Attributes;
                            property.DeclaringType = cls;
                            property.Flags = PropertyFlags.None;
                         // property.Getter;  -- see below
                         // property.HidesBaseClassMember;
                         //   property.ImplementedTypes = new TypeNodeList();
                         //   property.ImplementedTypes.Add((TypeNode)this.convert());
                            property.Name = Identifier.For(name);
                         // property.NodeType;
                         // property.OtherMethods;
                         // property.OverridesBaseClassMember;
                         // property.Parameters;
                         // property.Setter;  -- see below
                            property.SourceContext = base.sourceContext;
                            property.Type = type;
                        //    property.OverridesBaseClassMember = true;
                            cls.Members.Add(property);
                    //  }

                        NODE getter_in_unit = unit.find_getter(declaration.name);
                        NODE setter_in_unit = unit.find_setter(declaration.name);
                        NODE getter_in_impl = null;
                        NODE setter_in_impl = null;

                        bool need_getter = false, need_setter = false;

                    if (getter_in_unit != null) {
                            Method getter = (Method)getter_in_unit.convert();
                        if (getter == null) /* an error */
                            goto Skip1;
                            getter.ImplementedInterfaceMethods = new MethodList();
                            Member def_getter = ((Interface)node).GetMembersNamed(Identifier.For("get_"+name))[0];
                            getter.ImplementedInterfaceMethods.Add((Method)def_getter);
                            property.Getter = getter;
                    Skip1:
                        ;
                    } else {
                            // No getter for the definition variable defined in object/module.
                            // Perhaps, there is a getter in the default implementation?
                            if ( implementation != null )
                                getter_in_impl = implementation.find_getter(declaration.name);
                        }
                    if (setter_in_unit != null) {
                            Method setter = (Method)setter_in_unit.convert();
                        if (setter == null) /* en error */
                            goto Skip2;
                            setter.ImplementedInterfaceMethods = new MethodList();
                            Member def_setter = ((Interface)node).GetMembersNamed(Identifier.For("set_"+name))[0];
                            setter.ImplementedInterfaceMethods.Add((Method)def_setter);
                            property.Setter = setter;
                    Skip2:
                        ;
                    } else {
                            // No setter for the definition variable defined in object/module.
                            // Perhaps, there is a setter in the default implementation?
                            if ( implementation != null )
                                setter_in_impl = implementation.find_setter(declaration.name);
                        }

                        // If there is no getter/setter anywhere - that is, 
                        // a) we do not have an implementation at all (otherwise we do have accessors anyway)
                        // b) there is no getter/setter in the object/module itself, 
                        // then we need to generate default one(s).
                        if ( declaration.modifiers.Getter && implementation == null && getter_in_unit == null )
                            need_getter = true;
                        if ( declaration.modifiers.Setter && implementation == null && setter_in_unit == null )
                            need_setter = true;

                    if (need_getter || need_setter) {
                            // We need to generate either getter or setter or both for object/module.
                            // Before that, we have to generate the internal (default) variable 
                            // which will be used as the internal representation for the accessor(s).
                            //
                            // NOTICE that it is not necessary to generate the property itself
                            // because the accessors are the implementations of the existing property
                            // which is already defined in the definition.
                            // - NO: for MODULES we do need the property in the module body!

                            VARIABLE_DECL var = (VARIABLE_DECL)declaration;

                            Field variable = new Field();

                            variable.Type = type;
                            variable.Name = Identifier.For(name+"_default");
                            variable.Flags = FieldFlags.Private;
                        if (module)
                            variable.Flags |= FieldFlags.Static;
                         // variable.Attributes;
                            variable.DeclaringType = cls;
                            variable.DefaultValue = null;
                            variable.Initializer = var.createInitializer(var);

                            cls.Members.Add(variable);

                            // Now generate the accessor(s) needed

                        if (need_getter) {
                                // Getter is not declared; generating it here.
                                Method getter = new Method();
                                getter.Body = new Block();
                                getter.Body.Statements = new StatementList();

                                // Making 'return <variable>;'
                                Return return_stmt = new Return();
                                if ( module )
                                    return_stmt.Expression = new MemberBinding(null,variable);
                                else
                                    return_stmt.Expression = new MemberBinding(new This(),variable); //Identifier.For(name+"_default");
                                return_stmt.SourceContext = base.sourceContext;
                                getter.Body.Statements.Add(return_stmt);

                                getter.DeclaringType = cls;
                                getter.Flags = MethodFlags.Public | MethodFlags.SpecialName;
                            if (module)
                                getter.Flags |= MethodFlags.Static;
                            else
                                getter.CallingConvention = CallingConventionFlags.HasThis;

                             // if ( !module )
                             // {
                                    getter.ImplementedInterfaceMethods = new MethodList();
                                    Member def_getter = ((Interface)node).GetMembersNamed(Identifier.For("get_"+name))[0];
                                    getter.ImplementedInterfaceMethods.Add((Method)def_getter);
                             // }
                                getter.Name = Identifier.For("get_"+name);
                                getter.ReturnType = type;
                                getter.Parameters = null;

                                cls.Members.Add(getter);
                            /*   if ( module ) */
                            property.Getter = getter;
                            }
                        if (need_setter) {
                                // Setter is not declared; generating it here.
                                Method setter = new Method();
                                setter.Body = new Block();
                                setter.Body.Statements = new StatementList();

                                // Making '<variable> = value;'
                                AssignmentStatement assign = new AssignmentStatement();
                                assign.Operator = NodeType.Nop;
                                if ( module )
                                    assign.Target = new MemberBinding(null,variable);
                                else
                                    assign.Target = new MemberBinding(new This(),variable); // Identifier.For(name+"_default");
                                assign.Source = Identifier.For("value");
                                setter.Body.Statements.Add(assign);

                                setter.DeclaringType = cls;
                                setter.Flags = MethodFlags.Public | MethodFlags.SpecialName;
                            if (module)
                                setter.Flags |= MethodFlags.Static;
                            else
                                setter.CallingConvention = CallingConventionFlags.HasThis;

                             // if ( !module )
                             // {
                                    setter.ImplementedInterfaceMethods = new MethodList();
                                    Member def_setter = ((Interface)node).GetMembersNamed(Identifier.For("set_"+name))[0];
                                    setter.ImplementedInterfaceMethods.Add((Method)def_setter);
                             // }
                                setter.Name = Identifier.For("set_"+name);
                                setter.ReturnType = SystemTypes.Void; // type;
                                setter.Parameters = new ParameterList();

                                Parameter par = new Parameter();
                             // par.Attributes;
                                par.DefaultValue = null;
                                par.Flags = ParameterFlags.In;
                             // par.MarshalType;
                                par.Name = Identifier.For("value");
                             // par.NodeType;
                                par.ParameterListIndex = 0;
                                par.SourceContext = base.sourceContext;
                                par.Type = type; // SystemTypes.Object;
                                setter.Parameters.Add(par);

                                cls.Members.Add(setter);
                            /* if ( module ) */
                            property.Setter = setter;
                            }
                    } else if (implementation != null) {
                            // Implementation unit contains (default) implementation 
                            // of the accessors. We should generate the "equivalents"
                            // to these accessors in the module/object according the following scheme:
                            //
                            // object O implements D;
                            //
                            //       ==>  D D_mixed = new D_implem();
                            //
                            //            int  get_i() { return D_mixed.i; }
                            //            void set_i(int v) { D_mixed.i = v; }

                            bool need_replacement_getter = declaration.modifiers.Getter && getter_in_unit == null;
                            bool need_replacement_setter = declaration.modifiers.Setter && setter_in_unit == null;

                        if (need_replacement_getter) {
                                Method getter = new Method();
                                getter.Body = new Block();
                                getter.Body.Statements = new StatementList();

                                // Making 'return D_mixed.i;'
                                Return return_stmt = new Return();
                                return_stmt.Expression = new QualifiedIdentifier(
                                                                Identifier.For(mixedName),
                                                                Identifier.For(name));
                                return_stmt.SourceContext = base.sourceContext;
                                getter.Body.Statements.Add(return_stmt);

                                getter.DeclaringType = cls;
                                getter.Flags = MethodFlags.Public | MethodFlags.SpecialName;
                            if (module)
                                getter.Flags |= MethodFlags.Static;
                            else
                                getter.CallingConvention = CallingConventionFlags.HasThis;

                             // if ( !module )
                             // {
                                    getter.ImplementedInterfaceMethods = new MethodList();
                                    Member def_getter = ((Interface)node).GetMembersNamed(Identifier.For("get_"+name))[0];
                                    getter.ImplementedInterfaceMethods.Add((Method)def_getter);
                             // }
                                getter.Name = Identifier.For("get_"+name);
                                getter.ReturnType = type;
                                getter.Parameters = null;

                                cls.Members.Add(getter);
                            /* if ( module ) */
                            property.Getter = getter;
                            }
                        if (need_replacement_setter) {
                                Method setter = new Method();
                                setter.Body = new Block();
                                setter.Body.Statements = new StatementList();

                                // Making 'D_mixed.i = value;'
                                AssignmentStatement assign = new AssignmentStatement();
                                assign.Operator = NodeType.Nop;
                                assign.Target = new QualifiedIdentifier(Identifier.For(mixedName),
                                                                        Identifier.For(name));
                                assign.Source = Identifier.For("value");
                                setter.Body.Statements.Add(assign);

                                setter.DeclaringType = cls;
                                setter.Flags = MethodFlags.Public | MethodFlags.SpecialName;
                            if (module)
                                setter.Flags |= MethodFlags.Static;
                            else
                                setter.CallingConvention = CallingConventionFlags.HasThis;

                             // if ( !module )
                             // {
                                    setter.ImplementedInterfaceMethods = new MethodList();
                                    Member def_setter = ((Interface)node).GetMembersNamed(Identifier.For("set_"+name))[0];
                                    setter.ImplementedInterfaceMethods.Add((Method)def_setter);
                             // }
                                setter.Name = Identifier.For("set_"+name);
                                setter.ReturnType = SystemTypes.Void; // type;
                                setter.Parameters = new ParameterList();

                                Parameter par = new Parameter();
                             // par.Attributes;
                                par.DefaultValue = null;
                                par.Flags = ParameterFlags.In;
                             // par.MarshalType;
                                par.Name = Identifier.For("value");
                             // par.NodeType;
                                par.ParameterListIndex = 0;
                                par.SourceContext = base.sourceContext;
                                par.Type = type; // SystemTypes.Object;
                                setter.Parameters.Add(par);

                                cls.Members.Add(setter);
                            /* if ( module ) */
                            property.Setter = setter;
                            }
                        }
                        continue;
                        #endregion
                    }
                if (declaration is PROCEDURE_DECL) {
                        #region ProcedureDecl
                        NODE decl = unit.find_in_scope(declaration.name);
                    if (decl != null) {
                        if (decl is UNKNOWN_DECL)
                            decl = decl.resolve();
                            PROCEDURE_DECL proc = decl as PROCEDURE_DECL;
                            if (proc != null)
                            {
                                if (proc.prototype == null) SomeProcExists = true;
                                if (proc.prototype != null /*&& proc.prototype.enclosing == this - obsolete*/ ) continue;
                                // It's OK: procedure is implemented in object/module
                            }
                            else // This is something else
                            {
                                // Duplicate?
                            }
                        }
                        // Otherwise, it is not implemented.
                        // Looking through the default implementation for it...

                        // Otherwise, implementation exists
                        DEFINITION_DECL fdef = def;
                    while (decl == null && fdef != null) {
                            IMPLEMENTATION_DECL implementation = fdef.default_implementation as IMPLEMENTATION_DECL;
                            if (implementation == null) // no implementation
                                goto NoImplementation;
                            decl = implementation.find(declaration.name);
                        if (decl.enclosing is DEFINITION_DECL)
                            decl = null;
                            fdef = (DEFINITION_DECL)fdef.base_definition;
                        }
                        if ( decl == null )  // no such entity in the implementation
                            goto NoImplementation;

                        // Entity exists
                        if ( decl.enclosing is DEFINITION_DECL )  // the same situation as before
                            goto NoImplementation;

                        // Otherwise, 'implementation' unit contains (default)
                        // implementation of the procedure. Generating the "equivalent"
                        // in the module/object according the following scheme:
                        //
                        // definition D;             <== interface D {
                        //     procedure P;          <==     void P();
                        // end D.                    <== }
                        //
                        // implementation D;
                        //     procedure P implements D.P; begin ... end P;
                        // end D.
                        //                           <== class D_implem : D {
                        //                           <==     override void D.P () { ... }
                        //                           <== }
                        //
                        // object O implements D;    <== public sealed class O : D {
                        //                           <==     private D_implem D_mixed;
                        //                           <==     public void D.P() { D_mixed.P(); }
                        // end O.                    <== }

                    //  Method method = (Method)declaration.node.Clone();
                        PROCEDURE_DECL p = declaration as PROCEDURE_DECL;

                        Method method = new Method();
                        if (module)
                            method.CallingConvention = CallingConventionFlags.Default;
                        else
                            method.CallingConvention = CallingConventionFlags.HasThis;
                        method.DeclaringType = (TypeNode)unit.convert();
                        if ( module )
                            method.Flags = MethodFlags.Public | MethodFlags.Static;
                        else
                            method.Flags = MethodFlags.NewSlot | MethodFlags.Public | MethodFlags.Virtual |
                                           MethodFlags.HideBySig | MethodFlags.Final;
                    if (!module) {
                            method.ImplementedInterfaceMethods = new MethodList();
                            method.ImplementedInterfaceMethods.Add((Method)declaration.convert());
                            method.OverriddenMethod = (Method)declaration.convert();
                        }
                        method.Name = declaration.name;
                        method.Parameters = new ParameterList();
                    for (int j = 0, m = p.paramCount; j < m; j++) {
                            Parameter tpar = (Parameter)p.parameters[j].convert();
                        if (tpar != null) {
                                Parameter par = (Parameter)tpar.Clone();
                                par.DeclaringMethod = method;
                                method.Parameters.Add(par);
                        } else {
                                ERROR.UndeclaredUnit(sourceContext, "argument");
                            }
                        }
                        method.ReturnType = (TypeNode)p.return_type.convert();
                        method.SourceContext = decl.sourceContext;

                        method.Body = new Block(new StatementList());
                        MethodCall call = new MethodCall();
                        call.Callee = new QualifiedIdentifier(Identifier.For(mixedName),
                                                              Identifier.For(method.Name.Name));
                        call.Operands = new ExpressionList();
                        for ( int j=0, m=method.Parameters.Length; j<m; j++ )
                            call.Operands.Add(Identifier.For(method.Parameters[j].Name.Name));
                        // TODO: take into account the passing rules like value/reference etc.
                    if (method.ReturnType == SystemTypes.Void) {
                            ExpressionStatement call_stmt = new ExpressionStatement();
                            call_stmt.Expression = call;
                            call_stmt.SourceContext = decl.sourceContext;
                            method.Body.Statements.Add(call_stmt);
                    } else {
                            Return ret = new Return();
                            ret.Expression = call;
                            ret.SourceContext = decl.sourceContext;
                            method.Body.Statements.Add(ret);
                        }
                        cls.Members.Add(method);
                        continue;
                        #endregion
                } else
                        continue;

                     NoImplementation:
                    ERROR.NoEntityImplementation(unit.sourceContext,
                                                 unit_kind,unit.name.Name,UNIT.generateFullName(declaration));
                    // Create dummy code for the entity - just to prevent
                    // duplicated CCI message.
                if (SomeProcExists)
                    continue;
                    // Without this condition, two methods with the same name
                    // are in the class, and I don't understand why CCI doesn't like this...

                    Method dummy = (Method)declaration.node.Clone();
                    dummy.CallingConvention = CallingConventionFlags.HasThis;
                    dummy.DeclaringType = (TypeNode)unit.convert();
                    if ( module ) 
                        dummy.Flags = MethodFlags.NewSlot | MethodFlags.Public | MethodFlags.HideBySig |
                                      MethodFlags.Final | MethodFlags.Static;
                    else // object
                        dummy.Flags = MethodFlags.NewSlot | MethodFlags.Public | MethodFlags.Virtual |
                                      MethodFlags.HideBySig | MethodFlags.Final;
                    dummy.ImplementedInterfaceMethods = new MethodList();
                    dummy.ImplementedInterfaceMethods.Add((Method)declaration.convert());
                    dummy.OverriddenMethod = (Method)declaration.convert();
                 // dummy.Name        -- remains untouched
                 // dummy.Parameters  -- remains untouched
                 // dummy.ReturnType  -- remains untouched
                 // dummy.SourceContext -- doesn't make any sense because this is just dummy
                    dummy.Body = new Block(new StatementList());  // empty body

                    cls.Members.Add(dummy);
                    continue;
                }
                #endregion
                   
                def = def.base_definition as DEFINITION_DECL;
                
                if( def != null) def.addUnimplementedEntities ( unit, module, mixedName/* def.name.Name + "_mixed" */);
            //}// For each definition in refine list                
        }

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            if (modifiers.Public)
                System.Console.Write("PUBLIC ");
            else
                System.Console.Write("PRIVATE ");
            System.Console.Write("DEFINITION {0}, line={1}",base.name.ToString(), this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("REFINED DEFINITION: ");
            if ( base_definition == null )
                System.Console.WriteLine("MISSED");
            else {
                base_definition.report_short();
                System.Console.WriteLine();
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("DEFAULT IMPLEMENTATION: ");
            if ( default_implementation == null )
                System.Console.WriteLine("MISSED");
            else {
                default_implementation.report_short();
                System.Console.WriteLine();
            }

            base.report(shift+reportShift);
        }

        public override void report_short() {
            System.Console.Write("DEFINITION {0}:{1}",unique,name.Name);
        }
#endif
    }

    // IMPLEMENTATION_DECL
    // ===================
    //
    // Implementation = IMPLEMENTATION ImplementationName ";"
    //                      [ ImportDeclaration ]
    //                        Declarations
    //                      ( Blockstatement | END ) SimpleName.
    //
    public sealed class IMPLEMENTATION_DECL : UNIT_DECL {
        // Constructor
        public IMPLEMENTATION_DECL ( Identifier name ) : base(ASTNodeType.IMPLEMENTATION_DECL, name) { }

        //-----------------------------------------------------------------

        // FROM THE BASE:
     // public DECLARATION_LIST  locals; -- imports, members, procedures
     // public BLOCK             body;   -- implementation's body

        public UNIT_DECL         implemented_definition;  // either UNKNOWN_DECL or DEFINITION_DECL

        //-----------------------------------------------------------------
        public override NODE findExcludingDefs(Identifier name) {
            return base.find(name);
        }

        public override NODE find(Identifier name) {
            NODE result = base.find(name);

            if ( implemented_definition != null &&
                 ( result == null || (result is UNKNOWN_DECL && !CONTEXT.firstPass) ) )
                result = implemented_definition.find(name);
            
            if ((result == null) && (enclosing != null))
                result = enclosing.find(name);

            return result;
        }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            for (int i = 0; i < locals.Length; i++)
            {
                if (locals[i] == null) continue;
                NODE scope = locals[i].findScopeAtContext(line, col, documentName);
                if (scope != null)
                    return scope;
            }
            return null;
        }

        //-----------------------------------------------------------------

        public static IMPLEMENTATION_DECL create(IDENT_LIST name) {
            Identifier id = name[name.Length-1];

            // First, create implementation.
            IMPLEMENTATION_DECL implementation = new IMPLEMENTATION_DECL(id);
         // implementation.body               -- will be filled later
         // implementation.enclosing
         // implementation.full_name
         // implementation.implemented_definition
         // implementation.locals             -- will be filled later
         // implementation.sourceContext

            // Second, build the context; in particular,
            // implementation's 'enclosing' field will be set.
            DECLARATION anotherUnit = UNIT_DECL.processName(implementation,name);

            // Then, check the nesting
            NODE context = CONTEXT.current;
            if ( context != null && !(context is NAMESPACE_DECL) && !(context is MODULE_DECL) )
                // Cannot declare definition in any compilation unit
                ERROR.IllegalNesting("implementation in a compilation unit other than module");

            // Check the uniqueness of the implementation name.
            if (anotherUnit != null) {
                // There IS a unit or namespace with the same name in the same scope!
///////         bool err = true;
                if (anotherUnit is NAMESPACE_DECL) {
                    // 'unit' is NOT a real unit (i.e., it is a NAMESPACE)
                    // Message:
                    // cannot declare <unit> <name>:
                    // there is <namespace> with the same name in the current scope
                    ERROR.IncorrectUnitName("implementation",anotherUnit.name.Name,"namespace");
                } else if (anotherUnit is IMPLEMENTATION_DECL) {
                    // Message:
                    // duplicate declaration of <unit_name> <name>
                    ERROR.DuplicateUnit("implementation",anotherUnit.name.Name);
                } else if (anotherUnit is DEFINITION_DECL) {
                    // The definition with the same name as new implementation exists.
                    // We will link both units together.
                    DEFINITION_DECL definition = anotherUnit as DEFINITION_DECL;

                    // Additional check: perhaps there IS implementation already linked with
                    // definition just found?
                    if ( definition.default_implementation != null )
                        ERROR.SystemErrorIn("IMPLEMENTATION_DECL.create","definition is already busy???");

                    implementation.implemented_definition = definition;
                    definition.default_implementation = implementation;
///////             err = false;
                } else if (anotherUnit is UNKNOWN_DECL) {
                    // There is unresolved external unit with the same name; resolve it!
                    UNKNOWN_DECL another = anotherUnit as UNKNOWN_DECL;
                    another.name = null;
                    another.RealDeclaration = implementation;
///////             err = false;
                } else {
                    // The existing compilation unit is NEITHER definition NOR implementation.
                    // Message:
                    // cannot declare <implementation> <name>:
                    // there is <an unrelated unit> with the same name in the current scope
                    ERROR.IncorrectUnitName("implementation",anotherUnit.name.Name,"an unrelated unit");
                }
////////        if ( err ) implementation.name = ERROR.errUnitName; //null;
            }
         // else -- NO unit with the given name; that's OK.

            // Add new implementation to the current context.
            CONTEXT.enter(implementation);
            return implementation;
        }

        //-----------------------------------------------------------------

        public override NODE resolve() {
            
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o ...
            return true;
        }

        //------------------------------------------------------------------------------

        public override TYPE type  // evaluates implementation; doesn't make sense
        {
            get { return null; }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            // Looks very similar to the same method for OBJECTs.
            // The major differences are:
            // - no user-defined implemented definitions (but exactly one which
            //   is the definition with the same name as this implementation);
            // - no parameters hence the constructor is always parameterless;
            // - the target class contains some entities taken from the definition
            //   (eg, implements definition's variables as properties).

            if (node != null)
                return node;

         // resolve();
            if (!validate())
                return null;

            Class cls = new Class();  // Zonnon implementation is mapped to CLI sealed class
            node = cls;

            UNIT_DECL saved = CONTEXT.current_unit;
            ROUTINE_DECL saved2 = CONTEXT.current_routine;
            CONTEXT.current_unit = this;
            CONTEXT.current_routine = null;

            // This is the special structure for collecting members' initializers.
            // Initializers will be collected during members' processing and later
            // (see below) the structure with initializers will go to the ctor's body.
            FieldInitializerBlock initializers = new FieldInitializerBlock();
            initializers.Statements = new StatementList();
            initializers.IsStatic = false;
            initializers.Type = cls;

            StatementList init_statements = new StatementList();

         // cls.Attributes;
         // cls.BaseClass;
         // cls.BaseType;
         // cls.ClassSize;
            cls.DeclaringModule = CONTEXT.symbolTable;
            if (enclosing != null) {
                if ( enclosing is NAMESPACE_DECL)  // global object
                    CONTEXT.symbolTable.Types.Add(cls);
                else  // local implementation
                    cls.DeclaringType = (TypeNode)enclosing.convertAndGetType();
            }
         // cls.ExplicitCoercionMethods;
            cls.Flags = TypeFlags.None; // TypeFlags.Sealed;

            bool publ = false;
            if ((this.implemented_definition != null))
                publ = this.implemented_definition.modifiers.Public;
            if ( enclosing is NAMESPACE_DECL )
            {
                if ( publ ) cls.Flags |= TypeFlags.Public;
                else                    cls.Flags |= TypeFlags.NotPublic;
            }
            else
            {
                if ( publ ) cls.Flags |= TypeFlags.NestedPublic;
                else                    cls.Flags |= TypeFlags.NestedPrivate;
            }

         // cls.FullName;
         // cls.HidesBaseClassMember;
         // cls.ImplicitCoercionMethods;
            if (cls.Members == null)
                cls.Members = new MemberList();

            // Generating object constructor
            InstanceInitializer ctor = new InstanceInitializer();
         // Immediately initializing its fields, otherwise possible crash 
         // because of recursive call.

         // ctor.Body.UniqueKey
            ctor.CallingConvention |= CallingConventionFlags.HasThis;
            ctor.DeclaringType = cls;
         // ctor.Ensures;
         // ctor.ExceptionHandlers;
            ctor.Flags |= MethodFlags.Public | MethodFlags.SpecialName | MethodFlags.RTSpecialName;
            ctor.Flags |= MethodFlags.HideBySig;
            ctor.HasCompilerGeneratedSignature = false;
         // ctor.ImplementedInterfaceMethod;
         // ctor.ImplementedInterfaceMethods;
         // ctor.ImplementedTypes;
         // ctor.ImplFlags;
            ctor.InitLocals = true;
         // ctor.NodeType;
         // ctor.Parameters = null; -- already generated
         // ctor.PInvokeFlags;
         // ctor.PInvokeImportName;
         // ctor.PInvokeModule;
         // ctor.Requires;
         // ctor.ReturnAttributes;
            ctor.ReturnType = SystemTypes.Void;
         // ctor.Scope;
            ctor.SourceContext = base.sourceContext;
         // ctor.Template;
         // ctor.TemplateArguments;
         // ctor.TemplateParameters;
         // ctor.UniqueKey;
            cls.Members.Add(ctor); // adding ctor to members even before it is completely generated

            ctor.Parameters = new ParameterList();  // no pars for implementation's ctor
         // ctor.Attributes
            ctor.Body = new Block();

            ctor.Body.Checked = false;  // ???
            ctor.Body.HasLocals = false;  // ??????????????????????????
         // ctor.Body.NodeType;
            if ( base.body.statements.Length > 0 ) // can be 0 because of pasre errors
                ctor.Body.SourceContext = base.body.statements[0].sourceContext;

            // Generating ctor's body
            ctor.Body.Statements = new StatementList();
            // Generate base class ctor's invokation: System.Object::.ctor(),
            // and the call to its constructor
            cls.BaseClass = SystemTypes.Object;
            MethodCall superCtorCall =
                new MethodCall(new QualifiedIdentifier(new Base(),StandardIds.Ctor),null,NodeType.Call);
            ctor.Body.Statements.Add(new ExpressionStatement(superCtorCall));

            // Adding field initializers - in fact, nothing...
            ctor.Body.Statements.Add(initializers);
            // Adding "real" field initializers
            for ( int i=0, n=init_statements.Length; i<n; i++ )
                ctor.Body.Statements.Add(init_statements[i]);

            // Finally, generating body itself
            for ( int i=0,n=base.body.statements.Length; i<n; i++)  // in fact, only ONE statement: block.
                ctor.Body.Statements.Add((Statement)(base.body.statements[i].convert()));

            // now continue generating class...
            cls.Name = Identifier.For(base.name.Name+"_implem");
            if ( enclosing != null && enclosing is NAMESPACE_DECL )
                cls.Namespace = Identifier.For(NODE.generateFullName(enclosing));
         // cls.NodeType;
         // cls.OverridesBaseClassMember;
         // cls.PackingSize;
            cls.SourceContext = base.sourceContext;

            // Adding reference to implemented definition
            cls.Interfaces = new InterfaceList();
            if ( this.implemented_definition != null )
                cls.Interfaces.Add((Interface)this.implemented_definition.convert());

            // Converting members.
            // If there are initializers for members then we collect them
            // in FieldInitializerBlock structure.
            for (int i = 0, n = locals.Length; i < n; i++) {
                if (locals[i] is UNKNOWN_DECL)
                    continue;

                Node member = locals[i].convert();

                if ((member is Member) && (locals[i].type is ARRAY_TYPE)) {
                    //adding metadata
                    InstanceInitializer ii_v = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
                    MemberBinding attrBinding_v = new MemberBinding(null, ii_v);
                    ExpressionList args_v = new ExpressionList();
                    if ((locals[i].type as ARRAY_TYPE).isMath)
                        args_v.Add(new Literal("math array", SystemTypes.String));
                    else
                        args_v.Add(new Literal("simple array", SystemTypes.String));
                    AttributeNode attrNode_v = new AttributeNode(attrBinding_v, args_v, AttributeTargets.All);
                    (member as Member).Attributes.Add(attrNode_v);
                }

                if (locals[i] is VARIABLE_DECL) {
                    Block array_initializers = ((VARIABLE_DECL)locals[i]).createElementInitializer();
                    if ( array_initializers != null )
                     // initializers.Statements.Add(array_initializers);
                        init_statements.Add(array_initializers);
                } else
                    if (locals[i] is IMPORTSPACE_DECL) {
                    foreach (Member m in ((NameBinding)member).BoundMembers)
                        cls.Members.Add(m);
                }
                if (member == null)
                    continue;
                if (member is Member) {
                    cls.Members.Add((Member)member);
                }
                // else -- an error; the message is already issued
                //     continue;
            }

            addFromDefinition(this.implemented_definition as DEFINITION_DECL);

            //adding metadata
            InstanceInitializer ii = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
            MemberBinding attrBinding = new MemberBinding(null, ii);
            ExpressionList args = new ExpressionList();
            args.Add(new Literal("implementation", SystemTypes.String));
            AttributeNode attrNode = new AttributeNode(attrBinding, args, AttributeTargets.All);
            cls.Attributes.Add(attrNode);

            CONTEXT.current_unit = saved;
            CONTEXT.current_routine = saved2;
            return node;
        }

        // addFromDefinition
        // -----------------
        // The function generates "companion" code for implementation
        // adding images for definition entities which are not explicitly
        // specified in the implementation.
        //
        // The function is invoked after the main generation for the implementation
        // is completed.
        //
        private void addFromDefinition(DEFINITION_DECL definition) {
            if (definition == null)
                return;  // no definition for this implementation

            Class cls = (Class)node;

            // checking if definition REFINES another
            UNIT_DECL unit = ((DEFINITION_DECL)definition.base_definition);
            if (unit != null && ((DEFINITION_DECL)unit).default_implementation != null)
                unit = ((DEFINITION_DECL)unit).default_implementation;
            if (unit != null) { // REFINES                
                unit.convert();

                Node result = unit.convertAndGetType();
                if (result is Interface) {
                    cls.Interfaces.Add((Interface)result);
                } else if (result is Class) {
                    if (((Class)cls).BaseClass == SystemTypes.Object) {
                        ((Class)cls).BaseClass = (Class)result;
                    } else {
                        // Error: two base classes!
                        ERROR.SystemErrorIn("OBJECT_DECL.convert", "more than one base class");
                    }
                }
            } // end REFINES

            if (definition.locals == null)
                return;

            for (int i = 0, n = definition.locals.Length; i < n; i++) {
                DECLARATION def_declaration = definition.locals[i];

                if (def_declaration is VARIABLE_DECL) {
                    string   name = def_declaration.name.Name;
                    TypeNode type = (TypeNode)def_declaration.type.convert();

                    Field variable = null;

                    NODE existing_getter = this.find_getter(def_declaration.name);
                    NODE existing_setter = this.find_setter(def_declaration.name);

                    if ( ( def_declaration.modifiers.Getter && existing_getter == null ) || 
                         (def_declaration.modifiers.Setter && existing_setter == null)) {
                        // At least one accessor is assumed but not implemented;
                        // so we have to generate the default internal variable
                        // for the unimplemented accessor. (Later, see below,
                        // we will generate the accessor itself).
                        VARIABLE_DECL var = (VARIABLE_DECL)def_declaration;

                        variable = new Field();

                        variable.Type = type;
                        variable.Name = Identifier.For(name+"_default");
                        variable.Flags = FieldFlags.Private;
                     // variable.Attributes;
                        variable.DeclaringType = cls;
                        variable.DefaultValue = null;
                        variable.Initializer = var.createInitializer(var);

                        if (def_declaration.type is ARRAY_TYPE) {
                            //adding metadata
                            InstanceInitializer ii_v = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
                            MemberBinding attrBinding_v = new MemberBinding(null, ii_v);
                            ExpressionList args_v = new ExpressionList();
                            if ((def_declaration.type as ARRAY_TYPE).isMath)
                                args_v.Add(new Literal("math array", SystemTypes.String));
                            else
                                args_v.Add(new Literal("simple array", SystemTypes.String));
                            AttributeNode attrNode_v = new AttributeNode(attrBinding_v, args_v, AttributeTargets.All);
                            variable.Attributes.Add(attrNode_v);
                        }

                        cls.Members.Add(variable);
                    }

                    // Generating property which corresponds to the variable
              
                    Property property = new Property();
                 // property.Attributes;
                    property.DeclaringType = cls;
                    property.Flags = PropertyFlags.None;
                 // property.Getter;  -- see below
                 // property.HidesBaseClassMember;
                    property.ImplementedTypes = new TypeNodeList();
                    property.ImplementedTypes.Add((TypeNode)definition.convert());
                    property.Name = Identifier.For(name);
                 // property.NodeType;
                 // property.OtherMethods;
                 // property.OverridesBaseClassMember;
                 // property.Parameters;
                 // property.Setter;  -- see below
                    property.SourceContext = base.sourceContext;
                    property.Type = type;

                    if (def_declaration.type is ARRAY_TYPE) {
                        //adding metadata
                        InstanceInitializer ii_p = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
                        MemberBinding attrBinding_p = new MemberBinding(null, ii_p);
                        ExpressionList args_p = new ExpressionList();
                        if ((def_declaration.type as ARRAY_TYPE).isMath)
                            args_p.Add(new Literal("math array", SystemTypes.String));
                        else
                            args_p.Add(new Literal("simple array", SystemTypes.String));
                        AttributeNode attrNode_p = new AttributeNode(attrBinding_p, args_p, AttributeTargets.All);
                        property.Attributes.Add(attrNode_p);
                    }

                    if (existing_getter != null) {
                        property.Getter = (Method)existing_getter.convert();
                    } else if (def_declaration.modifiers.Getter && existing_getter == null) {
                        // Getter is assumed but not implemented; generating it here.
                        Method getter = new Method();
                        getter.Body = new Block();

                        // Making 'return <variable>;'
                        Return return_stmt = new Return();
                        return_stmt.Expression = new MemberBinding(new This(),variable);
                        return_stmt.SourceContext = base.sourceContext;
                        getter.Body.Statements = new StatementList();
                        getter.Body.Statements.Add(return_stmt);

                        getter.DeclaringType = cls;
                        getter.Flags = MethodFlags.Public | MethodFlags.SpecialName;
                        getter.CallingConvention = CallingConventionFlags.HasThis;

                        getter.ImplementedInterfaceMethods = new MethodList();
                        Member def_getter = ((Interface)definition.convert()).GetMembersNamed(Identifier.For("get_"+name))[0];
                        getter.ImplementedInterfaceMethods.Add((Method)def_getter);

                        getter.Name = Identifier.For("get_"+name);
                        getter.ReturnType = type;
                        getter.Parameters = null;

                        property.Getter = getter;
                        cls.Members.Add(getter);
                    }
                    if (existing_setter != null) {
                        property.Setter = (Method)existing_setter.convert();
                    } else if (def_declaration.modifiers.Setter && existing_setter == null) {
                        // Setter is assumed but not implemented; generating it here.
                        Method setter = new Method();
                        setter.Body = new Block();

                        // Making '<variable> = value;'
                        AssignmentStatement assign = new AssignmentStatement();
                        assign.Operator = NodeType.Nop;
                        assign.Target = new MemberBinding(new This(),variable);
                        assign.Source = Identifier.For("value");
                        setter.Body.Statements = new StatementList();
                        setter.Body.Statements.Add(assign);

                        setter.DeclaringType = cls;
                        setter.Flags = MethodFlags.Public | MethodFlags.SpecialName;
                        setter.CallingConvention = CallingConventionFlags.HasThis;

                        setter.ImplementedInterfaceMethods = new MethodList();
                        Member def_setter = ((Interface)definition.convert()).GetMembersNamed(Identifier.For("set_"+name))[0];
                        setter.ImplementedInterfaceMethods.Add((Method)def_setter);

                        setter.Name = Identifier.For("set_"+name);
                        setter.ReturnType = SystemTypes.Void; // type;
                        setter.Parameters = new ParameterList();

                        Parameter par = new Parameter();
                     // par.Attributes;
                        par.DefaultValue = null;
                        par.Flags = ParameterFlags.In;
                     // par.MarshalType;
                        par.Name = Identifier.For("value");
                     // par.NodeType;
                        par.ParameterListIndex = 0;
                        par.SourceContext = base.sourceContext;
                        par.Type = type;
                        setter.Parameters.Add(par);

                        property.Setter = setter;
                        cls.Members.Add(setter);
                    }
                    cls.Members.Add(property);
                } else if (def_declaration is ROUTINE_DECL) {
                    // If implementation actually implements the procedure from definition
                    // then just skip it.
                    DECLARATION r = this.locals.find(def_declaration.name);

                    if (r != null && r is ROUTINE_DECL) {
                        if ( !TYPE.sameProc(r as ROUTINE_DECL,def_declaration as ROUTINE_DECL) )
                            // Warning
                            ERROR.DifferentSignatures(r.name.Name,r.sourceContext);
                        else  
                            // Implementation contains its own (default) version of the routine; 
                            // do not need to generate a dummy.
                            continue;
                    }
                    
                    

                    // Implementation doesn't contain the actual code for routine;
                    // generate the dummy for this routine
                    // bad check: if ( def_declaration.node == null ) /* an error before */ continue; //RM
                    ROUTINE_DECL rr = def_declaration as ROUTINE_DECL;
                 // Method routine = (Method)def_declaration.node.Clone();
                    Method routine = new Method();
                    routine.Name = rr.name;
                    routine.CallingConvention = CallingConventionFlags.HasThis;
                    routine.ReturnType = (TypeNode)rr.return_type.convert();
                    routine.DeclaringType = cls;
                    routine.Body = new Block(new StatementList());
                    //Add return of default value of type to ensure definitive assignment
                    if (routine.ReturnType != SystemTypes.Void) {
                        Construct construct = new Construct();
                        construct.Constructor = new MemberBinding(null, routine.ReturnType);
                        construct.Constructor.Type = SystemTypes.Type;
                        construct.SourceContext = this.sourceContext;
                        construct.Type = routine.ReturnType;

                        Return ret = new Return();
                        ret.Expression = construct;
                        ret.SourceContext = this.sourceContext;
                        routine.Body.Statements.Add(ret);
                    }

                    routine.Flags = MethodFlags.Public | MethodFlags.Virtual;
                    routine.Parameters = new ParameterList();
                    for (int j = 0, m = rr.paramCount; j < m; j++) {
                        Parameter p = (Parameter)rr.parameters[j].convert();
                        if (p == null)
                            return;
                        Parameter pc = (Parameter)p.Clone();
                        pc.DeclaringMethod = routine;
                        routine.Parameters.Add(pc);                        
                    }
                    routine.ImplementedInterfaceMethods = new MethodList();
                    routine.ImplementedInterfaceMethods.Add((Method)def_declaration.node);
                    
                    // If base calss containes an implementation set an override flag                    
                    Method ovrm = cls.BaseClass.GetMethod(routine.Name, routine.GetParameterTypes());
                    if (ovrm != null) {
                        routine.OverridesBaseClassMember = true;
                        routine.OverriddenMethod = ovrm;
                        //routine.Flags = ovrm.Flags; // In case of Finalize it'll be protected then.
                        // We Forbid to use Finalize in definitions
                    };

                    cls.Members.Add(routine);
                } else if (def_declaration is TYPE_DECL) {
                    // If implementation actually implements the type from definition
                    // then just skip it.
                    if (this.locals.find(def_declaration.name) != null)
                        continue;

                    TypeNode t = (TypeNode)def_declaration.convert();
                    if ( t != null )
                        t.Flags |= TypeFlags.NestedPublic;
                    cls.Members.Add(t);
                } else  // ANY OTHER DEFINITION MEMBERS????
                {
                }
            }
        }

        //-----------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("IMPLEMENTATION {0}, line={1}",base.name!=null?base.name.ToString():"<NONAME>", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("DEFAULT IMPLEMENTED DEFINITION: ");
            if ( implemented_definition == null )
                System.Console.WriteLine("MISSED");
            else {
                implemented_definition.report_short();
                System.Console.WriteLine();
            }
            base.report(shift+reportShift);
        }

        public override void report_short() {
            System.Console.Write("IMPLEMENTATION {0}:{1}",unique,name.Name);
        }
#endif
    }

    // =========================================================================
    // 1.2 ROUTINES
    // =========================================================================

    public abstract class ROUTINE_DECL : DECLARATION {
        // Constructor
        public ROUTINE_DECL(ASTNodeType astNodeType, Identifier name)
            : base(astNodeType, name) {
            inBody = false;
            inParams = true;
            parameters = new VARIABLE_DECL_LIST();
            locals = new DECLARATION_LIST();
            body = new BLOCK();
            body.enclosing = this;
			prototypeName = "";
        }

        //-------------------------------------------------------------------

        public bool inParams;
        public bool inBody;

        public int  paramCount;

        public VARIABLE_DECL_LIST parameters;
        public DECLARATION_LIST   locals;
        public BLOCK              body;
        public TYPE               return_type;

        public DECLARATION        prototype;   // for IMPLEMENTS clause

        public override string ToString() {
            string par = "";
            for (int i = 0; i < parameters.Length; i++)
                par += " par" + i.ToString() + " = \"" + parameters[i].type.Name + "\"";
            return "<" + base.ASTNodeType.ToString() + " name = \"" + Name + "\""+par+"/>";
        }

		public string			  prototypeName; // Remeber the protoype name before it is resolved!

		// used for XML generation in derived classes
		public XmlNode xmlRoutineNode;

        //-------------------------------------------------------------------

        public override NODE find(Identifier name) {
            NODE result = locals.find(name);
            if (result == null)
                result = parameters.find(name);
            if (result == null) result = enclosing.find(name);
            return result;
        }

        public override NODE findLocal(Identifier name)
        {
            NODE result = locals.find(name);
            if (result == null) result = parameters.find(name);         
            return result;
        }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            for (int i = 0; i < locals.Length; i++)
            {
                if (locals[i] == null) continue;
                scope = locals[i].findScopeAtContext(line, col, documentName);
                if (scope != null) break;
            }
            if(scope == null)
            for (int i = 0; i < parameters.Length; i++)
            {
                if (parameters[i] == null) continue;
                scope = parameters[i].findScopeAtContext(line, col, documentName);
                if (scope != null) break;
            }
            if (scope == null && body != null)
                scope = body.findScopeAtContext(line, col, documentName);

            return scope;
        }
        //--------------------------------------------------------------------

        public override NODE resolve() {
            for ( int i=0, n=parameters.Length; i<n; i++ )
                parameters[i] = (PARAMETER_DECL)parameters[i].resolve();

            if ( return_type != null )
                return_type = (TYPE)return_type.resolve();
            return this;
        }

        public abstract override bool validate ( );
        public abstract override TYPE type { get; set; }
        public abstract override Node convert ( );

        //--------------------------------------------------------------------------------

        // addImplementedProcedure
        // -----------------------
        // PROCEDURE p IMPLEMENTS d1.p; ...
        //                        ====
        //
        public void addImplementedProcedure(IDENT_LIST qualName) {
         // DESIGNATOR entity = SELECTOR.processQualName(null,qualName);
         // DESIGNATOR entity = SELECTOR.processImportName(qualName);
            DESIGNATOR entity = SELECTOR.processDefinitionName(qualName);

            if (this.Name != qualName[qualName.Length - 1].Name)
            {
                if (!this.ErrorReported)
                {
                    ERROR.NotImplemented("giving a different name (" + this.Name + " instead of " + qualName[qualName.Length - 1].Name + ") to an implemented procedure");
                    this.ErrorReported = true;
                }
                return;
            }

            if ( entity == null ) return;
            // An error in qualified-id has been detected.
            // We can do nothing...
            DECLARATION decl = (DECLARATION)entity.resolve();

            // We expect _procedure_ as the name's "sort".
            if ( decl is PROCEDURE_DECL ) // We have found the procedure.
            {
                // - Check if 'procedure' is really from the proper definition
                // - Check if the procedure hasn't been mentioned in this implementation list.

                // Add implemented procedure to the implementation list.
                this.prototype = (ROUTINE_DECL)decl;
                // Other checks...
                return;
            } else if (decl is FIELD_DECL) {
                this.prototype = (FIELD_DECL)decl;
                return;
            } else if (decl is UNKNOWN_DECL) // can happen if decl denotes an external proc...
            {
                this.prototype = (UNKNOWN_DECL)decl;
				this.prototypeName = NODE.generateFullName(decl);
                return;
            }
            else if (decl is EXTERNAL_DECL)
            {
                this.prototype = (EXTERNAL_DECL)decl;
                return;
            }

            // All other cases are illegal.

            // Name 'ident' does not denote a procedure as expected
            ERROR.WrongProcedureName(qualName.ToString());
        }

        //---------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            NODE.doShift(shift);
            System.Console.Write("PARAMETERS:");
            if ( parameters == null || parameters.Length == 0 )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine(" {0}",parameters.Length);
                for ( int i=0, n=parameters.Length; i<n; i++ )
                    parameters[i].report(shift+reportShift);
            }

            NODE.doShift(shift);
            System.Console.Write("RETURN TYPE:");
            if ( return_type == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                return_type.report(shift+reportShift);
            }

            NODE.doShift(shift);
            System.Console.Write("IMPLEMENTS:");
            DECLARATION prototype = (this is ACTIVITY_DECL) ? ((ACTIVITY_DECL)this).prototype : this.prototype;
            if ( prototype == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                NODE.doShift(shift+NODE.reportShift);
                prototype.report_short();
                System.Console.WriteLine();
            }

            NODE.doShift(shift);
            System.Console.Write("LOCALS:");
            if ( locals == null || locals.Length == 0 )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine(" {0}",locals.Length);
                for ( int i=0, n=locals.Length; i<n; i++ )
                    locals[i].report(shift+2*reportShift);
            }

            NODE.doShift(shift);
            System.Console.Write("BODY:");
            if ( body == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                body.report(shift+reportShift);
            }
        }
#endif
    }

    // PROCEDURE_DECL
    // ==============
    //
    public sealed class PROCEDURE_DECL : ROUTINE_DECL {
        // Constructor
        public PROCEDURE_DECL ( Identifier name ) : base(ASTNodeType.PROCEDURE_DECL, name) { }

        //------------------------------------------------------------------------------

     // FROM THE BASE:
     // public VARIABLE_DECL_LIST parameters;  -- procedure parameters
     // public DECLARATION_LIST   locals;      -- procedure locals
     // public BLOCK              body;        -- procedure body
     // public TYPE               return_type; -- procedure return type
     // public DECLARATION        prototype;   -- for IMPLEMENTS clause

        //-------------------------------------------------------------------------------
        public delegate Node   ConvertStandardCall   ( CALL call );
        public delegate object CalculateStandardCall ( CALL call );
        public delegate TYPE   EvaluateType          ( CALL call );

        public bool IsStatic(){
            return this.getEnclosingUnit() is MODULE_DECL;
        }

        public ConvertStandardCall   convertStandardCall;   // method to convert the call to standard procedure
        public CalculateStandardCall calculateStandardCall; // method to calculate the call to standard function
                                                            // with constant arguments
        public EvaluateType          evaluateType;          // method for calculating actual type for the call
                                                            // to generic standard procedure

        //--------------------------------------------------------------------------------

        public static PROCEDURE_DECL create(Identifier ident, MODIFIERS modifiers) {
            PROCEDURE_DECL procedure = new PROCEDURE_DECL(ident);
            bool doNotAdd = false;
            NODE context = CONTEXT.current;
            NODE node = context.find(ident);

            if (node != null) {
                if (node is UNKNOWN_DECL) {
                    if (context is UNIT_DECL) {   // If it is local then it was late declaration
                        node = ((UNIT_DECL)context).locals.find(ident);
                        if (node != null) {
                            ((UNIT_DECL)context).locals.replace((DECLARATION)node, procedure);                            
                            ((UNKNOWN_DECL)node).RealDeclaration = procedure;
                            doNotAdd = true;
                        }
                    }
                } else if (context is IMPLEMENTATION_DECL ||
                          context is OBJECT_DECL         ||
                          context is MODULE_DECL) {
                    if (node.enclosing is DEFINITION_DECL) {
                        if (context is IMPLEMENTATION_DECL) {
                            // This is quite correct situation: procedure (with body)
                            // implementing the procedure prototype from the definition.
                            if ( node is PROCEDURE_DECL )
                                procedure.prototype = (PROCEDURE_DECL)node;
                            else if ( node is FIELD_DECL )
                                procedure.prototype = (FIELD_DECL)node;
                            else
                                ERROR.IllegalHiding(ident.Name);
                        } else // MODULE or OBJECT
                        {
                            // The fact that there is the procedure of the same name
                            // as in DEFINITION means _nothing_: we should wait for
                            // implements clause to make a decision that this procedure
                            // really implements the one from the definition...
                        }
                    } else {
                        // This may be the following situation: we have already got
                        // an accessor and this is the _second_ accessor for the same
                        // definition variable.
                        if ( node is PROCEDURE_DECL &&
                             ( (node.modifiers.Getter && modifiers.Setter) ||
                               (node.modifiers.Setter && modifiers.Getter)    ) )

                            procedure.prototype = ((PROCEDURE_DECL)node).prototype;
                        else
                            ERROR.DuplicateDeclaration(ident.Name);
                    }

                    // Other checks will be done later (see check() function below).
                } else // Error: duplicate declaration: name 'ident' is already used
                {
                    ERROR.DuplicateDeclaration(ident.Name);
                    procedure.name = ERROR.errUnitName; // return null;
                }
            }

            procedure.enclosing = CONTEXT.current;
         // procedure.exceptions -- initialized
         // procedure.implementations  -- initialized
         // procedure.locals -- initialized
         // procedure.modifiers -- initialized
            if (!modifiers.Private && !modifiers.Public) {
                // Choose the default visibility
                if ( CONTEXT.current_unit is MODULE_DECL || CONTEXT.current_unit is OBJECT_DECL )
                    modifiers.Private = true;
                else
                    modifiers.Public = true;
            }
            procedure.modifiers.add(modifiers);
         // procedure.name -- already given
         // procedure.parameters -- initialized
            procedure.return_type = null;
         // procedure.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor
         // procedure.statements -- initialized

            if (!doNotAdd) {
                // Add new procedure to the tree.
                if (context is ROUTINE_DECL)
                    ((ROUTINE_DECL)context).locals.Add(procedure);
                else
                    ((UNIT_DECL)context).locals.Add(procedure);
            }

            // Add new procedure to the current context.
            CONTEXT.enter(procedure);

            return procedure;
        }

        // check
        // -----
        // This function is called after the complete procedure heading is parsed.
        // The function just checks the correctness of the explicit or implicit
        // IMPLEMENTS clause for this procedure.
        //
        // IMPORTANT CHANGE: we will use this procedure not during parsing,
        //                   but on the Second Pass, in order to avoid the case when
        //                   prototype is UNKNOWN_DECL.
        //                   Now the function is called from validate().
        //
        private bool check() {
            if (this.ErrorReported)
                goto Finish;

            if (prototype == null) {
                if (modifiers.Getter || modifiers.Setter) {
                    ERROR.NoAccessorPrototype(this.name.Name,this.sourceContext);
                    this.ErrorReported = true;
                }
                goto Finish;
            }

            // prototype != null
            prototype = (DECLARATION)prototype.resolve();
            if (prototype is UNKNOWN_DECL) {
                
                //NODE proto_enc = prototype.enclosing;                
                //if ( proto_enc.name == null )
                //{
                //    if ( proto_enc is UNKNOWN_DECL )
                //        if ( ((UNKNOWN_DECL)proto_enc).real_declaration != null )
                //            n = ((UNKNOWN_DECL)proto_enc).real_declaration.name.Name;
                //}
                //else
                //    n = proto_enc.name.Name;
                if (!prototype.ErrorReported)
                {
                    if (prototype.enclosing is UNKNOWN_DECL)
                    {
                        ERROR.UndeclaredDefinition(this.sourceContext, NODE.generateFullName(prototype.enclosing));
                } else
                    {

                        ERROR.NoProcInDefinition(prototype.name.Name, NODE.generateFullName(prototype.enclosing), this.sourceContext);
                    }
                    prototype.ErrorReported = true;
                }
                return false;
            }
            if (prototype is EXTERNAL_DECL) /* Don't check */
                return true;

            string proc_def = prototype.enclosing.Name + "." + prototype.Name;

            // Check if the procedure implementation is PUBLIC.
            if (!this.modifiers.Public) {
                ERROR.ImplementationIsNotPublic(this.name.Name, proc_def, this.sourceContext);
                this.ErrorReported = true;
            }

            if (prototype is VARIABLE_DECL) {
                if (!modifiers.Getter && !modifiers.Setter) {
                    ERROR.NoAccessorModifier(prototype.name.Name,this.sourceContext);
                    this.ErrorReported = true;
                }
                if (modifiers.Getter && !prototype.modifiers.Getter) {
                    ERROR.IllegalAccessorSpec("get",prototype.name.Name,this.sourceContext);
                    this.ErrorReported = true;
                } else if (modifiers.Setter && !prototype.modifiers.Setter) {
                    ERROR.IllegalAccessorSpec("set",prototype.name.Name,this.sourceContext);
                    this.ErrorReported = true;
                }
                if (modifiers.Getter && !TYPE.sameType(this.return_type, prototype.type)) {
                    ERROR.IllegalProcForVar(prototype.name.Name,this.sourceContext);
                    this.ErrorReported = true;
                }
                if ( ( modifiers.Setter && this.paramCount != 1 ) ||
                     (modifiers.Getter && this.paramCount != 0)) {
                    ERROR.IllegalAccessorSignature(prototype.name.Name,this.sourceContext);
                    this.ErrorReported = true;
                }
                if (modifiers.Setter && !(return_type is VOID_TYPE)) {
                    ERROR.IllegalAccessorSignature(prototype.name.Name,this.sourceContext);
                    this.ErrorReported = true;
                }
                if (modifiers.Setter && this.paramCount > 0 && !TYPE.sameType(this.parameters[0].type, prototype.type)) {
                    ERROR.IllegalAccessorSignature(prototype.name.Name,this.sourceContext);
                    this.ErrorReported = true;
                }
                goto Finish;
            }

            // Check if procedure implements the right definition's procedure.
            // See the example below for the illustration:
            //
            // definition D1; procedure P; end D1.
            // definition D2; procedure P; end D2.
            //
            // object O implements D1;
            //     procedure {public } P implements D2.P; begin ... end P;
            // end O.                               ==

            UNIT_DECL_LIST implemented_defs = null;
            UNIT_DECL      context = CONTEXT.current_unit;
            string         kind;
            if (context is OBJECT_DECL) { kind = "object"; implemented_defs = ((OBJECT_DECL)context).definitions; } else if (context is MODULE_DECL) { kind = "module"; implemented_defs = ((MODULE_DECL)context).definitions; } else if (context is IMPLEMENTATION_DECL) {
                DEFINITION_DECL implemented_def = ((IMPLEMENTATION_DECL)context).implemented_definition as DEFINITION_DECL;
                DEFINITION_DECL prototype_def = prototype.enclosing as DEFINITION_DECL;
                if ((implemented_def != prototype_def && !implemented_def.refines(prototype_def))) {
                    ERROR.IllegalImplementingProc2(UNIT.generateFullName(prototype), "implementation", UNIT.generateFullName(this.enclosing), this.sourceContext);
                    this.ErrorReported = true;                    
                }
                goto Finish;
            } else
                goto Finish;

            if (implemented_defs == null) {
                // Definition procedure 'D2.P' cannot be implemented by object/module 'O'
                ERROR.IllegalImplementingProc2(proc_def,kind,this.enclosing.name.Name,this.sourceContext);
                this.ErrorReported = true;
                goto Finish;
            }
            // Check if we have necessary definition
            UNIT_DECL result = null;
            
            DEFINITION_DECL prototypeDef = (prototype.enclosing is IMPLEMENTATION_DECL) ? 
                ((IMPLEMENTATION_DECL)prototype.enclosing).implemented_definition as DEFINITION_DECL 
                : prototype.enclosing as DEFINITION_DECL;
            for (int i = 0, n = implemented_defs.Length; i < n; i++) {
                UNIT_DECL defdecl = implemented_defs[i].resolve() as UNIT_DECL;
                DEFINITION_DECL defdecldef = (defdecl is IMPLEMENTATION_DECL) ? ((IMPLEMENTATION_DECL)defdecl).implemented_definition as DEFINITION_DECL : defdecl as DEFINITION_DECL;                
                if (defdecl == null || defdecldef == null)
                    continue;
                if (defdecldef == prototypeDef || defdecldef.refines(prototypeDef)) { result = defdecldef; break; }
            }
            if (result == null) {
                ERROR.IllegalImplementingProc4(this.sourceContext, proc_def);
                this.ErrorReported = true;
                goto Finish;
            }
            

          Finish:
            return !this.ErrorReported;
        }

        //--------------------------------------------------------------------------------

        public override NODE resolve() {
            if (modifiers.Shared)
                getEnclosingUnit().modifiers.Shared = true;
            return base.resolve();
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            bool err = !check();  // validating: first stage

            // Validate definition if this is getter or setter
            if (this.prototype != null && !(prototype is EXTERNAL_DECL)) {
                prototype.resolve();
                UNIT_DECL definition = (UNIT_DECL)prototype.enclosing;
                UNIT_DECL_LIST definitions = null;
                if (this.enclosing is OBJECT_DECL)
                    definitions = ((OBJECT_DECL)enclosing).definitions;
                else if (this.enclosing is MODULE_DECL)
                    definitions = ((MODULE_DECL)enclosing).definitions;
                else if (this.enclosing is IMPLEMENTATION_DECL)
                {
                    definitions = new UNIT_DECL_LIST(1);
                    definitions.Add(((IMPLEMENTATION_DECL)enclosing).implemented_definition);
                }
                if (definitions != null && !IMPLEMENTS.implements(definitions, definition)) {
                    // Procedure "P" cannot implement procedure from 'D' 
                    // (because its unit doesn't implement this definition)
                    if (!ErrorReported)
                    {
                        ERROR.IllegalImplementingProc3(this.Name, definition.Name,
                                                       this.sourceContext);
                        this.ErrorReported = true;
                    }
                    err = true;
                }
            }

            //Temprorary hack. TODO: Advance this test for System.Object 
            if ((name.Name == "Finalize") && modifiers.Public) {
                ERROR.SupposedToBePrivate("Finalize", sourceContext);
                ErrorReported = true;
            }

            // Validate parameters
            for ( int i=0, n=parameters.Length; i<n; i++ )
                if (!parameters[i].validate())
                    err = true;

            if (return_type == null)
                err = true;
            else if (!return_type.validate())
                err = true;

            if (modifiers.Shared && !getEnclosingUnit().modifiers.Protected) {
                ERROR.IllegalUseOfModifier("shared", "a procedure in a non protected object. Add protected modifier to the object", sourceContext);                
            }

            if (modifiers.Protected) {
                ERROR.IllegalUseOfModifier("protected", "a procedure. Add protected modifier to the object only. Use 'shared' for read only procedures", sourceContext);
            }

            if (prototype is PROCEDURE_DECL) {
                // Check the compatibility between prototype and implementation.
                if ((!ErrorReported) && (!err) && !TYPE.sameProc((PROCEDURE_DECL)prototype, this)) {
                    string proc_def = prototype.enclosing.Name + "." + prototype.Name;
                    ERROR.IllegalImplementingProc(this.name.Name, proc_def, this.sourceContext);
                    err = this.ErrorReported = true;
                }
            }

            if (modifiers.Public && getEnclosingUnit().modifiers.Actor)
            {
                if (!ErrorReported)
                {
                    ERROR.PublicMethodInActor(sourceContext);
                    ErrorReported = true;
                }
            }

            return !err;
        }

        //------------------------------------------------------------------------------

        public override TYPE type  // evaluates procedure type: just returns its type
        {
            get { return return_type; }
            set { return_type = value; }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
         // resolve();
            if (node != null)
                return node;
            if (this.ErrorReported)
                return null;
            if (!validate())
                return null;

            ROUTINE_DECL saved = CONTEXT.current_routine;
            CONTEXT.current_routine = this;

            Method method = new Method();
            node = method;  // doing it immediately, otherwise infinite recursion may happen

            method.DeclaringType = enclosing.convertAndGetType() as TypeNode;

            if (method.DeclaringType == null) return method;

            if ( enclosing is MODULE_DECL )
            {
                #region ForModule

             // method.Attributes;
             // method.Body.UniqueKey
             // method.CallingConvention;
                
             // method.Ensures;
             // method.ExceptionHandlers;
                if (modifiers.Private)
                    method.Flags = MethodFlags.Private;
                else if (modifiers.Public)
                    method.Flags = MethodFlags.Public;
                else /* by default */
                    method.Flags = MethodFlags.Private;
                method.Flags |= MethodFlags.Static;
             // method.HasCompilerGeneratedSignature;
             // method.HidesBaseClassMember;
                if (prototype != null) {
                    method.ImplementedInterfaceMethods = new MethodList();
                    method.ImplementedInterfaceMethods.Add((Method)prototype.node);
                }
             // method.ImplementedTypes;
             // method.ImplFlags;
                method.InitLocals = true; 
                method.Name = Identifier.For(base.name.Name);
                method.Name.SourceContext = base.name.SourceContext;
             // method.NodeType;
             // method.OverridesBaseClassMember;
             // method.PInvokeFlags;
             // method.PInvokeImportName;
             // method.PInvokeModule;
             // method.Requires;
             // method.ReturnAttributes;
                if (return_type != null) {
                    if (CONTEXT.useComputeMath && ComputeType.FromType(return_type).HasValue) {
                        method.ReturnType = STANDARD.Data;
                    } else {
                        method.ReturnType = (TypeNode)return_type.convert();
                    }
                }
             // method.Scope;
                method.SourceContext = base.sourceContext;
             // method.ThisParameter
             // method.Template;
             // method.TemplateArguments;
             // method.TemplateParameters;
             // method.UniqueKey;

                method.Body = new Block();
                method.Body.Checked = false;  // ???
                method.Body.HasLocals = locals.Length!=0;
             // method.Body.NodeType;
                if ( body.statements.Length > 0 ) // can be 0 because of pasre errors
                    method.Body.SourceContext = body.statements[0].sourceContext;

                method.Parameters = new ParameterList();
                method.Body.Statements = new StatementList();

                for (int i = 0, n = parameters.Length; i < n; i++) {
                    Node par = parameters[i].convert();
                    if (par == null)
                        continue;
                //  ((Parameter)par).ParameterListIndex = i;
                    method.Parameters.Add((Parameter)par);
                }
                for (int i = 0, n = locals.Length; i < n; i++) {
                    Node local = locals[i].convert();
                    if(!(local is Statement)) continue;
                    method.Body.Statements.Add((Statement)local);

                    if (locals[i] is VARIABLE_DECL) {
                        Block array_initializers = ((VARIABLE_DECL)locals[i]).createElementInitializer();
                        if ( array_initializers != null )
                            method.Body.Statements.Add(array_initializers);
                    }
                }                

                // node = method; -- already done, see above

                

                #endregion
            } else if (enclosing is DEFINITION_DECL) {
                #region ForDefinition
                

                if (modifiers.Private)
                    method.Flags = MethodFlags.Private;
                else if (modifiers.Public)
                    method.Flags = MethodFlags.Public;
                else /* by default */
                    method.Flags = MethodFlags.Public;
                method.Flags |= MethodFlags.Abstract | MethodFlags.Virtual;

                method.Name = Identifier.For(base.name.Name);
                method.Parameters = new ParameterList();
                for ( int i=0, n=parameters.Length; i<n; i++ )
                    method.Parameters.Add((Parameter)(parameters[i].convert()));
                method.ReturnType = (TypeNode)(return_type.convert());
                method.SourceContext = base.sourceContext;
                method.CallingConvention |= CallingConventionFlags.HasThis;
                // node = method; -- already done, see above

                // No body in definitions. Return here
                CONTEXT.current_routine = saved;
                return node;

                #endregion
            } else if (enclosing is OBJECT_DECL || enclosing is IMPLEMENTATION_DECL) {
                // method.Attributes;
                // method.Body.UniqueKey
                method.CallingConvention = CallingConventionFlags.HasThis;
                // method.Ensures;
                // method.ExceptionHandlers;
                if (modifiers.Private)
                    method.Flags = MethodFlags.Private;
                else if (modifiers.Public)
                    method.Flags = MethodFlags.Public;
                else /* by default */
                    method.Flags = MethodFlags.Private;
                if (enclosing is IMPLEMENTATION_DECL)
                    method.Flags |= MethodFlags.Virtual;
                // method.Flags |= MethodFlags.NewSlot;
                // method.HasCompilerGeneratedSignature;
                // method.HidesBaseClassMember;
                if ((Name.CompareTo("Finalize") == 0) && (parameters.Length == 0)) // Special case
                {
                    method.OverriddenMethod = (Method)SystemTypes.Object.GetMembersNamed(new Identifier("Finalize"))[0];
                    method.OverridesBaseClassMember = true;
                    method.Flags = MethodFlags.Family; // Change visibility according to the base class.
                    method.Flags |= MethodFlags.HideBySig | MethodFlags.Virtual;
                } else if (prototype != null) {
                    prototype = (DECLARATION)prototype.resolve();
                    if (prototype is EXTERNAL_DECL) // external method overriding
                    {
                        Node m = ((EXTERNAL_DECL)prototype).entity;  // do not convert()!- it returns Identifier
                        if (m is Method) {
                            // .method family hidebysig virtual instance void 
                            if (((Method)m).IsAbstract) {
                                // method.Flags |= MethodFlags.Virtual;
                                method.ImplementedInterfaceMethods = new MethodList();
                                method.ImplementedInterfaceMethods.Add((Method)m);
                            } else {
                                method.OverriddenMethod = (Method)m;
                                method.OverridesBaseClassMember = true;
                                if (!modifiers.Public)
                                {
                                    method.Flags = ((Method)m).Flags;
                                }
                                else
                                {
                                    if ((((Method)m).Flags & MethodFlags.Public) != MethodFlags.Public)
                                        ERROR.NotImplemented(sourceContext, "change of scope to public for extended .NET types");
                                }
                                method.Flags |= MethodFlags.HideBySig | MethodFlags.Virtual;
                            }
                        } else
                            ERROR.WrongImportName(prototype.name.Name);

                        goto Weiter;
                    }
                    else if (prototype is UNKNOWN_DECL) {
                        ERROR.WrongImportName(prototype.name.Name); //NODE.generateFullName(prototype));
                        goto Weiter;
                    }
                    // else
                    //     -- prototype is a valid prototype from definition

                    method.ImplementedInterfaceMethods = new MethodList();
                    if (prototype is ROUTINE_DECL) {
                        method.ImplementedInterfaceMethods.Add((Method)prototype.convert());
                    } else // procedure implements getter or setter
                    {
                        Property property = (Property)prototype.node;  // don't convert()!
                        Method accessor = null;
                        if (this.modifiers.Getter) {
                            accessor = property.Getter;
                            method.Name = Identifier.For("get_" + base.name.Name);
                        } else {
                            accessor = property.Setter;
                            method.Name = Identifier.For("set_" + base.name.Name);
                        }
                        method.Flags |= MethodFlags.SpecialName | MethodFlags.HideBySig | MethodFlags.Virtual;
                        method.OverriddenMethod = accessor;
                        method.ImplementedInterfaceMethods.Add(accessor);
                    }
                }

            Weiter:
                // method.ImplementedTypes;
                // method.ImplFlags;
                method.InitLocals = true;
                if (method.Name == null) {
                    method.Name = Identifier.For(base.name.Name);
                    method.Name.SourceContext = base.name.SourceContext;
                }
                // method.NodeType;
                // method.OverridesBaseClassMember;

                method.Parameters = new ParameterList();

                for (int i = 0, n = parameters.Length; i < n; i++) {
                    Parameter par = (Parameter)(parameters[i].convert());
                    if (par != null)
                        par.DeclaringMethod = method;
                    method.Parameters.Add(par);
                }
                // method.PInvokeFlags;
                // method.PInvokeImportName;
                // method.PInvokeModule;
                // method.Requires;
                // method.ReturnAttributes;
                method.ReturnType = (TypeNode)(return_type.convert());
                // method.Scope;
                method.SourceContext = base.sourceContext;
                // method.ThisParameter ??????????????
                // method.Template;
                // method.TemplateArguments;
                // method.TemplateParameters;
                // method.UniqueKey;

                method.Body = new Block();
                method.Body.Checked = false;  // ???
                method.Body.HasLocals = true; //false;
                // method.Body.NodeType;
                if (body.statements.Length > 0) // can be 0 because of pasre errors
                    method.Body.SourceContext = body.statements[0].sourceContext;
                method.Body.Statements = new StatementList();
                for (int i = 0, n = locals.Length; i < n; i++) {
                    Node local = locals[i].convert();
                    if(local != null) // TODO: Check local type declaration's convert()
                        method.Body.Statements.Add((Statement)local);

                    if (locals[i] is VARIABLE_DECL) {
                        Block array_initializers = ((VARIABLE_DECL)locals[i]).createElementInitializer();
                        if (array_initializers != null)
                            method.Body.Statements.Add(array_initializers);
                    }
                }

                // node = method; -- already done, see above
            }
                        
            bool RWL = enclosing.modifiers.Protected && enclosing.modifiers.Shared;
            bool Shared = this.modifiers.Shared;
            if (enclosing.modifiers.Protected)
            {
                method.Body.Statements.Add(generateUnlockVariable());
                Try try_catch = new Try();
                try_catch.TryBlock = new Block();
                try_catch.TryBlock.Statements = new StatementList();

                try_catch.TryBlock.Statements.Add(AWAIT.EvictLockEnterMethod(RWL, Shared));

                try_catch.TryBlock.Statements.Add((Statement)(body.convert()));

                ///=====
                try_catch.Finally = new Finally();
                try_catch.Finally.Block = new Block();
                try_catch.Finally.Block.Statements = new StatementList();
                try_catch.Finally.Block.Statements.Add(AWAIT.EvictLockLeaveMethod(RWL, Shared));

                method.Body.Statements.Add(try_catch);
            }
            else
            {
                //Normal not protected body
                Statement st = body.convert() as Statement;
                if(st != null) method.Body.Statements.Add(st);
            }

            CONTEXT.current_routine = saved;
            return node;
        }
        

        public static LocalDeclarationsStatement generateEntryBarrier ( int barrierNo )
        {
            // Barrier _barrierNN = new Barrier();

            TypeNode btype = (TypeNode)STANDARD.barrier.type.convert();

            LocalDeclarationsStatement barrier = new LocalDeclarationsStatement();
            barrier.Constant = false;
            barrier.Declarations = new LocalDeclarationList(1);
            barrier.InitOnly = false;
         // barrier.SourceContext = 
            barrier.Type = btype;
            barrier.TypeExpression = barrier.Type;

                LocalDeclaration b = new LocalDeclaration();
             // b.Field
                b.Name = Identifier.For("_barrier"+barrierNo.ToString());
             // b.SourceContext = 

                    // Generate initializer for the local declaration (see NEW.convert)
                    Construct construct = new Construct();
                    construct.Constructor = new MemberBinding(null,btype);
                    construct.Constructor.Type = SystemTypes.Type;
                 // construct.SourceContext = this.sourceContext;
                    construct.Type = btype;
                    construct.Operands = new ExpressionList(); // no params

                b.InitialValue = construct;

            barrier.Declarations.Add(b);
            return barrier;
        }

        public static LocalDeclarationsStatement generateUnlockVariable()
        {                        
            LocalDeclarationsStatement unlock = new LocalDeclarationsStatement();
            unlock.Constant = false;
            unlock.Declarations = new LocalDeclarationList(1);
            unlock.InitOnly = false;
            unlock.Type = SystemTypes.Boolean;
            unlock.TypeExpression = unlock.Type;

            LocalDeclaration b = new LocalDeclaration();
            // b.Field
            b.Name = Identifier.For("_unlock");
            // b.SourceContext = 

            b.InitialValue = new Literal((Boolean)true, SystemTypes.Boolean);

            unlock.Declarations.Add(b);
            return unlock;
        }

        public static Statement generateLeaveBarrier ( bool locked, bool RWL, bool Shared, int barrierNo )
        {
            // Release the lock
            // barrierNN.Leave();
            // Get the lock again
            Block leave = new Block();
            leave.Statements = new StatementList();

            MethodCall call = new MethodCall();
            call.Callee = new QualifiedIdentifier(Identifier.For("_barrier"+barrierNo.ToString()),
                                                  Identifier.For("Leave"));
            call.Operands = new ExpressionList(); // empty list
            if (locked)
            {
                leave.Statements.Add(AWAIT.EvictLockLeave(RWL, Shared));

                Try try_catch = new Try();
                try_catch.TryBlock = new Block();
                try_catch.TryBlock.Statements = new StatementList();

                try_catch.TryBlock.Statements.Add(new ExpressionStatement(call));

                ///=====
                try_catch.Finally = new Finally();
                try_catch.Finally.Block = new Block();
                try_catch.Finally.Block.Statements = new StatementList();
                try_catch.Finally.Block.Statements.Add(AWAIT.EvictLockEnter(RWL, Shared));
                leave.Statements.Add(try_catch);
            }
            else
            {
                leave.Statements.Add(new ExpressionStatement(call));
            }
            return leave;
        }

        //------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            if (modifiers.Public)
                System.Console.Write("PUBLIC ");
            else
                System.Console.Write("PRIVATE ");
            System.Console.Write("PROCEDURE DECLARATION {0}, line={1}",name.ToString(), this.sourceContext.StartLine.ToString());
            report_extra();

            base.report(shift+reportShift);
        }

        public override void report_short() {
            System.Console.Write("PROCEDURE {0}:{1}",unique,name.Name);
        }
#endif
        public override string ToString() {
            string signature = Name+"(";
            if(parameters != null)
                for (int i = 0, n = parameters.Length; i < n; i++) {
                if (parameters[i].type != null)
                    signature += NODE.generateFullName(parameters[i].type);
                    
                    if (i < n - 1)
                        signature += ", ";
            }
            signature += ")";
            return signature;
        }
    }

    // OPERATOR_DECL
    // =============
    //
    public sealed class OPERATOR_DECL : ROUTINE_DECL {
        // Constructor
        public bool external = false;
        public OPERATOR_DECL ( Identifier name ) : base(ASTNodeType.OPERATOR_DECL, name) { }
        public OPERATOR_DECL ( string code     ) : base(ASTNodeType.OPERATOR_DECL, null) { this.code = code; name = toName(code); }

        //------------------------------------------------------------------------------

        // FROM THE BASE:
     // public VARIABLE_DECL_LIST parameters;  -- operator parameters (1 or 2)
     // public DECLARATION_LIST   locals;      -- operator locals
     // public BLOCK              body;        -- operator body
     // public TYPE               return_type; -- operator return type
     // public ROUTINE_DECL       prototype;   -- for IMPLEMENTS clause

        //-------------------------------------------------------------------------------

     // public int    priority;
        public string code;

        // The chain of overloaded operator for the same operator sign.
        public OPERATOR_DECL previous;  

/*******
        private static Identifier toName ( string code )
        {
            if ( code.Length < 1 )
            {
                ERROR.NoOperator();
                return ERROR.errUnitName;
            }
            if ( code.Length > 3 )
            {
                ERROR.OperatorTooLong(code);
                return ERROR.errUnitName;
            }

            string name = "_";

            string legals   = @"~@#$%^&*+-=/\<>:";
            string letters  =  "ABCEFGHJKLNPQSTU";

            string prohibited = "()[]{}.,;\"'";
            bool   err = false;

            for ( int i=0, n=code.Length; i<n; i++ )
            {
                if ( prohibited.IndexOf(code[i],0,prohibited.Length) >= 0 )
                {
                    string s = ""; s += code[i];
                    ERROR.IllegalPartOfOperator(s);
                    err = true;
                    continue;
                }
                int pos = legals.IndexOf(code[i],0,legals.Length);
                if ( pos >=0 )
                    name += letters[pos];
            }
            if ( err ) return ERROR.errUnitName;

            if ( name.Length == 1 ) // no signs; only letters are allowed
            {
                if      ( code == "DIV" ) name += "DIV";
                else if ( code == "MOD" ) name += "MOD";
                else if ( code == "OR"  ) name += "OR";
                else if ( code == "IN"  ) name += "IN";
                else
                {
                    ERROR.IllegalOperator(code);
                    return ERROR.errUnitName;
                }
            }
            return Identifier.For(name);
        }
******/
        public static Identifier toName(string code) {
            bool err = false; 

            if ( code.Length < 1 ) { ERROR.NoOperator(); err = true; }
            if ( code.Length > 3 ) { ERROR.OperatorTooLong(code); err = true; }

            string name = "op_";

            switch (code) {
                case "+":
                name += "Addition";
                break;
                case "-":
                name += "Subtraction";
                break;
                case "*":
                name += "Multiply";
                break;
                case "/":
                name += "Division";
                break;
                case "mod":
                name += "Modulus";
                break;
                case "div":
                name += "Division";
                break;
                case "in":
                name += "In";
                break;
                case "or":
                name += "LogicalOr";
                break;
                case "&":
                name += "LogicalAnd";
                break;
                case "<":
                name += "LessThan";
                break;
                case "<=":
                name += "LessThanOrEqual";
                break;
                case ">":
                name += "GreaterThan";
                break;
                case ">=":
                name += "GreaterThanOrEqual";
                break;
                case "=":
                name += "Equality";
                break;
                case "#":
                name += "Inequality";
                break;
                //case ".<"  : name += "ElementWiseLessThan"; break;
                //case ".<=" : name += "ElementWiseLessThanOrEqual"; break;
                //case ".>"  : name += "ElementWiseGreaterThan"; break;
                //case ".>=" : name += "ElementWiseGreaterThanOrEqual"; break;
                //case ".="  : name += "ElementWiseEquality"; break;
                //case ".#"  : name += "ElementWiseInequality"; break;
                case ":=":
                name += "Assign";
                break;
                case "^":
                name += "Dereference";
                break;
                case "~":
                name += "Negation";
                break;
                case "**":
                name += "Exponent";
                break;
                case "\\":
                name += "LeftDivision";
                break;
                //case "!"   : name += "Transpose"; break;
                //case "+*"  : name += "ScalarProduction"; break;
                //case ".*"  : name += "ElementWiseMultiplication"; break;
                //case "./"  : name += "ElementWiseDivision"; break;
                //case "by"  : name += "RangeStep"; break;
                //case ".."  : name += "ArrayRange"; break;
                default:
                ERROR.IllegalOperator(code);
                err = true;
                break;
            }
            if (err)
                return ERROR.errUnitName;
            return Identifier.For(name);
        }

        //--------------------------------------------------------------------------------

        public static OPERATOR_DECL create(string code, MODIFIERS modifiers) {
            OPERATOR_DECL operatorr = new OPERATOR_DECL(code);

            NODE context = CONTEXT.current;
            NODE node = context.find(operatorr.name);

            if (node != null) {
                operatorr.previous = (OPERATOR_DECL)node;

             // // Duplicate declaration: name 'ident' is already used
             // ERROR.DuplicateDeclaration(code);
             // operatorr.name = ERROR.errUnitName; // return null;
            }

            operatorr.enclosing = CONTEXT.current;
         // operatorr.exceptions -- initialized
         // operatorr.implementations  -- initialized
         // operatorr.locals -- initialized
         // operatorr.modifiers -- initialized
            if (!modifiers.Private && !modifiers.Public) {
                // Choose the default visibility (operators can appear only in modules)
                modifiers.Private = true;
            }
            operatorr.modifiers.add(modifiers);
         // operatorr.priority = modifiers.Precedence>=0 ? modifiers.Precedence : 3;  // 3 by default
         // operatorr.name -- already given
         // operatorr.parameters -- initialized
            operatorr.return_type = null;
         // operatorr.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor
         // operatorr.statements -- initialized

            // Add new procedure to the tree.
            if ( context is ROUTINE_DECL )
                ((ROUTINE_DECL)context).locals.Add(operatorr);
            else
                ((UNIT_DECL)context).locals.Add(operatorr);

            // Add new procedure to the current context.
            CONTEXT.enter(operatorr);

            return operatorr;
        }

        //-------------------------------------------------------------------------------

     // public override NODE resolve ( )
     // {
     //     return this;
     // }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o  validate parameters
            bool err = false;

            int count = parameters.Length;
            if ( count<1 || count>2 )
            {
                ERROR.IllegalNumOfParams(this.sourceContext);
                err = true;
            }

            int possible_error = 0;
            int external = 0;
            for ( int i=0; i<count; i++ )
            {
                PARAMETER_DECL par = parameters[i] as PARAMETER_DECL;
                if ( !par.validate() ) return false;
                TYPE t = par.type;
                if (t is ARRAY_TYPE)
                {
                    if (((ARRAY_TYPE)t).isMath)
                    {
                        //NG: we can't overload operators for math arrays at all!
                        err = true;
                        ERROR.MathArrayInOverloadedOperator(this.sourceContext, t.type.ToString());
                        ErrorReported = true;
                    }
                    else
                        continue; 
                }
                if ( t is ENUM_TYPE ) continue;
                if ( t is PROC_TYPE ) continue;
                // We forbid using reference with value types
                if (par.Reference && !((i == 0) && (code == ":="))) //For assignment first must be by reference
                {
                    if (!ErrorReported) ERROR.ReferenceInOperator(par.Name, par.sourceContext);
                    ErrorReported = true;
                    return false;
                }
                else
                {
                    if (t is INTERFACE_TYPE) { 
                        // Issue warning 6.3.3 3)
                        /*3)	Specifying an object type with a specified interface (such as object { D }) as the 
                         * operators parameter is not allowed. The reason is that it must be possible to 
                         * resolve operator overloading completely at compile time (i.e. statically).
                         */
                        if(!ErrorReported) ERROR.WrongParameterInOperatorDeclaration(t.sourceContext);
                        ErrorReported = true;
                        continue; 
                    }
                    if (t is OBJECT_TYPE) continue;
                    if (t is EXTERNAL_TYPE)
                    {
                        external++;
                        continue; // We allow all parameters to be not user defined
                    }
                }
                possible_error++; 
            }

            if (external == count && ! (enclosing is EXTERNAL_TYPE))
            {
                if (!ErrorReported) ERROR.OnlyExternalTypesInOperator(sourceContext);
                ErrorReported = true;
            }

            if (( possible_error == count ) && (!ErrorReported))
            {
                ERROR.UserDefinedOperatorParam(this.sourceContext);
                ErrorReported = true;
                err = true;
            }

            bool this_is_binary = false;
            switch (this.code.Length) {
                case 1: {
                    string one_char_binary_op = "*/<>=#&";  // without + and -
                    this_is_binary = one_char_binary_op.IndexOf(code[0],0,7) > 0;
                    break;
                }
                case 2: {
                    this_is_binary = ( code=="<=" || code==">=" || code==":=" || code=="or" || code=="in" );
                    break;
                }
                case 3: {
                    this_is_binary = ( code=="div" || code=="mod" );
                    break;
                }
            }
            if (this_is_binary && count != 2) {
                ERROR.IllegalBinaryOperator(code,this.sourceContext);
                err = true;
            }

            bool this_is_unary = (code.Length==1) && (code[0]=='~' || code[0]=='^');  // without + and -
            if (this_is_unary && count != 1) {
                ERROR.IllegalUnaryOperator(code,this.sourceContext);
                err = true;
            }

            if (code == ":=") {
                // Check 1st parameter
                PARAMETER_DECL firstPar = (PARAMETER_DECL)parameters[0];
                if (!firstPar.Reference) {
                    ERROR.FirstParInAssignment(firstPar.sourceContext);
                    err = true;
                }
                // Check if both parameters are of the same type
                // TODO: Figure out why we should prohibit it
                //if ( parameters.Length == 2 && (parameters[0].type == parameters[1].type) )
                //{
                //    ERROR.SameTypeInAssignment(parameters[0].type.ToString(),this.sourceContext);
                //    err = true;
                //}
            }

            if (previous != null) {
                // Check if there is the operator with the same signature
                // is already defined before.
                OPERATOR_DECL prev = (OPERATOR_DECL)previous;
                while (prev != null) {
                    if (prev.paramCount != this.paramCount)
                        goto Continue;
                    if (!TYPE.sameType(prev.parameters[0].type, this.parameters[0].type))
                        goto Continue;
                    if (this.paramCount == 1)
                        goto Continue;
                    if (!TYPE.sameType(prev.parameters[1].type, this.parameters[1].type))
                        goto Continue;
                    // Duplicate declaration: name 'ident' is already used
                    ERROR.DuplicateDeclaration(this.sourceContext,code);
                    err = true;
                Continue:
                    prev = prev.previous;
                }
            }
            return !err;
        }

        //------------------------------------------------------------------------------

        public override TYPE type  // evaluates operator type: just returns its type
        {
            get { return return_type; }
            set { return_type = value; }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

         // resolve();
            if (!validate())
                return null;

            ROUTINE_DECL saved = CONTEXT.current_routine;
            CONTEXT.current_routine = this;

            // enclosing is MODULE_DECL

            Method method = new Method();
            node = method; // doing it immediately to prevent infinite recursion

         // method.Attributes;

            method.Body = new Block();

            method.Body.Checked = false;  // ???
            method.Body.HasLocals = locals.Length!=0;
         // method.Body.NodeType;
            if ( body.statements.Length > 0 ) // can be 0 because of pasre errors
                method.Body.SourceContext = body.statements[0].sourceContext;

            method.Parameters = new ParameterList();
            method.Body.Statements = new StatementList();

            for (int i = 0, n = parameters.Length; i < n; i++) {
                Node par = parameters[i].convert();
                if (par == null)
                    continue;
                method.Parameters.Add((Parameter)par);
            }
            for (int i = 0, n = locals.Length; i < n; i++) {
                Node local = locals[i].convert();
                if ( local is Parameter )                        // ???
                    method.Parameters.Add((Parameter)local);     // ???
                else
                    method.Body.Statements.Add((Statement)local);

                if (locals[i] is VARIABLE_DECL) {
                    Block array_initializers = ((VARIABLE_DECL)locals[i]).createElementInitializer();
                    if ( array_initializers != null )
                        method.Body.Statements.Add(array_initializers);
                }
            }
            for ( int i=0, n=body.statements.Length; i<n; i++)  // in fact, only ONE statement: block.
                method.Body.Statements.Add((Statement)(body.statements[i].convert()));
         // method.Body.UniqueKey
         // method.CallingConvention;

            method.DeclaringType = (TypeNode)enclosing.convertAndGetType();
         // method.Ensures;
         // method.ExceptionHandlers;
            if (modifiers.Private)
                method.Flags = MethodFlags.Private;
            else if (modifiers.Public)
                method.Flags = MethodFlags.Public;
            else /* by default */
                method.Flags = MethodFlags.Private;
            method.Flags |= MethodFlags.Static;
         // method.HasCompilerGeneratedSignature;
         // method.HidesBaseClassMember;
         // method.ImplementedInterfaceMethod;
         // method.ImplementedInterfaceMethods;
         // method.ImplementedTypes;
         // method.ImplFlags;
            method.InitLocals = true;
            method.Name = Identifier.For(base.name.Name);
         // method.NodeType;
         // method.OverridesBaseClassMember;

         // method.Parameters = new ParameterList();
         // for ( int i=0, n=parameters.Length; i<n; i++ )
         //     method.Parameters.Add((Parameter)(parameters[i].convert()));

         // method.PInvokeFlags;
         // method.PInvokeImportName;
         // method.PInvokeModule;
         // method.Requires;
         // method.ReturnAttributes;
            if ( return_type != null )
                method.ReturnType = (TypeNode)(return_type.convert());
         // method.Scope;
            method.SourceContext = base.sourceContext;
         // method.ThisParameter
         // method.Template;
         // method.TemplateArguments;
         // method.TemplateParameters;
         // method.UniqueKey;

            node = method;

            CONTEXT.current_routine = saved;
            return node;
        }

        //------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
         // System.Console.Write("OPERATOR DECLARATION {0}:{1} PREC={2}",name.ToString(),code,priority);
            System.Console.Write("OPERATOR DECLARATION {0}:{1}, line={2}",name.ToString(),code,this.sourceContext.StartLine.ToString());
            report_extra();

            base.report(shift+reportShift);
        }

        public override void report_short() {
            System.Console.Write("OPERATOR {0}:{1}",unique,name.Name);
        }
#endif
    }

    // ACTIVITY_DECL
    // =============
    //
    public sealed class ACTIVITY_DECL : ROUTINE_DECL {
        // Additional node for the image of the activity launher
        public Member node1;

        // Constructor
        public ACTIVITY_DECL(Identifier name)
            : base(ASTNodeType.ACTIVITY_DECL, name) {
            return_type = new VOID_TYPE();
        }

        //------------------------------------------------------------------------------

        // FROM THE BASE:
     // public VARIABLE_DECL_LIST parameters;  -- doesn't exist for activity
     // public DECLARATION_LIST   locals;      -- activity locals
     // public BLOCK              body;        -- activity body
     // public TYPE               return_type; -- activity return type - always VOID
     // public ROUTINE_DECL       prototype;   -- for IMPLEMENTS clause
        public new PROTOCOL_DECL  prototype;   // acivity can implement a PROTOCOL

        //-------------------------------------------------------------------------------

        public static ACTIVITY_DECL create(Identifier name, MODIFIERS modifiers) {
            ACTIVITY_DECL activity = new ACTIVITY_DECL(name);

            DECLARATION context = CONTEXT.current;
            DECLARATION node = (DECLARATION)context.find(name);

            if (node != null) {
                if (node is UNKNOWN_DECL) {
                    ((UNKNOWN_DECL)node).name = null;
                    ((UNKNOWN_DECL)node).RealDeclaration = activity;
                    activity.locals = ((UNKNOWN_DECL)node).locals;
                }

            //  The following doesn't make any sense because
            //  activity should have an explicit 'implements' clause
            //  which referes to a protocol declaration
            //
            //  else if ( node is PROTOCOL_DECL )
            //  {
            //      activity.prototype = (ACTIVITY_SPEC)node;
            //  }
                else
                    ERROR.DuplicateDeclaration(name.Name);
            }

            activity.enclosing = context;
         // activity.exceptions -- initialized
         // activity.locals     -- initialized
         // activity.modifiers  -- initialized
         // activity.name       -- no name
         // activity.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor
         // activity.statements -- initialized
            activity.modifiers = modifiers;

            // Add new activity to the current object.
            if ( !(CONTEXT.current is OBJECT_DECL) &&
                 !(CONTEXT.current is MODULE_DECL) 
           // && !(CONTEXT.current is DEFINITION_DECL) 
               ) {
             // ERROR.WrongContextForActivity();
                return null;
            }
            ((UNIT_DECL)(CONTEXT.current)).locals.Add(activity);
            // Add new activity to the current context.
            CONTEXT.enter(activity);

            return activity;
        }

        // addImplementedProtocol
        // ----------------------
        // ACTIVITY a IMPLEMENTS d1.p; ...
        //                       ====
        //
        public void addImplementedProtocol(IDENT_LIST qualName) {
            DESIGNATOR entity = SELECTOR.processQualName(null,qualName);
         // DESIGNATOR entity = SELECTOR.processImportName(qualName);
         // DESIGNATOR entity = SELECTOR.processDefinitionName(qualName);

            if (entity == null)
                return;
            // An error in qualified-id has been detected.
            // We can do nothing...
            DECLARATION decl = (DECLARATION)entity.resolve();

            // We expect only _protocol_ as the name's "sort".
            if (decl is PROTOCOL_DECL) {
                // Add implemented protocol to the implementation list.
                this.prototype = (PROTOCOL_DECL)decl;
                // Other checks...
                return;
            }
            // All other cases are illegal.

            // Name 'ident' does not denote a protocol as expected
            ERROR.WrongProtocolName(qualName.ToString());
        }

        //--------------------------------------------------------------------------------

     // public override NODE resolve ( )
     // {
     //     return this;
     // }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o Now we accept only "simple" types of activity parameters

            // Enclosing type must be a protected reference object
            if (!enclosing.modifiers.Protected && !ErrorReported)
            {
                ERROR.SupposedToBeProtected(sourceContext);
                ErrorReported = true;
                return false;
            }

            if (enclosing is OBJECT_DECL && !enclosing.modifiers.Reference && !ErrorReported)
            {
                ERROR.NotImplemented("activities for value obects are ");
                ErrorReported = true;
                return false;
            }

            for ( int i=0, n=parameters.Length; i<n; i++ )
            {
                TYPE t = parameters[i].type;
                if ( t is OBJECT_TYPE || t is ARRAY_TYPE    || t is INTERFACE_TYPE || 
                     t is PROC_TYPE || t is ACTIVITY_TYPE || t is EXTERNAL_TYPE) {
                    parameters[i].ErrorReported = true;
                    ERROR.NotImplemented("activity parameters of this type are");
                    ErrorReported = true;
                    return false;
                }
            }
            return true;
        }

        //------------------------------------------------------------------------------

        public override TYPE type  // evaluates activity type
        {
            get {
                if (internal_type != null)
                    return internal_type;

                ACTIVITY_TYPE activity_type = new ACTIVITY_TYPE();
                activity_type.activity = this;
                internal_type = activity_type;

                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            //  ACTIVITY a ( Parameters ) IMPLEMENTS p;  Declarations Body  END a;
            //  ------------------------------------------------------------------
            //  Activity is mapped to two function: the launcher, and the activity "body" itself.
            //
            //  public Protocol a ( Barrier barrier )  // activity launcher
            //  {
            //      Protocol activity = new p(_a); <<== new(new activityType(_a)) !!!!
            //      acticity.invoke(barrier);
            //      return activity;
            //  }
            //
            //  private void _a (Protocol protocol)
            //  {
            //      Parameters;
            //      Declarations;
            //      try {
            //          par1 = protocol.accept();
            //           ...
            //          parn = protocol.accept();
            //          Body;
            //      } 
            //      catch ( ProtocolMismatch ) { ... }
            //  }
            //
            // We put image of the launcher to the special 'node1' node.
            // The calling procedure will take both 'node' and 'node1'.

            if ( enclosing is DEFINITION_DECL )
                // This is activity _specification_, but not declaration.
                return null;

            if (node != null)
                return node;



         // resolve();
            if (!validate())
                return null;

            ROUTINE_DECL saved = CONTEXT.current_routine;
            CONTEXT.current_routine = this;

            Method launcher = new Method();
            node1 = launcher;

            Method activity = new Method();
            node = activity;

            // First, generate activity launcher:
            // ---------------------------------
            //  public Protocol a ( Barrier barrier )  // activity launcher
            //  {
            //      Protocol activity = new p(_a);
            //      acticity.invoke(barrier);
            //      return activity;
            //  }

            TypeNode actual_protocol = this.prototype!=null ? (TypeNode)this.prototype.convert()
                                                            : (TypeNode)STANDARD.protocol.type.convert();
            if (actual_protocol == null)
                return null; // Because of an error recognized above

         // launcher.Attributes;
            launcher.Body = new Block();
            launcher.Body.Checked = false;  // ???
            launcher.Body.HasLocals = true;
         // launcher.Body.NodeType;
            launcher.Body.SourceContext = this.sourceContext;
            launcher.Parameters = new ParameterList(1);

                Parameter par = new Parameter();
                par.Type = (TypeNode)STANDARD.barrier.type.convert();
                par.Name = Identifier.For("barrier");
                par.Flags = ParameterFlags.In;

            launcher.Parameters.Add(par);

            launcher.Body.Statements = new StatementList();

            // Generate local declaration for launcher.
            LocalDeclarationsStatement protocol_ref = new LocalDeclarationsStatement();
            protocol_ref.Constant = false;
            protocol_ref.Declarations = new LocalDeclarationList(1);
            protocol_ref.InitOnly = false;
            protocol_ref.SourceContext = this.sourceContext;
            protocol_ref.Type = actual_protocol;  // protocol type
            protocol_ref.TypeExpression = protocol_ref.Type;

                LocalDeclaration pref = new LocalDeclaration();
             // pref.Field
                pref.Name = Identifier.For("activity");
                pref.SourceContext = base.sourceContext;
                
                    // Generate initializer for the local declaration (see NEW.convert)
                    Construct construct = new Construct();
                    // Strange thing: CCI expects _class_ in Construct.Constructor,
                    // but not a constructor itself!..
                    construct.Constructor = new MemberBinding(null,actual_protocol);
                    construct.Constructor.Type = SystemTypes.Type;
                    construct.SourceContext = this.sourceContext;
                    construct.Type = actual_protocol;
                    construct.Operands = new ExpressionList(2);

                        // Generating new activityType(_a)
                        //
                        // See NEW.convert(), case PROC_TYPE

                        ConstructDelegate delg = new ConstructDelegate();

                        delg.DelegateType = (TypeNode)STANDARD.activityType.convert();
                        delg.MethodName = Identifier.For("_"+this.name.Name);

                        // You should pass in a MemberBinding as the target object.
                        // The Type field of the MemberBinding should be SystemTypes.Type and the bound
                        // member should be the type that defines the method that implements the delegate.
                        //       - Herman Venter.
                    //  delg.TargetObject = new MemberBinding(new This(),(TypeNode)CONTEXT.current_unit.convert());
                    //                                 //     ---------- ??
                    //  delg.TargetObject.Type = SystemTypes.Type;

                        // I construct TargetObject field in a different way than Herman
                        // recommends (see his note above). His idea doesn't work for his own code
                        // therefore I had to make this node as follows: I do not create
                        // MemberBinding node (because Looker looses the information about
                        // the target object while processing it), but create just This node
                        // instead. Additionally, I pass the class where the method for activity
                        // defined, via This's Type field. It looks strange but it works:
                        // Resolver.VisitConstructDelegate() takes the class just from this
                        // field and searches this class looking for the method with the name 
                        // taken from MethodName field.
                        // See also the similar code in NEW.convert(), the branch
                        // for PROC_TYPE/Delegates.
                        //
                        // The only problematic point here is that This() node seems not working
                        // properly for _structs_. Therefore, for now objects with activities
                        // _must_be_ treated as reference objects, i.e., objects should be declared
                        // with {ref} modifier.
            if (enclosing is MODULE_DECL) {
                            //delg.TargetObject = new This(); //????
                            delg.TargetObject = new This();//enclosing.name;
                            delg.TargetObject.Type = (TypeNode)enclosing.convert();
            } else {
                            delg.TargetObject = new This();
                            delg.TargetObject.Type = (TypeNode)CONTEXT.current_unit.convert();
                        }

                        BinaryExpression delgRes = new BinaryExpression();
                        delgRes.NodeType = NodeType.Castclass;
                        delgRes.Operand1 = delg;
                        delgRes.Operand2 = new MemberBinding(null,(TypeNode)STANDARD.activityType.convert());

                    construct.Operands.Add(delgRes);
                 // construct.Operands.Add(Identifier.For("_"+this.name.Name));
                    construct.Operands.Add(new Literal(false,SystemTypes.Boolean));

                pref.InitialValue = construct;

            protocol_ref.Declarations.Add(pref);
            launcher.Body.Statements.Add(protocol_ref);

            // Generate activity.invoke(barrier);
            MethodCall invoke = new MethodCall();

                invoke.Callee = new QualifiedIdentifier(Identifier.For("activity"),Identifier.For("invoke"),
                                                        this.sourceContext,false);
                invoke.GiveErrorIfSpecialNameMethod = false; // ??
                invoke.IsTailCall = false;
             // invoke.NodeType
                invoke.Operands = new ExpressionList(1);
                invoke.Operands.Add(Identifier.For("barrier"));
                invoke.SourceContext = this.sourceContext;
                invoke.Type = SystemTypes.Void;
                ExpressionStatement call = new ExpressionStatement(invoke,this.sourceContext);

            launcher.Body.Statements.Add(call);

            // Generate return activity;
            Return ret = new Return(Identifier.For("activity"),this.sourceContext);
            launcher.Body.Statements.Add(ret);

            // Continue generate launcher method.
         // launcher.Body.UniqueKey
            launcher.DeclaringType = (TypeNode)this.enclosing.convert();
         // launcher.Ensures;
         // launcher.ExceptionHandlers;

            // Activity launcher can be private - as all other class methods...
            // TODO: add choosing visibility depending on modifiers.
            launcher.Flags = MethodFlags.Public /* | MethodFlags.Virtual */ ;
            if ( enclosing is MODULE_DECL )
                launcher.Flags |= MethodFlags.Static;
            else
                launcher.CallingConvention = CallingConventionFlags.HasThis;

         // launcher.HasCompilerGeneratedSignature;
         // launcher.HidesBaseClassMember;
         // launcher.ImplementedInterfaceMethod;
         // launcher.ImplementedInterfaceMethods;
         // launcher.ImplementedTypes;
         // launcher.ImplFlags;
            launcher.InitLocals = true;
            launcher.Name = Identifier.For(this.name.Name);  // the same name as activity itself
         // launcher.NodeType;
         // launcher.OverridesBaseClassMember;
         // launcher.PInvokeFlags;
         // launcher.PInvokeImportName;
         // launcher.PInvokeModule;
         // launcher.Requires;
         // launcher.ReturnAttributes;
            launcher.ReturnType = (TypeNode)STANDARD.protocol.type.convert();  // standard protocol always
         // launcher.Scope;
            launcher.SourceContext = this.sourceContext;
         // launcher.ThisParameter
         // launcher.Template;
         // launcher.TemplateArguments;
         // launcher.TemplateParameters;
         // launcher.UniqueKey;

            node1 = launcher;

            // Second, generate the method for activity body:
            //
            //  private void _a (Protocol protocol)
            //  {
            //      Parameters;
            //      par1 = protocol.accept();
            //       ...
            //      parn = protocol.accept();
            //      Declarations;
            //      Body;
            //  }

         // activity.Attributes;
            activity.Body = new Block();
            activity.Body.Checked = false;  // ???
            activity.Body.HasLocals = true;
         // activity.Body.NodeType;
            activity.Body.SourceContext = this.sourceContext;
            activity.Parameters = new ParameterList(1);
            activity.Body.Statements = new StatementList();

            Block abody = new Block();
            abody.Statements = new StatementList();
            abody.HasLocals = true;
            abody.SourceContext = sourceContext;

            bool RWL = enclosing.modifiers.Protected && enclosing.modifiers.Shared;
            bool Shared = this.modifiers.Shared;

            Try try_catch = new Try();
            try_catch.TryBlock = new Block();
            try_catch.TryBlock.Statements = new StatementList();
            
            

            try_catch.TryBlock.Statements.Add(AWAIT.EvictLockEnter(RWL, Shared));

            try_catch.TryBlock.Statements.Add(abody);

            ///=====
            try_catch.Finally = new Finally();
            try_catch.Finally.Block = new Block();
            try_catch.Finally.Block.Statements = new StatementList();
            try_catch.Finally.Block.Statements.Add(AWAIT.EvictLockLeave(RWL, Shared));

            activity.Body.Statements.Add(try_catch);

                Parameter activity_par = new Parameter();
                activity_par.Type = (TypeNode)STANDARD.protocol.type.convert();
                activity_par.Name = Identifier.For("protocol");
                activity_par.Flags = ParameterFlags.In;

            activity.Parameters.Add(activity_par);
            

            // Generate local declarations and accept statements for activity parameters
            for (int i = 0, n = parameters.Length; i < n; i++) {
                VARIABLE_DECL param = parameters[i];
                if (param == null)
                    continue; // an error before...

                // T p;

                LocalDeclarationsStatement true_locals = new LocalDeclarationsStatement();
                true_locals.Constant = false;
                true_locals.Declarations = new LocalDeclarationList(1);
                true_locals.InitOnly = false;
                true_locals.SourceContext = param.sourceContext;
                true_locals.Type = (TypeNode)param.type.convert();
                true_locals.TypeExpression = true_locals.Type;

                    LocalDeclaration true_local = new LocalDeclaration();
                 // true_local.Field
                    true_local.Name = Identifier.For(param.name.Name);
                    true_local.SourceContext = param.sourceContext;
                    true_local.InitialValue = null;

                true_locals.Declarations.Add(true_local);
                abody.Statements.Add(true_locals);

                // p = (T)protocol.accept();

                AssignmentStatement assignment = new AssignmentStatement();

                assignment.NodeType = NodeType.AssignmentStatement;
                assignment.Operator = NodeType.Nop;  // this means "normal" assignment, but not += etc.
             // assignment.OperatorOverload;

                assignment.Target = Identifier.For(param.name.Name);
                assignment.SourceContext = param.sourceContext;

                    MethodCall accept = new MethodCall();
                    accept.ArgumentListIsIncomplete = false;
                    accept.Callee = new QualifiedIdentifier(Identifier.For("protocol"),Identifier.For("accept"),
                                                            param.sourceContext,false);
                    accept.Operands = new ExpressionList();  // empty
                    accept.SourceContext = param.sourceContext;

                    TypeNode targetType = (TypeNode)param.type.convert();

                    BinaryExpression rightPart = 
                        new BinaryExpression(accept,new MemberBinding(null,targetType),NodeType.Castclass);
                    rightPart.SourceContext = param.sourceContext;
                
                assignment.Source = rightPart;
                abody.Statements.Add(assignment);
            }

            // Generate "true" local declarations
            for (int i = 0, n = locals.Length; i < n; i++) {
                Node local = locals[i].convert();
                abody.Statements.Add((Statement)local);

                if (locals[i] is VARIABLE_DECL) {
                    Block array_initializers = ((VARIABLE_DECL)locals[i]).createElementInitializer();
                    if ( array_initializers != null )
                        abody.Statements.Add(array_initializers);
                }
            }
                       
            abody.Statements.Add((Statement)(body.convert()));

            // Continue generate activity method.
         // activity.Body.UniqueKey
            activity.DeclaringType = (TypeNode)this.enclosing.convert();
         // activity.Ensures;
         // activity.ExceptionHandlers;

            // Activities themselves can be made private; the "real" visibility
            // is represented as the visibility of its launcer (see above).
            activity.Flags = MethodFlags.Private /* | MethodFlags.Virtual */;
            if ( enclosing is MODULE_DECL )
                activity.Flags |= MethodFlags.Static;
            else
                activity.CallingConvention = CallingConventionFlags.HasThis;

         // activity.HasCompilerGeneratedSignature;
         // activity.HidesBaseClassMember;
         // activity.ImplementedInterfaceMethod;
         // activity.ImplementedInterfaceMethods;
         // activity.ImplementedTypes;
         // activity.ImplFlags;
            activity.InitLocals = true;
            activity.Name = Identifier.For("_"+this.name.Name);
         // activity.NodeType;
         // activity.OverridesBaseClassMember;
         // activity.PInvokeFlags;
         // activity.PInvokeImportName;
         // activity.PInvokeModule;
         // activity.Requires;
         // activity.ReturnAttributes;
            activity.ReturnType = SystemTypes.Void;
         // activity.Scope;
            activity.SourceContext = this.sourceContext;
         // activity.ThisParameter
         // activity.Template;
         // activity.TemplateArguments;
         // activity.TemplateParameters;
         // activity.UniqueKey;

            //if (enclosing.modifiers.Protected)
            //{
            //    Lock lock_stmt = new Lock();
            //    lock_stmt.SourceContext = this.sourceContext;
            //    lock_stmt.Guard = new This();
            //    lock_stmt.Body = activity.Body;
            //    activity.Body = new Block();
            //    activity.Body.Statements = new StatementList();
            //    activity.Body.Statements.Add(lock_stmt);
            //}

            node = activity;

            CONTEXT.current_routine = saved;
            return node;
        }

        //------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("ACTIVITY DECLARATION {0}, line={1}",name.ToString(), this.sourceContext.StartLine.ToString());
            report_extra();

            base.report(shift+reportShift);
        }

        public override void report_short() {
            System.Console.Write("ACTIVITY {0}",unique);
        }
#endif
    }

    // =========================================================================
    // 1.3 SIMPLE DECLARATIONS
    // =========================================================================

    // SIMPLE_DECL
    // ===========
    // For all kinds of "simple" (or local) declarations of named entities:
    //
    // o  import declarations (but they can be also unnamed...)
    // o  variable declarations
    // o  constant declarations
    // o  type declarations
    // o  enumerator declarations
    //
    public abstract class SIMPLE_DECL : DECLARATION {
        // Constructor
        public SIMPLE_DECL ( ASTNodeType astNodeType, Identifier name ) : base(astNodeType, name) { }

        public abstract override NODE resolve ( );
        public abstract override bool validate ( );
        public abstract override TYPE type { get; set; }
        public abstract override Node convert ( );
#if DEBUG
        public abstract override void report ( int shift );
#endif
    }

    // IMPORT_DECL
    // ===========
    // For Zonnon import declarations:
    //
    //   ImportDeclaration = IMPORT Import { "," Import }.
    //   Import = ImportedName [ AS Ident ].
    //   ImportedName = QualIdent.
    //
    public sealed class IMPORT_DECL : SIMPLE_DECL {
        // Constructor
        public IMPORT_DECL ( Identifier name ) : base(ASTNodeType.IMPORT_DECL, name) { }

        public IMPORT_DECL(Identifier name, bool satellite, SourceContext sct) : 
            base(ASTNodeType.IMPORT_DECL, name) {
            this.sourceContext = sct;
            satelliteImport = satellite; 
        }

        // A namespace or unit to which this import declaration refers.
        // It's a typical case that 'unit' refers to an UNKNOWN_DECL node.
        // This is for units/namespaces which are just not known yet:
        //
        // MODULE m;
        //    IMPORT A.B;  <== Here neither A nor B is known...
        //  ...
        //
        // During resolution this UNKNOWN_DECL should be replaced for
        // a NAMESPACE_DECL or other UNIT_DECL node.
        //
        public UNIT_DECL imported_unit;
        /// <summary>
        /// Import DEFINITION as satellight to implements clause
        /// </summary>
        private bool satelliteImport = false; 
        //-----------------------------------------------------
        public bool IsSatellite() {
            return satelliteImport;
        }

        public override NODE resolve() {
            if (imported_unit == null) return this;
            NODE n = imported_unit.resolve();
            if ( n is UNIT_DECL )  // can be of some other type (in case of an error)
            {
                imported_unit = (UNIT_DECL)n;
                if (this.name == null)
                    name = n.name;
                return imported_unit;
            } else {
                string s;
                if (this.name != null)
                    s = this.name.Name;
                else
                    s = n.name.Name;
                ERROR.IncorrectImport(s);
                return this;
            }
        }

        //-----------------------------------------------------

        public override bool validate ( )   // checks semantical correctness
        {
            DECLARATION unit;

            if (imported_unit is DEFINITION_DECL && !satelliteImport) {
                if (this.getEnclosingUnit().IsTopLevelUnit()) {
                    // It still makes pretty much sense for top level units
                } else
                    if (((DEFINITION_DECL)imported_unit).default_implementation != null) {
                    ERROR.NotImplemented(sourceContext, "use implements with definitions, but not import. Private inheritance is");
                    imported_unit = ((DEFINITION_DECL)imported_unit).default_implementation;
                    } else
                    ERROR.CannotImportDefinition(imported_unit.Name, sourceContext);
            }

            if ( imported_unit is UNKNOWN_DECL )
                unit = ((UNKNOWN_DECL)imported_unit).RealDeclaration;
            else
                unit = imported_unit;

            if ( unit != null && unit is UNIT_DECL )
                return unit.validate();

            if (!this.ErrorReported) {
                //Identifier name = unit!=null ? unit.name : imported_unit.name; 
                //NODE.generateFullName(unit!=null ? unit : imported_unit);
                string name = NODE.generateFullName(unit != null ? unit : imported_unit);
                ERROR.WrongImportName(this.sourceContext, name);
                this.ErrorReported = true;
            }
            return false;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return null; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            if ( imported_unit is UNKNOWN_DECL && ((UNKNOWN_DECL)imported_unit).RealDeclaration == null )
            {
                if ( !imported_unit.ErrorReported )
                {
                    ERROR.UndeclaredUnit(base.sourceContext,imported_unit.name.Name);
                    imported_unit.ErrorReported = true;
                }
                return null;
            }

            string   nameTail = null;
            TypeNode type     = null;
            IMPLEMENTATION_DECL implementation = null;

            UNIT_DECL_LIST implemented_defs = null;
            if ( enclosing is MODULE_DECL )
                implemented_defs = ((MODULE_DECL)enclosing).definitions;
            else if ( enclosing is OBJECT_DECL )
                implemented_defs = ((OBJECT_DECL)enclosing).definitions;

            if (imported_unit is DEFINITION_DECL) {
                implementation = ((DEFINITION_DECL)imported_unit).default_implementation as IMPLEMENTATION_DECL;
                DEFINITION_DECL rdef = (DEFINITION_DECL)imported_unit;
                while (implementation == null) // Check if there is a refined defenition
                {
                    if (rdef.base_definition != null && rdef.base_definition.resolve() is DEFINITION_DECL)
                    {
                        rdef = (DEFINITION_DECL)rdef.base_definition.resolve();
                        implementation = rdef.default_implementation as IMPLEMENTATION_DECL;
                    }
                    else
                    {
                        return null;
                    }
                }
                
                //// If the definition is not mentioned in the 'implements' clause
                //// then we do not generate "mix-in" member.
                //if ( implemented_defs == null ) return null;                
                //if ( implemented_defs.find(imported_unit) == null ) return null;
                // == > We can have it among refins so we do not check this fact.

                // Generate field for "mixed" instance of the imported implementation.
                nameTail = "_mixed";
                type = implementation.convertAndGetType() as TypeNode;
                //type = (TypeNode)imported_unit.convert();
            } else if (imported_unit is IMPLEMENTATION_DECL) {
                implementation = imported_unit as IMPLEMENTATION_DECL;
                if (implementation.implemented_definition != null) {
                    // If the definition is not mentioned in the 'implements' clause
                    // then we do not generate "mix-in" member.
                    if (implemented_defs == null)
                        return null;
                    DECLARATION def = (DECLARATION)implementation.implemented_definition.resolve();
                    if (!(def is DEFINITION_DECL))
                        return null;
                    for (int i = 0, n = implemented_defs.Length; i < n; i++) {
                        UNIT_DECL impl = (UNIT_DECL)implemented_defs[i].resolve();
                        if (impl == def)
                            goto Success;
                        if (impl == implementation)
                            goto Success;
                    }
                    return null;
                Success:
                    nameTail = "_mixed";
                    type = (TypeNode)implementation.implemented_definition.convert();
                } else {
                    // Otherwise, this import actually _aggregates_ implementation.
                    // Generate the member representing agggregated implementation.
                    nameTail = "_hidden";
                    type = (TypeNode)implementation.convert();
                }
            } else
                return null;

         // nameTail != null

            Field mixed = new Field();
            mixed.DeclaringType = (TypeNode)this.getEnclosingUnit().convert();
            mixed.Flags = FieldFlags.Private;
            if (enclosing is MODULE_DECL)
                mixed.Flags |= FieldFlags.Static;
            mixed.Name = Identifier.For(/*implementation.name.Name*/  imported_unit.Name + nameTail);
            mixed.Type = type;

            UNIT_DECL context = CONTEXT.current_unit;
        //  if ( context is OBJECT_DECL && ((OBJECT_DECL)context).modifiers.Value )
        //      return mixed;
        //  -- This will be checked afetrwards, just after returning from this function.

            Construct ctorCall = new Construct();
            // Strange thing: CCI expects _class_ in Construst.Constructor,
            // but not a constructor itself!..
            ctorCall.Constructor = new MemberBinding(null,(TypeNode)implementation.convert());
            ctorCall.Constructor.Type = SystemTypes.Type;
            ctorCall.Operands = new ExpressionList();  // empty
            ctorCall.SourceContext = this.sourceContext;
            ctorCall.Type = (TypeNode)implementation.convert();

            mixed.Initializer = ctorCall;
            mixed.SourceContext = this.sourceContext;

            return mixed;

     //     AliasDefinition alias = new AliasDefinition();
     //
     //     alias.Alias = base.name;
     //     alias.URI          = Identifier.For(NODE.generateFullName(imported_unit));
     //     alias.OriginalName = Identifier.For(NODE.generateFullName(imported_unit));
     //  // alias.AliasedType;
     //     alias.SourceContext = base.sourceContext;
     //
     //     node = alias;
     //     return node;
        }

        public string generateFullName() {
            if (imported_unit is EXTERNAL_DECL) {
				// The external unit provides its full qualified name!
                return ((EXTERNAL_DECL)imported_unit).entity.ToString();
            } else {
				// Units we have declared do not provide such a full name mechanism
				// the only information we have is the unit name itself, so, go up the
				// teh tree of declaration and build a fully qualified name
                string s = imported_unit.name.ToString(); 
                UNIT_DECL ud = (UNIT_DECL)imported_unit.enclosing;

                while (ud != CONTEXT.globalTree) {
                    s = ud.name + "." + s;
                    ud = (UNIT_DECL)ud.enclosing;
                }
                return s;
            }
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            // if ( imported_unit is SYSTEM_ENTITY ) System.Console.Write("SYSTEM ");
            System.Console.Write("IMPORT DECLARATION {0}, line={1}",(name!=null)?name.ToString():"unnamed", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("IMPORTED UNIT: ");
         // if ( imported_unit is SYSTEM_ENTITY )
         // {
         //     System.Console.WriteLine();
         //     imported_unit.report(shift+2*reportShift);
         // }
         // else
            imported_unit.report_short();
            System.Console.WriteLine();
        }

        public override void report_short() {
            System.Console.WriteLine("IMPORT DECLARATION {0}:{1}",
                unique,(name!=null)?name.ToString():"unnamed");
        }
#endif
    }

    // VARIABLE_DECL
    // =============
    // For all kinds of variable declarations: procedure variables, fields and parameters.
    //
    //   VariableDeclaration = IdentList ":" VariableType.
    //
    public abstract class VARIABLE_DECL : SIMPLE_DECL {
        // Set to true if the declared variable is mentioned in and await statement
        public bool usedInAwait = false;

        // Constructor
        public VARIABLE_DECL ( ASTNodeType astNodeType, Identifier name ) : base(astNodeType, name) { }

        //-----------------------------------------------------

        public override bool validate() {
            if ( modifiers.Private && modifiers.Immutable )
                ERROR.ImmutableIsPrivate(name.SourceContext);

            if (modifiers.Getter || modifiers.Setter) {
                if (this is FIELD_DECL && this.enclosing is DEFINITION_DECL)
                    return true;
                if (!this.ErrorReported) {
                    ERROR.IllegalModifierFor("get/set","parameter or local",this.sourceContext);
                    this.ErrorReported = true;
                }
                return false;
            }
            return true;
        }

        public abstract override NODE resolve ( );
        public abstract override TYPE type { get; set; }
        public abstract override Node convert ( );


#if DEBUG
        public abstract override void report ( int shift );
#endif
        //----------------------------------------------------------------------

        public static VARIABLE_DECL create(NODE unit, IDENT_LIST names, TYPE type, bool Reference, MODIFIERS mods) {
            VARIABLE_DECL VarDecl = null;

            for (int i = 0, n = names.Length; i < n; i++) {
                NODE result = unit.findLocal(names[i]);

                if (result != null && !(result is UNKNOWN_DECL)) {
                    // duplicate declaration
                    ERROR.DuplicateDeclaration(names[i].ToString());
                    continue;
                }
            //  else
            //      -- resolve unknown declaration (at the end of the function)

                if (unit is UNIT_DECL)
                    VarDecl = new FIELD_DECL(names[i]);
            //  else if ( unit is ACTIVITY_DECL ) VarDecl = new LOCAL_DECL(names[i]);
                else if ( unit is ROUTINE_DECL ) // PARAMETER_DECL or LOCAL_DECL
                {
                    if (((ROUTINE_DECL)unit).inParams)
                        VarDecl = new PARAMETER_DECL(names[i], Reference);
                    else
                        VarDecl = new LOCAL_DECL(names[i]);
                } else
                    return null;

                VarDecl.enclosing = unit;
             // VarDecl.name  -- already given
                VarDecl.setContext(names[i].SourceContext,Parser.LEXAN.getSourceContext());
                VarDecl.type = type;

                if (mods != null && !mods.Empty()) {
                    if (VarDecl is LOCAL_DECL || VarDecl is PARAMETER_DECL) {
                        string decl = VarDecl is LOCAL_DECL ? "local variable" : "parameter";
                        ERROR.IllegalModifierFor(mods.ToString(),decl);
                    } else  // VarDecl is FIELD_DECL
                    {
                        if (unit is DEFINITION_DECL && !mods.Getter && !mods.Setter) {
                            mods.Getter = true;
                            mods.Setter = true;
                        }
                        VarDecl.modifiers = mods;
                    }
                } else if (unit is UNIT_DECL) {
                    // No explicit modifiers; assign public/private dy default
                    mods = new MODIFIERS();
                    if (unit is MODULE_DECL || unit is OBJECT_DECL)
                        mods.Private = true;
                    else  /* DEFINITION or IMPLEMENTATION */
                        mods.Public = true;
                    if (unit is DEFINITION_DECL && !mods.Getter && !mods.Setter) {
                        // If a variable is declared without accessor modifiers
                        // then treat it as _both_ getter and setter.
                        mods.Getter = true;
                        mods.Setter = true;
                    }
                    VarDecl.modifiers = mods;
                }

                if (unit is UNIT_DECL)
                    ((UNIT_DECL)unit).locals.Add(VarDecl);
                else if (unit is ROUTINE_DECL) {
                    if (((ROUTINE_DECL)unit).inParams)
                        ((ROUTINE_DECL)unit).parameters.Add(VarDecl);
                    else
                        ((ROUTINE_DECL)unit).locals.Add(VarDecl);
                }
                if (result is UNKNOWN_DECL) {
                    ((UNKNOWN_DECL)result).RealDeclaration = VarDecl;
                    ((UNKNOWN_DECL)result).name = null;
                }
            }

            // For processing multiple assignments only (see Parser).
            if (names.Length == 1)
                return VarDecl;
            else
                return null;
        }

        //----------------------------------------------------------------------

        // createInitializer
        // -----------------
        // Generates the CCI code for variable initializers:
        //
        // - for variables of array types:
        //
        //                new AT[size1,...],
        //
        //   where AT is an array type, sizei - dimensions.
        //
        // - for variables of value object types:
        //
        //                new T
        //
        //   where T is an object type.
        //
        // The function is used by derived classes: LOCAL_DECL and FIELD_DECL.
        //
        public Expression createInitializer(VARIABLE_DECL variable) {
            if ( variable.type is ARRAY_TYPE ) // type is ArrayTypeExpression )
            {
                // Don't consider initializers if array is open
                if (((ARRAY_TYPE)variable.type).isOpen)
                    return null;

                ARRAY_TYPE source_type = variable.type as ARRAY_TYPE;
                ArrayTypeExpression array = ((TypeNode)variable.type.convert()) as ArrayTypeExpression;

                ConstructArray initializer = new ConstructArray();

                initializer.ElementType = array.ElementType;
                initializer.Operands = new ExpressionList();
                initializer.Rank = array.Rank; //array.Sizes.Length;
                initializer.Type = (ArrayType)array;
                initializer.SourceContext = variable.sourceContext;

                for (int i = 0, n = initializer.Rank; i < n; i++) {
                    initializer.Operands.Add(new Literal(source_type.const_dimensions[i],SystemTypes.Int32));
                }
                return initializer;
            }
            if ((variable.type is EXTERNAL_TYPE) || (variable.type is OBJECT_TYPE)) {
                Struct cls = null;
                if (variable.type is OBJECT_TYPE) {
                    OBJECT_DECL obj = (OBJECT_DECL)((OBJECT_TYPE)variable.type).ObjectUnit;
                    if (obj.reference)
                        return null;
                    cls = obj.convert() as Struct;
                } else {
                    cls = ((EXTERNAL_TYPE)variable.type).entity as Struct;
                }

                
                if (cls == null)
                    return null;

                InstanceInitializer ctr = cls.GetConstructors()[0] as InstanceInitializer;
                if (ctr == null)
                    return null;
                if (ctr.Parameters.Length != 1)
                    return null;
                // Enshure that it's Zonnon's init constructor for value objects
                if (ctr.Parameters[0].Name.Name.CompareTo("_fict") != 0)
                    return null;
                Construct construct = new Construct();
                construct.Constructor = new MemberBinding(null, ctr);  // NODE.convertTypeName(obj);
                construct.Operands = new ExpressionList();
                construct.Operands.Add(new Literal(0, SystemTypes.Int32));  /////////////////////
                construct.Type = cls;

                return construct;                

            }
            return null;
        }

        public Block createElementInitializer() {
         // return null;
            // If the variable is ARRAY, and if its dimensions are constants,
            // and if array elements are either arrays or VAL-objects,
            // then we should _initialize_ array elements.
            //
            // VAR x : ARRAY n OF obj;  ==>
            //
            //                 obj[n] x = new obj[n];
            //                 ...
            //             ||  { for (int i=0; i<n; i++)
            //             ||        x[i] = new obj; }
            //
            // VAR x : ARRAY n, m OF obj;  ==>
            //
            //                 obj[n,m] x = new obj[n,m];
            //                 ...
            //             ||  { for (int i1=0; i1<n; i1++)
            //             ||        for (int i2=0; i2<m; i2++)
            //             ||            x[i1,i2] = new obj; }
            //
            // VAR x : ARRAY n OF ARRAY m OF obj;  ==>
            //
            //                 obj[n] x = new obj[n];
            //                 ...
            //             ||  { for (int i1=0; i1<n; i++)
            //             ||    {   x[i1] = new object[m];
            //             ||        for (int i2=0; i2<m; i2++)
            //             ||            x[i1][i2] = new obj; } }

            // The function generates initializing code
            // and returns it as the result.

            // Check if the type is ARRAY.
            if (!(type is ARRAY_TYPE))
                return null;
            // Check if all dimensions are constants.
            EXPRESSION_LIST dimensions = ((ARRAY_TYPE)type).dimensions;
            for (int i = 0, n = dimensions.Length; i < n; i++) {
                if (dimensions[i] == null)
                    return null;
                if (dimensions[i].calculate() == null)
                    return null;
            }

            // If elements type is, in turn, ARRAY then recursively generate
            // initializing code; otherwise, generate the code directly.
            TYPE elem_type = ((ARRAY_TYPE)type).base_type;
            if (elem_type is OBJECT_TYPE) {
                // Check if the type of array elements is VAL-object.
                if (!((OBJECT_TYPE)elem_type).ObjectUnit.modifiers.Value)
                return null;
            } else if (!(elem_type is ARRAY_TYPE))
                return null;

            return TreeNUtil.createElementInitializerInternal(type, this.name, 0, null, true, this.sourceContext);
        }

        protected bool checkVisibility() {
            bool routine_is_public = false;
            bool this_is_field = false;
            if ( enclosing is ROUTINE_DECL )
                routine_is_public = ((ROUTINE_DECL)enclosing).modifiers.Public;
            else if ( enclosing is PROC_TYPE )
                routine_is_public = ((PROC_TYPE)enclosing).modifiers.Public;
            else if ( enclosing is OBJECT_DECL || enclosing is MODULE_DECL )
                this_is_field = true;

      ///      bool needToCheck = ( this_is_field && this.modifiers.Public ) || routine_is_public;                
                               // This is a public field or this is a parameter of a public routine

      ///      if ( needToCheck )
            {
                bool res = this.type.checkVisibility(this.sourceContext);

                if (!res)
                    this.ErrorReported = true;
                // Type of a public variable declaration is private;
                // a message has been issued.

                return res;
            }
        }
    }

    // PARAMETER_DECL
    // ==============
    //
    public sealed class PARAMETER_DECL : VARIABLE_DECL {
        // Constructor
        public PARAMETER_DECL ( Identifier name, bool Ref ) : base(ASTNodeType.PARAMETER_DECL, name) { Reference = Ref; }

        //-----------------------------------------------------

        public bool Reference;

        //-----------------------------------------------------

        public override NODE resolve() {
            if (type != null && type is UNKNOWN_TYPE)
                type = (TYPE)type.resolve();
            /* TODO: Check why we need this line below. |= - important, not just = */
            if (type is EXTERNAL_TYPE)
                Reference |= ((EXTERNAL_TYPE)type).entity is System.Compiler.Reference;
            
            return this;
        }

        //-----------------------------------------------------

        public override bool validate ( ) // checks semantical correctness
        {
            base.validate();
            if (type == null) {
                ERROR.UnknownType(this.sourceContext,this.name.Name);
                return false;
            }
            if (!type.validate())
                return false;
            if (!base.checkVisibility())
                return false;
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return internal_type; } set { internal_type = value; } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            Parameter parameter = new Parameter();
         // parameter.Attributes
            parameter.DefaultValue = null;
        //  parameter.Flags = ParameterFlags.In;
   /////    if ( Reference ) parameter.Flags |= ParameterFlags.Out;
   /////    else             parameter.Flags |= ParameterFlags.In;
         // parameter.MarshalType
            parameter.Name = name;
         // parameter.NodeType
         // parameter.ParameterListIndex --???
            parameter.SourceContext = base.sourceContext;
            Node encl = this.enclosing.convert();
            if ( encl is Method )
                parameter.DeclaringMethod = (Method)this.enclosing.convert();
         // else
         //     -- parameter can also belong to a procedure type;
         //     -- for this case enclosing gives DelegateNode but not Method...

            if (type != null) {
                TypeNode primary;
                if (CONTEXT.useComputeMath && ComputeType.FromType(type).HasValue) {
                    primary = STANDARD.Data;
                } else {
                    primary = (TypeNode)type.convert();
                }
                if ( primary != null && Reference /* && !(type is ARRAY_TYPE) */ )
                    primary = new ReferenceTypeExpression(primary);
                parameter.Type = primary;

            }
            node = parameter;
            return node;
        }

        //----------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("PARAMETER DECLARATION {0}, line={1}",name.ToString(),this.sourceContext.StartLine.ToString());
            if ( Reference )
                System.Console.Write(" BY REFERENCE");
            report_extra();

            if (type == null) {
                NODE.doShift(shift+reportShift);
                System.Console.WriteLine("TYPE MISSED");
            } else
                type.report(shift+NODE.reportShift);
        }

        public override void report_short() {
            System.Console.Write("PARAMETER {0}:{1}",unique,base.name.ToString());
        }
#endif
    }

    // LOCAL_DECL
    // ==========
    //
    public sealed class LOCAL_DECL : VARIABLE_DECL {
        // Constructor
        public LOCAL_DECL ( Identifier name ) : base(ASTNodeType.LOCAL_DECL, name) { }

        //-----------------------------------------------------

        public override NODE resolve() {
            if ( type != null )
                type = (TYPE)type.resolve();
            return this;
        }

        //-----------------------------------------------------

        public override bool validate ( ) // checks semantical correctness
        {
            bool ok = base.validate();
            if (!ok) return false;
            if (type == null)
                return false;
            if (!base.checkVisibility())
                return false;
            ok = type.validate();
            if(!ok && type != null && !ErrorReported){
                ERROR.UnknownType(this.sourceContext, type.Name);
                ErrorReported = true;
            }
            return ok;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return internal_type; } set { internal_type = value; } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

    //      Local var = new Local();
    //   // var.DeclaringBlock
    //   // var.Index;
    //      var.InitOnly = false;
    //      var.Name = name;
    //   // var.NodeType;
    //   // var.Pinned;
    //      var.SourceContext = base.sourceContext;
    //      var.Type = (TypeNode)type.convert();
    //      var.TypeExpression = var.Type;
    //      node = var;

    //      VariableDeclaration variable = new VariableDeclaration();
    //
    //      variable.Name = name;
    //   // variable.NodeType
    //      variable.SourceContext = base.sourceContext;
    //      if ( type != null )
    //          variable.Type = (TypeNode)type.convert();
    //      variable.Initializer = base.createInitializer(this);
    //
    //      node = variable;

            LocalDeclarationsStatement loc_stmt = new LocalDeclarationsStatement();
            loc_stmt.Constant = false;
            loc_stmt.Declarations = new LocalDeclarationList(1);
            loc_stmt.InitOnly = false;
            loc_stmt.SourceContext = base.sourceContext;

            #region compute math
            if (CONTEXT.useComputeMath && ComputeType.FromType(type).HasValue) {
                loc_stmt.Type = STANDARD.Data;
            } else {
            loc_stmt.Type = (TypeNode)type.convert();
            }
            #endregion

            loc_stmt.TypeExpression = loc_stmt.Type;
      
            LocalDeclaration local = new LocalDeclaration();
         // local.Field
            if (!CONTEXT.useComputeMath) local.InitialValue = base.createInitializer(this);
            local.Name = name;
            local.SourceContext = base.sourceContext;
            loc_stmt.Declarations.Add(local);
      
            node = loc_stmt;
            return node;
        }

        //----------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("VARIABLE DECLARATION {0}, line={1}",name.ToString(), this.sourceContext.StartLine.ToString());
            report_extra();

            if (type == null) {
                NODE.doShift(shift+reportShift);
                System.Console.WriteLine("TYPE MISSED");
            } else
                type.report(shift+NODE.reportShift);
        }

        public override void report_short() {
            System.Console.Write("VARIABLE {0}:{1}",unique,base.name.ToString());
        }
#endif
    }

    // FIELD_DECL
    // ==========
    //
    public sealed class FIELD_DECL : VARIABLE_DECL {
        // Constructor
        public FIELD_DECL ( Identifier name ) : base(ASTNodeType.FIELD_DECL, name) { }

        //-----------------------------------------------------

        public override NODE find(Identifier name) {
            return type.find(name);
        }

        //-----------------------------------------------------
        private bool prevent_recutsion = false;
        public override NODE resolve() {
            if (prevent_recutsion) return this;
            prevent_recutsion = true;
            if ( type != null )
                type = (TYPE)type.resolve();
            prevent_recutsion = false;
            return this;
        }

        //-----------------------------------------------------

        public override bool validate ( ) // checks semantical correctness
        {
            base.validate();
            if (type == null)
                return false;
            if (!base.checkVisibility())
                return false;
            bool noproblem = type.validate();
            if (!noproblem && !ErrorReported)
            {                
                ERROR.UnknownType(this.sourceContext, type.Name);
                ErrorReported = true;
            }
            return noproblem;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type   // evaluates type
        {
            get { return internal_type; }
            set { internal_type = value; }
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            if ( type == null )
                // There was an error in determining the type...
                type = new INTEGER_TYPE();  // as a stub

            Field field = new Field();

         // field.Attributes;
            if ( enclosing != null ) // Here enclosing should be OBJECT or DEFINITION
                field.DeclaringType = (TypeNode)enclosing.convertAndGetType();
            field.DefaultValue = null;
            if ( enclosing is MODULE_DECL )
                field.Flags |= FieldFlags.Static;

            if (modifiers.Public)
                field.Flags |= FieldFlags.Public;
            else if (modifiers.Private)
                field.Flags |= FieldFlags.Private;
            else    /* default */
                field.Flags |= FieldFlags.Private;
            
         // if      ( modifiers.Immutable ) field.Flags |= FieldFlags.InitOnly;
            // TODO: it can be modified within the scope, so we can't use .NET protection. Need our own.

         // field.HidesBaseClassMember =
            field.IsVolatile = false;
            field.Name = base.name;
         // field.NodeType
         // field.Offset
         // field.OverridesBaseClassMember =
            field.SourceContext = base.sourceContext;

            #region compute math
            if (CONTEXT.useComputeMath && ComputeType.FromType(type).HasValue) {
                field.Type = STANDARD.Data;
            } else {
                field.Type = (TypeNode)type.convert();
            }
            #endregion


////////    if ( ((UNIT_DECL)enclosing).modifiers.Reference )
            field.Initializer = base.createInitializer(this);

         // if ( field.Type is ArrayType )
         // {
         //     ((ArrayType)field.Type).Sizes = new int[((ArrayType)field.Type).Rank];
         // }

         // if ( field.Type is ArrayTypeExpression )
         // {
         //     ArrayTypeExpression arr = field.Type as ArrayTypeExpression;
         //     for ( int i=0, n=arr.Sizes.Length; i<n; i++ )
         //     {
         //         arr.Sizes[i] = -1;
         //     }
         // }

            node = field;
            return node;
        }


#if DEBUG
        public override void report(int shift) {
            report_unique(shift);

            System.Console.Write(modifiers.ToString());
            System.Console.Write("FIELD DECLARATION {0}, line={1}",name.ToString(), this.sourceContext.StartLine.ToString());
            report_extra();

            if (type == null) {
                NODE.doShift(shift+reportShift);
                System.Console.WriteLine("TYPE MISSED");
            } else
                type.report(shift+NODE.reportShift);
        }

        public override void report_short() {
            System.Console.Write("FIELD {0}:{1}",unique,base.name.ToString());
        }
#endif
    }

    // CONSTANT_DECL
    // =============
    //
    //   ConstantDeclaration = Ident "=" ConstExpression.
    //
    public sealed class CONSTANT_DECL : SIMPLE_DECL {
        // Constructor
        public CONSTANT_DECL ( Identifier name ) : base(ASTNodeType.CONSTANT_DECL, name) { }

        //-----------------------------------------------------

        public EXPRESSION initializer;

        //-----------------------------------------------------

        public static CONSTANT_DECL create(NODE unit, MODIFIERS modifiers, Identifier name, EXPRESSION initializer) {
            NODE result = unit.find(name);

            if (result != null && !(result is UNKNOWN_DECL)) {
                // duplicate declaration
                ERROR.DuplicateDeclaration(name.ToString());
                return null;
            }
            //  else
            //      -- resolve unknown declaration (at the end of the function)

            CONSTANT_DECL ConstDecl = new CONSTANT_DECL(name);

            ConstDecl.enclosing = unit;
            ConstDecl.initializer = initializer;
            ConstDecl.initializer.enclosing = ConstDecl;
            ConstDecl.modifiers = modifiers;
            if (modifiers == null) {
                // Setting default modifiers
                if (unit is UNIT_DECL) {
                    if (unit is MODULE_DECL)
                        ConstDecl.modifiers.Private = true;
                    else if (unit is DEFINITION_DECL)
                        ConstDecl.modifiers.Public = true;
                    else if (unit is IMPLEMENTATION_DECL)
                        ConstDecl.modifiers.Public = true;
                    else if (unit is OBJECT_DECL)
                        ConstDecl.modifiers.Private = true;
                }
            }
         // ConstDecl.name -- already given
         // ConstDecl.sourceContext = Parser.LEXAN.getSourceContext();
            ConstDecl.type = initializer.type;

            if (unit is UNIT_DECL)
                ((UNIT_DECL)unit).locals.Add(ConstDecl);
            else if (unit is ROUTINE_DECL)
                ((ROUTINE_DECL)unit).locals.Add(ConstDecl);

            if (result is UNKNOWN_DECL) {
                ((UNKNOWN_DECL)result).RealDeclaration = ConstDecl;
                ((UNKNOWN_DECL)result).name = null;
            }
            return ConstDecl;
        }

        //-----------------------------------------------------

        public override NODE resolve() {
            initializer.resolve();
            if (initializer is CCI_LITERAL)
                return this; // initializer;
            // don't calculate; initializer is already "calculated"...

            object val = initializer.calculate();

            if (this.type is ANY_TYPE)
                this.type = initializer.type;

            if (val == null) {
                ERROR.NonConstant(initializer.sourceContext,"constant initializer");
                val = 1L;
            }
            if (initializer.type is INTEGER_TYPE || initializer.type is CARDINAL_TYPE) {
                Literal literal = null;
             // if ( ((INTEGER_TYPE)initializer.type).width <= 32 )
             //     literal = new Literal((int)(long)val,SystemTypes.Int32);
             // else
             //     literal = new Literal(val,SystemTypes.Int64);

                TypeNode t = (TypeNode)initializer.type.convert();
             // if ( val is long )
             // {
             //     literal = new Literal((long)val,SystemTypes.Int64);
             // }
             // else /* ulong */
             // {
             //     literal = new Literal((ulong)val,SystemTypes.UInt64);
             // }
                literal = new Literal(val,t);
                initializer = CCI_LITERAL.create(initializer.type,literal);
            } else if (initializer.type is ENUM_TYPE) {
                initializer = CCI_LITERAL.create(STANDARD.Integer.type,new Literal(val,SystemTypes.Int32));
            } else if (initializer.type is REAL_TYPE) {
             // double v = (double)val;
                initializer = CCI_LITERAL.create(STANDARD.Real.type,new Literal(val,SystemTypes.Double));
            } else if (initializer.type is CHAR_TYPE) {
                initializer = CCI_LITERAL.create(STANDARD.Char.type,new Literal(val,SystemTypes.Char));
            } else if (initializer.type is CARDINAL_TYPE) {
                initializer = CCI_LITERAL.create(STANDARD.Cardinal.type,new Literal(val,SystemTypes.UInt64));
            } else if (initializer.type is STRING_TYPE) {
                initializer = CCI_LITERAL.create(STANDARD.String.type,new Literal(val,SystemTypes.String));
            } else if (initializer.type is SET_TYPE) {
                initializer = CCI_LITERAL.create(STANDARD.Set.type,new Literal(val,SystemTypes.UInt32));
            } else if (initializer.type is BOOLEAN_TYPE) {
                initializer = CCI_LITERAL.create(STANDARD.Boolean.type, new Literal(val, SystemTypes.Boolean));
            }

            return this; // initializer;
        }

        //-----------------------------------------------------

        public override bool validate ( ) // checks semantical correctness
        {
            bool ok = initializer is CCI_LITERAL || initializer is LITERAL;
            if (!ok && !ErrorReported)
            {
                ERROR.NonConstant(initializer.sourceContext, initializer.sourceContext.SourceText);
                ErrorReported = true;
            }
            return ok;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates type
        {
            get { return internal_type; }
            set { internal_type = value; }
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            Node cst = null;
            resolve();
            // We do not generate any CCI code for PRIVATE Zonnon constant declarations:
            // they are always "true" literals so we can just take their values
            // when we compile expressions with such constants...

            // if constant is public we create a declaration and enclosing is module
            if (modifiers.Public && (enclosing is MODULE_DECL || enclosing is OBJECT_DECL))
            {
                Field field = new Field();
                field.DeclaringType = (TypeNode)enclosing.convertAndGetType();
                Literal lit = initializer.convert() as Literal;
                field.DefaultValue = lit;                
                if (lit == null)
                {
                    ERROR.NonConstant(sourceContext, Name);
                    ErrorReported = true;
                }
                field.Flags = FieldFlags.Static | FieldFlags.Literal 
                    | FieldFlags.Public | FieldFlags.HasDefault;
                    
                field.Name = name;
                field.SourceContext = sourceContext;
                field.Type = initializer.type.convert() as TypeNode;
                field.Initializer = initializer.convert() as Expression;
                cst = field;
            }
            return cst;
        }

        //------------------------------------------------------------------------

        //------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("CONSTANT DECLARATION {0}, line={1}",name.ToString(), this.sourceContext.StartLine.ToString());
            report_extra();

            if (type == null) {
                NODE.doShift(shift+reportShift);
                System.Console.WriteLine("TYPE MISSED");
            } else
                type.report(shift+NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("INIT EXPRESSION");

            if ( initializer == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                initializer.report(shift+NODE.reportShift);
            }
        }

        public override void report_short() {
            System.Console.Write("CONSTANT {0}:{1}",this.unique,this.name.Name);
        }
#endif
    }

    // TYPE_DECL
    // =========
    //
    //   TypeDeclaration = Ident "=" Type.
    //
    public sealed class TYPE_DECL : SIMPLE_DECL {
        private bool recursion;

        // Constructor
        public TYPE_DECL ( Identifier name ) : base(ASTNodeType.TYPE_DECL, name) { recursion = false; }

        //-----------------------------------------------------


        public override NODE find(Identifier name) {
            if (type != null) return type.find(name);
            else return null;
        }

        public static TYPE_DECL create ( NODE unit, MODIFIERS modifiers, Identifier name, TYPE type )
        {
            if ( unit == null ) return null; // an error before

            NODE entity = unit.find(name);
            TYPE_DECL typeDecl;

            if (entity != null && !(entity is UNKNOWN_DECL)) {
                // Duplicate declaration.
                ERROR.DuplicateDeclaration(name.ToString());
                return null;
            }

            typeDecl = new TYPE_DECL(name);

            typeDecl.enclosing = unit;
         // typeDecl.modifiers -- already initialized
            if (!modifiers.Private && !modifiers.Public) {
                // Choose default modifier
                if (unit is MODULE_DECL || unit is OBJECT_DECL)
                    modifiers.Private = true;
                else
                    modifiers.Public = true;
            }
            typeDecl.modifiers.add(modifiers);
         // typeDecl.name  -- already given
         // typeDecl.sourceContext

            // If type belongs to the STANDARD module OR if it already belongs
            // to some other TYPE_DECL then we don't modify its 'enclosing' field.
            if (type != null) {
                if (type.enclosing == null)
                    type.enclosing = typeDecl;
                else if ( !(type.enclosing is TYPE_DECL) && 
                          type.enclosing.enclosing != STANDARD.Standard)
                    type.enclosing = typeDecl;
            }
            typeDecl.type = type;

            if (unit is UNIT_DECL)
                ((UNIT_DECL)unit).locals.Add(typeDecl);
            else if (unit is ROUTINE_DECL)
                ((ROUTINE_DECL)unit).locals.Add(typeDecl);

            if (entity != null && entity is UNKNOWN_DECL) {
                ((UNKNOWN_DECL)entity).RealDeclaration = typeDecl;
                ((UNKNOWN_DECL)entity).name = null;
            }
            return typeDecl;
        }

        //-----------------------------------------------------

        public override NODE resolve() {
            if (recursion) {
                ERROR.RecursiveDefinition(this.name.Name,this.sourceContext);
                type = new INTEGER_TYPE(); // to prevent recursion
            } else {
                recursion = true;
                if (type != null)
                    type.resolve();
            }
            recursion = false;
            return this;
        }

        //-----------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (type == null)
                return false;
            if (this.modifiers.Public && !type.checkVisibility(this.sourceContext)) {
                ErrorReported = true;
            }
            bool res = type.validate();
            if (!res && !(type is ARRAY_TYPE) && !ErrorReported) {
                ERROR.WrongTypeName(this.sourceContext,this.name.Name);
                ErrorReported = true;
            }
            return res;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates type
        {
            get { return internal_type; }
            set { internal_type = value; }
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

        //  if ( this.type == null ) return null;

            TypeNode type = (TypeNode)(this.type.convert());

            if (type is ArrayTypeExpression){
              // Declaraion generates static initializer method which is called instead of new.
                if (this.type is ARRAY_TYPE && ((ARRAY_TYPE)this.type).isOpen && CONTEXT.current_unit is UNIT_DECL) {
                    Node unit = CONTEXT.current_unit.convert();
                    if (unit is Class)
                    {
                        bool isPublic = this.modifiers != null && this.modifiers.Public;
                        Method constructorMethod = TreeNUtil.GetArrayInitializationMethod(this.Name, isPublic, (Class)unit, (ARRAY_TYPE)this.type, this.sourceContext);                        
                        ((ARRAY_TYPE)this.type).constructorCall = new MemberBinding(null, constructorMethod);
                        ((Class)unit).Members.Add(constructorMethod);
                        return null; // The enclosing thing could be a procedure
                    }
                }
              return null;
            }            
            else if (type == SystemTypes.Object)
                return null;    // System.Object
            else if (type is System.Compiler.Struct)
                return null; // predefined type
            else if (type is System.Compiler.Class)
                return null; // An external class

            node = type;  // only for enum types
            return node;
        }

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            if (this.modifiers.Public)
                System.Console.Write("PUBLIC ");
            else
                System.Console.Write("PRIVATE ");
            System.Console.Write("TYPE DECLARATION {0}, line={1}",(name!=null)?name.ToString():"noname", this.sourceContext.StartLine.ToString());
            report_extra();

            if (type == null) {
                NODE.doShift(shift+NODE.reportShift);
                System.Console.WriteLine("FORWARD");
            } else
                type.report(shift+NODE.reportShift);
        }

        public override void report_short() {
            System.Console.Write("TYPE DECLARATION {0}:{1}",unique,base.name.ToString());
        }
#endif
    }

    // ENUMERATOR_DECL
    // ===============
    //
    //  TYPE e = ( e1, e2, e3 );
    //             ..  ..  ..
    //
    public sealed class ENUMERATOR_DECL : SIMPLE_DECL {
        // Constructor
        public ENUMERATOR_DECL ( Identifier name ) : base(ASTNodeType.ENUMERATOR_DECL, name) { }

        //-----------------------------------------------------

        public long val;

        //-----------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //-----------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (!(type is ENUM_TYPE))
                return false;
            return true; // type.validate(); -- with this, the infinite resursion occurs!!
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates type
        {
            get { return internal_type; }
            set { internal_type = value; }
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

         // resolve();
            if (!validate())
                return null;

            return node;
        }

        //-------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("ENUMERATOR DECLARATION {0}",name.ToString());
            report_extra();
        }

        public override void report_short() {
            System.Console.Write("ENUMERATOR DECLARATION {0}:{1}",unique,base.name.ToString());
        }
#endif
    }

    // PROTOCOL_DECL
    // =============
    //
    public sealed class PROTOCOL_DECL : UNIT_DECL//SIMPLE_DECL
    {
        public ENUM_TYPE  keywords;
        public SYNTAX     syntax;
        public PRODUCTION root;      // root production within syntax's list of productions
        public string protocolSpecification; //data to write as metadata

        // Constructor
        public PROTOCOL_DECL ( Identifier name ) : base(ASTNodeType.PROTOCOL_DECL, name) { }

        protected override bool containsErrorReport()
        {
            
            
            return ((syntax == null)?false:syntax.ErrorReported) || ((keywords == null)?false:keywords.ErrorReported);
        }

        //-------------------------------------------------------------------

        public override NODE find(Identifier name) {
            NODE result = keywords.find(name);
            if (result == null)
                result = syntax.find(name);
            return result;
        }

        //--------------------------------------------------------------------

        public static PROTOCOL_DECL create ( MODIFIERS modifiers,
                                             Identifier name, ENUM_TYPE keywords, SYNTAX syntax, string protocolSpecification_) {
            PROTOCOL_DECL protocol = new PROTOCOL_DECL(name);

            DECLARATION context = CONTEXT.current;
            DECLARATION node = (DECLARATION)context.find(name);

            if (node != null) {
                if (node is UNKNOWN_DECL) {
                    ((UNKNOWN_DECL)node).name = null;
                    ((UNKNOWN_DECL)node).RealDeclaration = protocol;
                } else
                    ERROR.DuplicateDeclaration(name.Name);
            }

            protocol.keywords = keywords;
            protocol.syntax = syntax;

            protocol.protocolSpecification = protocolSpecification_;

            protocol.enclosing = context;
         // protocol.name
         // protocol.sourceContext 

         // typeDecl.modifiers -- already initialized
            if (!modifiers.Private && !modifiers.Public) {
                // Choose default modifier
                modifiers.Public = true;
                //if ( context is MODULE_DECL || context is OBJECT_DECL ) modifiers.Private = true;
                //else                                                    modifiers.Public = true;
            }
            protocol.modifiers.add(modifiers);

            // Add new protocol to the current object
            ((UNIT_DECL)(CONTEXT.current)).locals.Add(protocol);
            return protocol;
        }

        //--------------------------------------------------------------------------------

        public override NODE resolve() {
            for (int i = 0, n = syntax.unresolved.Length; i < n; i++) {
                UNKNOWN_NONTERMINAL unknown = syntax.unresolved[i];
                if (unknown.resolved == UNKNOWN_NONTERMINAL.Resolved.NotResolved) {
                    DECLARATION decl = enclosing.find(unknown.name) as DECLARATION;

                    if (decl != null && decl.type != null) {
                        TYPE tp = decl.type;
                        while (unknown != null) {
                            unknown.resolved = UNKNOWN_NONTERMINAL.Resolved.ResolvedAsType;
                            unknown.resolved_as_type = tp;
                            unknown = unknown.previous;
                        }
                    }
                }
            }            
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o  Protocol declarations are allowed within definitions (?), objects and modules
            // o  Protocol syntax should be valid (no keft recursion etc.)

            if (enclosing is DEFINITION_DECL) {
                ErrorReported = true;
                ERROR.NotImplemented("protocols within definitions");
                return false;
            }
            if ( !(enclosing is MODULE_DECL) && !(enclosing is OBJECT_DECL)&& !(enclosing is NAMESPACE_DECL) )
            {
                this.ErrorReported = true;
                ERROR.WrongPlaceForProtocol(this.sourceContext);
                return false;
            }
            resolve();
            if (!this.syntax.validate())
                return false;
            return true;
        }

        //------------------------------------------------------------------------------

        public override TYPE type  // evaluates "protocol type" which is actually
        {                          // the enumeration type of its keywords (not sure though...)
            get {
                if (internal_type == null)
                    internal_type = keywords;
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //------------------------------------------------------------------------------

        // convert
        // -------
        // protocol P = { terminal symbols,
        //                productions };
        //
        // Every protocol is mapped to a class derived from the RTL's Protocol base class:
        //
        // class P : Protocol
        // {
        //      public enum Keywords { terminal symbols };
        //
        //      protected override bool Test ( int textNumber, object obj )
        //      {
        //          switch ( testNumber ) { ... }
        //          return false;
        //      }
        //      public P ( activityType proc, bool runInPool ) : base ( proc )
        //      {
        //          // initialize the protocol syntax table
        //      }
        // }
        //
        public override Node convert() {
            if (node != null)
                return node;

         // resolve(); -- doesn't make sense
            if (!validate())
                return null;

            syntax.convert();

            TypeNode cls = new Class();  // Protocols are mapped to classes

            node = cls;
/*
            UNIT_DECL saved = CONTEXT.current_unit;
            CONTEXT.current_unit = this;
*/
         // cls.Attributes;
         // cls.BaseClass;
         // cls.BaseType;
         // cls.ClassSize;
            cls.DeclaringModule = CONTEXT.symbolTable;
            
            // Protocols can be standalone or local to objects or modules
            
            if (enclosing != null)
            {
                if (enclosing is NAMESPACE_DECL)  // global object
                    CONTEXT.symbolTable.Types.Add(cls);
                else  // local object
                    cls.DeclaringType = (TypeNode)enclosing.convertAndGetType();
            }

         // cls.ExplicitCoercionMethods;
            cls.Flags = TypeFlags.Sealed;
            if (enclosing is NAMESPACE_DECL)
            {
                if (modifiers.Public) cls.Flags |= TypeFlags.Public;
                else cls.Flags |= TypeFlags.NotPublic;
            }
            else
            {
                if (modifiers.Public) cls.Flags |= TypeFlags.NestedPublic;
                else cls.Flags |= TypeFlags.NestedPrivate;
            }
         // cls.FullName;
         // cls.HidesBaseClassMember;
         // cls.ImplicitCoercionMethods;
            cls.Members = new MemberList();

            // Generating enum declaration for keywords
            if ( keywords != null )
                cls.Members.Add((Member)keywords.convert());

            // Generating object constructor
            InstanceInitializer ctor = new InstanceInitializer();
            // Immediately initializing its fields, otherwise possible crash 
            // because of recursive call.
         // ctor.Attributes
         // ctor.Body.UniqueKey
         // ctor.CallingConvention;
            ctor.DeclaringType = cls;
         // ctor.Ensures;
         // ctor.ExceptionHandlers;
            ctor.Flags |= MethodFlags.Public | MethodFlags.SpecialName | MethodFlags.RTSpecialName;
            ctor.Flags |= MethodFlags.HideBySig;
            ctor.HasCompilerGeneratedSignature = false;
         // ctor.ImplementedInterfaceMethod;
         // ctor.ImplementedInterfaceMethods;
         // ctor.ImplementedTypes;
         // ctor.ImplFlags;
            ctor.InitLocals = true;
         //          ctor.Name = Identifier.For("_body"); // _"+base.name.Name);
         // ctor.NodeType;
         // ctor.Parameters = null; -- already generated
         // ctor.PInvokeFlags;
         // ctor.PInvokeImportName;
         // ctor.PInvokeModule;
         // ctor.Requires;
         // ctor.ReturnAttributes;
            ctor.ReturnType = SystemTypes.Void;
         // ctor.Scope;
            ctor.SourceContext = base.sourceContext;
         // ctor.Template;
         // ctor.TemplateArguments;
         // ctor.TemplateParameters;
         // ctor.UniqueKey;
            cls.Members.Add(ctor);

            // Generating ctor parameters: ( activityType proc, bool runInPool )

            ctor.Parameters = new ParameterList();

            Parameter par = new Parameter();

            par.Type = (TypeNode)STANDARD.activityType.type.convert();
            par.Name = Identifier.For("proc");
            par.Flags = ParameterFlags.In;
            ctor.Parameters.Add(par);

            par = new Parameter();

            par.Type = SystemTypes.Boolean;
            par.Name = Identifier.For("runInPool");
            par.Flags = ParameterFlags.In;
            ctor.Parameters.Add(par);

            // Generating ctor's body

            ctor.Body = new Block();

            ctor.Body.Checked = false;  // ???
            ctor.Body.HasLocals = false;  // ??????????????????????????
         // ctor.Body.NodeType;
            ctor.Body.Statements = new StatementList();

            // First generate base class ctor's invokation - for protocols, this is Protocol.
            // Also generate the call to its constructor: Protocol(proc) 
            // where proc is ctor's parameter.

            ((Class)cls).BaseClass = ((EXTERNAL_TYPE)STANDARD.protocol.type).entity as Class;

            ExpressionList actual = new ExpressionList();
            actual.Add(new Identifier("proc"));
            actual[0].Type = (TypeNode)STANDARD.activityType.type.convert();

            MethodCall superCtorCall =
                    new MethodCall(new QualifiedIdentifier(new Base(),StandardIds.Ctor),
                                   actual,
                                   NodeType.Call);

            ctor.Body.Statements.Add(new ExpressionStatement(superCtorCall));

            // Now continue generating class...

            cls.Name = base.name;
//          if ( enclosing != null && enclosing is NAMESPACE_DECL )
//              cls.Namespace = Identifier.For(NODE.generateFullName(enclosing));
         // cls.NodeType;
         // cls.OverridesBaseClassMember;
         // cls.PackingSize;
            cls.SourceContext = base.sourceContext;

            // Finally, generating constructor body:
            // protocol syntax table.
            this.generateProtocolSyntax(ctor.Body.Statements);

            // Generate Test overriding function
            cls.Members.Add(this.generateTestFunction(cls));

         // CONTEXT.current_unit = saved;

            //adding metadata
            InstanceInitializer ii = STANDARD.ZonnonAttribute.GetConstructor(SystemTypes.String);
            MemberBinding attrBinding = new MemberBinding(null, ii);
            ExpressionList args = new ExpressionList();
            args.Add(new Literal(protocolSpecification, SystemTypes.String));
            AttributeNode attrNode = new AttributeNode(attrBinding, args, AttributeTargets.All);
            cls.Attributes.Add(attrNode);

            return node;
        }

        private Method generateTestFunction ( TypeNode cls)
        {
            //   protected override bool Test(int testNumber, object obj)
            //   {
            //       switch (testNumber)
            //       {
            //       case 1: return (obj is KeyWords) && ((KeyWords)obj == KeyWords.START_TEXT);
            //   
            //      
            //       case 2: return obj is string; 
            //		 ...
            //       case 7: return (obj is int) && ((int)obj == 7883);
            //       ...
            //       }
            //       return false;
            //   }

            Method method = new Method();
            method.OverridesBaseClassMember = true;

            method.Body = new Block();
            method.Body.Checked = false;  // ???
            method.Body.HasLocals = true;

            method.Body.SourceContext = this.sourceContext;
            method.Parameters = new ParameterList(2);

            Parameter par;
            par = new Parameter();
            par.Type = (TypeNode) STANDARD.Integer.type.convert();
            par.Name = Identifier.For("testNumber");
            par.Flags = ParameterFlags.In;

            method.Parameters.Add(par);

            par = new Parameter();  
            par.Type = (TypeNode) STANDARD.Object.type.convert();
            par.Name = Identifier.For("obj");
            par.Flags = ParameterFlags.In;

            method.Parameters.Add(par);		
            method.Body.Statements = new StatementList();
            method.DeclaringType = cls;
            method.Flags = MethodFlags.Public | MethodFlags.Virtual | MethodFlags.CheckAccessOnOverride;
            method.CallingConvention = CallingConventionFlags.HasThis;
            method.InitLocals = true;
            // SWITCH ===============================================
			
            Switch swtch = new Switch();
            swtch.Cases = new SwitchCaseList();
            swtch.Expression = Identifier.For("testNumber");
            swtch.SourceContext = this.sourceContext;

            int numberOfTests =  syntax.testFunction.tests.Count;
			
            for (int i = 0; i < numberOfTests; i++) {
                //***************CASE
                TestFunctionGenerator.Test test = syntax.testFunction.tests[i] as TestFunctionGenerator.Test;
                Expression expr = new Literal(true, SystemTypes.Boolean, base.sourceContext);
                switch (test.type) {
                    case TestFunctionGenerator.TestType.TerminalTest: {
                        TypeNode tp = (TypeNode)test.enumerator.type.convert();

                        BinaryExpression op_is = new BinaryExpression();
                        op_is.NodeType = NodeType.Is; //inst;
                        op_is.SourceContext = this.sourceContext;
                        op_is.Operand1 = Identifier.For("obj");
                        op_is.Operand2 = new Literal(keywords.convert(), SystemTypes.Type, sourceContext);
                        op_is.Type = SystemTypes.Boolean;
                        
                        BinaryExpression casted_object =
                            new BinaryExpression(Identifier.For("obj"), tp.Name, NodeType.Castclass);

                        BinaryExpression equal = new BinaryExpression();
                        equal.Operand1 = casted_object;
                        equal.Operand2 = new QualifiedIdentifier(tp.Name, test.enumerator.name);
                        equal.NodeType = NodeType.Eq;
                        equal.Type = SystemTypes.Boolean;
                        equal.SourceContext = this.sourceContext;
                        
                        BinaryExpression and = new BinaryExpression();
                        // TODO: To think how to check the type
                        and.Operand1 = op_is; //new Literal(true, SystemTypes.Boolean, sourceContext);
                        and.Operand2 = equal;
                        and.NodeType = NodeType.LogicalAnd;
                        and.Type = SystemTypes.Boolean;
                        and.SourceContext = this.sourceContext;

                        expr = and; //and; 

                    }
                        break;

                    case TestFunctionGenerator.TestType.ConstantTest: {
                        BinaryExpression op_is = new BinaryExpression();
                        op_is.NodeType = NodeType.Is; //inst;
                        op_is.SourceContext = this.sourceContext;
                        op_is.Operand1 = Identifier.For("obj");
                        //	op_is.Operand2 = new Literal(test.enumerator.type.convert(),
                        //	SystemTypes.Type,test.enumerator.type.sourceContext);
                        //  string sname = ((System.Compiler.TypeNode)(((System.Compiler.Struct)(((test.literal.type.convert())))))).FullName;
                        //  op_is.Operand2 = Identifier.For(sname);
                        System.Compiler.Node tp = test.literal.type.convert();
                        op_is.Operand2 = new Literal(tp, SystemTypes.Type, test.literal.sourceContext);
                        op_is.Type = SystemTypes.Boolean;

                        BinaryExpression casted_object =
                            new BinaryExpression(Identifier.For("obj"), new MemberBinding(null, (System.Compiler.Member)tp), NodeType.Castclass);

                        BinaryExpression equal = new BinaryExpression();
                        equal.Operand1 = casted_object;
                        equal.Operand2 = (Literal)test.literal.convert();
                        equal.NodeType = NodeType.Eq;
                        equal.Type = SystemTypes.Boolean;
                        equal.SourceContext = this.sourceContext;

                        BinaryExpression and = new BinaryExpression();
                        and.Operand1 = op_is;
                        and.Operand2 = equal;
                        and.NodeType = NodeType.LogicalAnd;
                        and.Type = SystemTypes.Boolean;
                        and.SourceContext = this.sourceContext;
                        expr = and;				
                        break;
                    }
                    case TestFunctionGenerator.TestType.TypeTest: {
                        if (test.type_name == null) {
                            ERROR.UndeclaredProduction("type", sourceContext);
                            return null;
                        }
                        System.Compiler.TypeNode tp = test.type_name.convert() as TypeNode;

                        BinaryExpression op_is = new BinaryExpression();
                        op_is.NodeType = NodeType.Is; //inst;
                        op_is.SourceContext = this.sourceContext;
                        op_is.Operand1 = Identifier.For("obj");
                        op_is.Operand2 = new Literal(test.type_name.convert(),
                            SystemTypes.Type, test.type_name.sourceContext);
                        op_is.Type = SystemTypes.Boolean;

                        expr = op_is;

                        break;
                    }
                }

                Return cret = new Return(expr,this.sourceContext);
				
                SwitchCase cse = new SwitchCase();
                cse.Body  = new Block(new StatementList());
                cse.Body.Statements.Add(cret);
                cse.Label = new Literal((ushort)i+1, SystemTypes.UInt16, base.sourceContext);
                swtch.Cases.Add(cse);
            } // end of loop trough cases

            Return ret = new Return(new Literal(false, SystemTypes.Boolean, base.sourceContext),this.sourceContext);

            Block defaultBlock = new Block(new StatementList());
            defaultBlock.Statements.Add(ret);

            SwitchCase def = new SwitchCase();
            def.Body  = defaultBlock;
            def.Label = null;
            swtch.Cases.Add(def);

            method.Body.Statements.Add(swtch);

            // END OF SWITCH ========================================

            method.Name = Identifier.For("Test");
            method.ReturnType = (TypeNode) STANDARD.Boolean.type.convert();
            method.SourceContext = this.sourceContext;
            return method;
        }

        private void generateProtocolSyntax(StatementList stmts) {
            Statement statement;

            // createEBNF(<number of lines>);
            // ==============================
            // number of lines in table
            if (syntax == null)
                return;
            if (syntax.table == null)
                return;
            if (syntax.table.EBNF == null)
                return;
            int numberOfLines = syntax.table.EBNF.Length;
            MethodCall call = null;
            call = new MethodCall();
            call.Callee = Identifier.For("createEBNF");
            call.GiveErrorIfSpecialNameMethod = false; 
            call.IsTailCall = false;
            call.Operands = new ExpressionList(1);
            call.Operands.Add(new Literal((ushort)numberOfLines, SystemTypes.UInt16, base.sourceContext));
            statement = new ExpressionStatement(call);
            stmts.Add(statement);

            // setEBNFLine(<line>, <checkCode>, <terminal>, <receive>, <next>, <endNode>);
            // ============= int ====== int ======= bool ===== bool ==== int === bool ====
            // 

            for (int i = 0; i < numberOfLines; i++) {
                Literal line = new Literal(i, SystemTypes.Int32, base.sourceContext);
                Literal checkCode = new Literal(syntax.table.EBNF[i].checkCode, SystemTypes.Int32, base.sourceContext);
                Literal terminal = new Literal(syntax.table.EBNF[i].terminal, SystemTypes.Boolean, base.sourceContext);
                Literal receive = new Literal(syntax.table.EBNF[i].receive, SystemTypes.Boolean, base.sourceContext);
                Literal next = new Literal(syntax.table.EBNF[i].next, SystemTypes.Int32, base.sourceContext); 
                Literal endNode = new Literal(syntax.table.EBNF[i].endNode, SystemTypes.Boolean, base.sourceContext);

                call = new MethodCall();
                call.Callee = Identifier.For("setEBNFLine");
                call.GiveErrorIfSpecialNameMethod = false; 
                call.IsTailCall = false;
                call.Operands = new ExpressionList(1);
                call.Operands.Add(line);
                call.Operands.Add(checkCode);
                call.Operands.Add(terminal);
                call.Operands.Add(receive);
                call.Operands.Add(next);
                call.Operands.Add(endNode);
                statement = new ExpressionStatement(call);
                stmts.Add(statement);
            }
        }

        public override NODE findExcludingDefs(Identifier name) { return find(name); }

        //------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            string n = name!=null?name.ToString():"noname";

            if (this.modifiers.Public)
                System.Console.Write("PUBLIC ");
            else
                System.Console.Write("PRIVATE ");
            System.Console.Write("PROTOCOL DECLARATION {0}",n);
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("KEYWORDS: ");
            if ( keywords == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                keywords.report(shift+NODE.reportShift);
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("SYNTAX:");

            if ( syntax == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                syntax.report(shift+NODE.reportShift);
            }
        }

        public override void report_short() {
            System.Console.Write("PROTOCOL DECL {0}:{1}",unique,this.name.Name);
        }
#endif
    }

    // ================================================================================
    // 2 TYPES
    // ================================================================================

    // TYPE
    // ====
    // For all kinds of Zonnon types.
    // The nodes of type TYPE never exist in the program tree itself;
    // these node are only refered to by SIMPLE_DECLARATION nodes.
    //
    public abstract class TYPE : NODE {
        public TYPE ( ASTNodeType astNodeType) : base(astNodeType, null) { }

        public abstract override NODE resolve ( );
        
        public abstract override bool validate ( );
        public abstract override TYPE type { get; set; }
        public abstract override Node convert ( );

        public abstract bool checkVisibility ( SourceContext context );

#if DEBUG
        public abstract override void report ( int shift );
#endif
        //-----------------------------------------------------------------------

        public static TYPE evaluateTypeName(IDENT_LIST qualName, long width) {
            DESIGNATOR d = null;
            return evaluateTypeName(qualName,width,ref d);
        }

        public override string ToString() {
            return "<" + base.ASTNodeType.ToString() + " name = \"" + Name + "\"/>";
        }    

        public static TYPE evaluateTypeName(IDENT_LIST qualName, long width, ref DESIGNATOR d) {
            if (qualName == null)
                return null;

            if (qualName.Length == 1) {
                // Perhaps, a standard type? - INTEGER or REAL
                TYPE type = evaluateTypeName(qualName[0],width);
                if (type != null)
                    return type;
            }

            // Processing the non-standard (user-defined) type name

            DESIGNATOR entity = SELECTOR.processQualName(null,qualName);

            if (entity == null) {
                // Error: wrong entity as a type.
                ERROR.WrongTypeName(qualName.ToString());
                return null;
            }
            // We expect _object_ or _type_declaration_ as the name's "sort".

            DECLARATION type_decl = (DECLARATION)entity.resolve();

        Again:
            if (type_decl is TYPE_DECL || type_decl is OBJECT_DECL || type_decl is PROTOCOL_DECL) {
                // That's OK; taking type from type declaration.
                return type_decl.type;
            } else if (type_decl is IMPORT_DECL) {
                type_decl = ((IMPORT_DECL)type_decl).imported_unit;
                goto Again;
            } else if (type_decl is UNKNOWN_DECL) {
                // the type is unknown yet
                return UNKNOWN_TYPE.create(type_decl,Parser.LEXAN.getSourceContext());
            } else if (type_decl is ACTIVITY_DECL) {
                // the type is an activity type
                d = entity;
                return ((ACTIVITY_DECL)type_decl).type;
            } else {
                ERROR.WrongTypeName(qualName.ToString());
                return null;
            }
        }

        public static TYPE evaluateTypeName(Identifier stdName, long width) {
            const int DefaultCharWidth = 16;
            const int DefaultWidth = 32;
            const int DefaultRealWidth = 64;
            const int DefaultFixedWidth = 96;
            TYPE type;

            if (stdName.Name == "integer") {
                if (width == 0 || width == DefaultWidth)
                    type = STANDARD.Integer.type;   // Default value; use the standard type
                else
                    type = new INTEGER_TYPE(width); // Create the new integer type
            } else if (stdName.Name == "real") {
                if (width == 0 || width == DefaultRealWidth)
                    type = STANDARD.Real.type;
                else
                    type = new REAL_TYPE(width);
            } else if (stdName.Name == "fixed") {
                if (width == 0 || width == DefaultFixedWidth)
                    type = STANDARD.Fixed.type;
                else
                    type = new FIXED_TYPE(width);
            } else if (stdName.Name == "char") {
                if (width == 0 || width == DefaultCharWidth)
                    type = STANDARD.Char.type;
                else
                    type = new CHAR_TYPE(width);
            } else if (stdName.Name == "cardinal") {
                if (width == 0 || width == DefaultWidth)
                    type = STANDARD.Cardinal.type;
                else
                    type = new CARDINAL_TYPE(width);
            } else if (stdName.Name == "string") {
                if (width > 0)
                    ERROR.SuperfluousSize("string");
                type = STANDARD.String.type;
            } else if (stdName.Name == "set") {
                if (width == 0 || width == DefaultWidth)
                    type = STANDARD.Set.type;
                else
                    type = new SET_TYPE(width);
            } else if (stdName.Name == "range") {
                type = new RANGE_TYPE();
            } else if (stdName.Name == "boolean") {
                if (width > 0)
                    ERROR.SuperfluousSize("boolean");
                type = STANDARD.Boolean.type;
            } else if (stdName.Name == "object") {
                type = STANDARD.Object.type;
            } else if (stdName.Name == "Overflow") {
                if (width > 0)
                    ERROR.SuperfluousSize("Overflow");
                type = STANDARD.Overflow.type;
            } else if (stdName.Name == "ZeroDivision") {
                if (width > 0)
                    ERROR.SuperfluousSize("ZeroDivision");
                type = STANDARD.ZeroDivision.type;
            } else if (stdName.Name == "Cast") {
                if (width > 0)
                    ERROR.SuperfluousSize("Cast");
                type = STANDARD.CastError.type;
            } else if (stdName.Name == "NilReference") {
                if (width > 0)
                    ERROR.SuperfluousSize("NilReference");
                type = STANDARD.NullInstance.type;
            } else if (stdName.Name == "OutOfRange") {
                if (width > 0)
                    ERROR.SuperfluousSize("OutOfRange");
                type = STANDARD.RangeError_Std.type;
            } else if (stdName.Name == "UnmatchedCase") {
                if (width > 0)
                    ERROR.SuperfluousSize("UnmatchedCase");
                type = STANDARD.CaseError.type;
            } else if (stdName.Name == "ProtocolMismatch") {
                if (width > 0)
                    ERROR.SuperfluousSize("ProtocolMismatch");
                type = STANDARD.ProtocolMismatch.type;
            } else if (stdName.Name == "Read") {
                if (width > 0)
                    ERROR.SuperfluousSize("Read");
                type = STANDARD.ReadError.type;
            }
            // There is no need to process OBJECT standard type here,
            // because it is processed in parseType() being the keyword!
            //
            // else if ( stdName.Name == "OBJECT" )
            //     type = new INTERFACE();
              else {
                if (width > 0)
                    ERROR.SuperfluousSize(stdName.Name);
                return null;
            }
         // type.enclosing = null;
            type.modifiers = null;
            type.name = stdName;
         // type.sourceContext

            return type;
        }

        public static TYPE evaluateFormalType(int[] dimensions, TYPE elemType) {
            if ( dimensions.Length == 0 )
                return elemType;

            ARRAY_TYPE arrayType = null;
            TYPE  result = elemType;

            for (int i = 0; i < dimensions.Length; i++) {
                arrayType = new ARRAY_TYPE();

                arrayType.base_type = result;
             // arrayType.dimensions -- already initialized; remains unassigned!
                arrayType.enclosing = null;
             // arrayType.modifiers;
                arrayType.name = null;
             // arrayType.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor
                for (int j = 0; j < dimensions[i];j++ )
                    arrayType.dimensions.Add(null);  // one-dimensional array implicitly
                arrayType.isOpen = true;

                result = arrayType;
            }
            return result;
        }

        public static void addFormalTypeOfProcType(PROC_TYPE procedure_type, TYPE formal_type, bool reference_sign) {
            VARIABLE_DECL declaration = new PARAMETER_DECL(null,reference_sign);

            declaration.enclosing = procedure_type;
         // declaration.modifiers
            declaration.modifiers.Reference = reference_sign;  // it's not necessary!!
         // declaration.name
         // declaration.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor
            declaration.type = formal_type;

            procedure_type.parameters.Add(declaration);
        }

        // AssignmentCompatibility
        // -----------------------
        // Checks if two types are "assignment compatible".
        //
        public static EXPRESSION AssignmentCompatibility(TYPE left, TYPE right, EXPRESSION right_part, SourceContext context, bool isMathAndNotMathCompatible) {

            bool err = false;
            bool errArray = false;
            EXPRESSION res = AssignmentCompatibilityInternal(ref err, ref errArray, left, right, right_part, isMathAndNotMathCompatible);
                
            if (errArray) {
                ERROR.NonOpenArray(left.ToString(),context);
                return null;
            }
            if (err) {
                ERROR.AssignmentCompatibility(left.ToString(),right.ToString(),context);
                return null;
            }
            return res;
        }
        // The same as AssignmentCompatibility but gives different error message
        // the original error message is not so clear for procedure calles
        public static EXPRESSION AssignmentCompatibilityInProcedureCall(TYPE left, TYPE right, int argNumber, CALL call, EXPRESSION right_part, SourceContext context) {
            if (left == null || right == null) return null;
            bool err = false;
            bool errArray = false;
            bool isMathAndNotMathCompatible = false;
            EXPRESSION res = AssignmentCompatibilityInternal(ref err, ref errArray, left.resolve() as TYPE, right.resolve() as TYPE, right_part, 
                isMathAndNotMathCompatible);

            if (errArray) {
                ERROR.NonOpenArray(left.ToString(), call.sourceContext);
                return null;
            }
            if (err) {
                if(!call.ErrorReported)
                    ERROR.AssignmentCompatibilityInProcedureCall(left.type.ToString(), right.type.ToString(), (argNumber+1).ToString(), call.callee.Name, right_part.sourceContext.SourceText, right_part.sourceContext);
                call.ErrorReported = true;
                return null;
            }
            return res;
        }

        public static bool AssignmentCompatibilityS(TYPE left, TYPE right) {
            if (left == null || right == null)
                return false; // Wierd stuff not compatible 
            bool err = false;
            bool errArray = false;
            bool isMathAndNotMathCompatible = false;
            EXPRESSION res = AssignmentCompatibilityInternal(ref err,ref errArray,left.resolve() as TYPE,right.resolve() as TYPE,null,
                isMathAndNotMathCompatible);
            return !err;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="err"></param>
        /// <param name="errArray"></param>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="right_part"></param>
        /// <param name="isMathAndNotMathCompatible">If it is true, then array {IsMath} and usual array ARE assignment compatible; else - no</param>
        /// <returns></returns>
        public static EXPRESSION AssignmentCompatibilityInternal ( ref bool err, ref bool errArray,
                                                                    TYPE left, TYPE right, 
                                                                    EXPRESSION right_part,
                                                                    bool isMathAndNotMathCompatible) {
            EXPRESSION result = right_part;

            if (left == null || right == null)
                return null;
            if (left is UNKNOWN_TYPE || right is UNKNOWN_TYPE)
                return null; // error was detected before

            NODE right_decl = null;
            if (right_part != null)
                right_decl = right_part.resolve();

            if ( (right_part is INSTANCE || right_part is SELECTOR) && (right_decl is PROCEDURE_DECL ||
                ((right_decl is EXTERNAL_DECL ) && ((right_decl as EXTERNAL_DECL).entity.NodeType == NodeType.Method) )) &&
                 !(left is PROC_TYPE)) {
                int pars;
                if (right_decl is PROCEDURE_DECL)
                    pars = ((PROCEDURE_DECL)right_decl).paramCount;
                else
                    pars = ((right_decl as EXTERNAL_DECL).entity as System.Compiler.Method).Parameters.Length;
                if (pars == 0) {
                    // There is a _procedure_ in the right part of the assignment
                    // (or in return), but the left part is not of a procedure type.
                    // So we treat right part as a procedure CALL with no arguments!
                    if ( right_part != null )
                        result = BINARY.makeCall(right_part);
                } else {
                    // It's a procedure in the right part of the assignment/return;
                    // it has parameter(s) but it is used without actuals.
                    // It's only possible if left type is a procedure type but here
                    // it is not the case (see !(left is PROC_TYPE) condition above).
                    ERROR.MissingParameters(pars,right_part.sourceContext);
                    err = true;
                    return null;
                }
            }

            if (left == right)
                return result;

            if (right is ACTIVITY_TYPE) {
                ROUTINE_DECL act_right = ((ACTIVITY_TYPE)right).activity;

                if (left is ACTIVITY_TYPE) {
                    ROUTINE_DECL act_left  = ((ACTIVITY_TYPE)left).activity;
                    err = act_right.prototype != act_left;
                } else if (left is ABSTRACT_ACTIVITY_TYPE) {
                    DECLARATION protocolLeft  = ((ABSTRACT_ACTIVITY_TYPE)left).protocol;
                    DECLARATION protocolRight = ((ACTIVITY_DECL)act_right).prototype;
                    err = protocolLeft != protocolRight;
                } else {
                    // Something like x := a(); -- any type is accepatable
                    err = false;
                }
            } else if (right is ABSTRACT_ACTIVITY_TYPE) {
                if (left is ABSTRACT_ACTIVITY_TYPE) {
                    DECLARATION protocolLeft  = ((ABSTRACT_ACTIVITY_TYPE)left).protocol;
                    DECLARATION protocolRight = ((ABSTRACT_ACTIVITY_TYPE)right).protocol;
                    err = protocolLeft != protocolRight;
                }
                err = left is ACTIVITY_TYPE;
                // Otherwise something like x := a(); -- any type is accepatable
            } else if (left is RANGE_TYPE && right is RANGE_TYPE) {
                // That's OK; no extra checks.
            } else if (left is BOOLEAN_TYPE && right is BOOLEAN_TYPE) {
                // That's OK; no extra checks.
            } else if (left is INTEGER_TYPE && right is INTEGER_TYPE) {
                INTEGER_TYPE l = left as INTEGER_TYPE;
                INTEGER_TYPE r = right as INTEGER_TYPE;
                if (l.width < r.width)
                    err = true;
                if (l.width >= r.width && l.width < 32) {
                    // Operations for short types will return 32 bit values
                    if (!(right_part is DESIGNATOR) && right_part != null) // For designators it's not the problem
                    {
                        result = new TYPE_CONV(right_part, l);
                    }
                }
            } else if (left is CARDINAL_TYPE && right is CARDINAL_TYPE) {
                CARDINAL_TYPE l = left as CARDINAL_TYPE;
                CARDINAL_TYPE r = right as CARDINAL_TYPE;
                if (l.width < r.width)
                    err = true;
                if (l.width >= r.width && l.width < 32) {
                    // Operations for short types will return 32 bit values
                    if (!(right_part is DESIGNATOR) && right_part != null) // For designators it's not the problem
                    {
                        result = new TYPE_CONV(right_part, l);
                    }
                }
            } else if (left is INTEGER_TYPE && right is CARDINAL_TYPE)  // IS IT REALLY COMPATIBLE???
            {
                INTEGER_TYPE l = left as INTEGER_TYPE;
                CARDINAL_TYPE r = right as CARDINAL_TYPE;
                if (l.width < r.width)
                    err = true;
            } else if (left is REAL_TYPE && right is REAL_TYPE) {
                REAL_TYPE l = left as REAL_TYPE;
                REAL_TYPE r = right as REAL_TYPE;
                if (l.width < r.width) err = true;
                if (l.width > r.width && right_part != null)
                {
                    // It's OK from the Zonnon point of view, but CTS doesn't like
                    // conversions from "smaller" to "bigger" floating types.
                    // So we have to insert conversion.
                    result = new TYPE_CONV(right_part, l);
                }
            } else if (left is FIXED_TYPE && right is FIXED_TYPE) {
                FIXED_TYPE l = left as FIXED_TYPE;
                FIXED_TYPE r = right as FIXED_TYPE;
                if (l.width < r.width)
                    err = true;
            } else if (left is FIXED_TYPE && right is REAL_TYPE) {
                FIXED_TYPE l = left as FIXED_TYPE;
                REAL_TYPE r = right as REAL_TYPE;
                if (l.width < r.width)
                    err = true;
            }
            // else if ( left is REAL_TYPE && ( right is INTEGER_TYPE || right is CARDINAL_TYPE) )
            // {
            //     // Conversion from integer/cardinal to real...
            //     result = new TYPE_CONV(right_part,left);
            // }
              else if (left is STRING_TYPE) {
                if (right is EXTERNAL_TYPE) {
                    err = !(((EXTERNAL_TYPE)right).entity as Class == SystemTypes.String);
                } else
                    err = !(right is STRING_TYPE) && !(right_part is NULL);
            } else if (left is CHAR_TYPE) {
                if (right is CHAR_TYPE) {
                    CHAR_TYPE l = left as CHAR_TYPE;
                    CHAR_TYPE r = right as CHAR_TYPE;
                    if (l.width < r.width) err = true;
                    if (l.width > r.width && right_part != null)
                    {
                        // It's OK from the Zonnon point of view, but CTS doesn't like
                        // "widening" for some cases, in particular, for byte->char;
                        // so we should insert a conversion CHAR{8} -> CHAR{16} for the right part.
                        result = new TYPE_CONV(right_part, l);
                    }
                } else if (right is STRING_TYPE) {
                    // The only possible case: string literal of length 1.
                    if (right_part is STRING_LITERAL) {
                        string str = ((STRING_LITERAL)right_part).str;
                        if (str.Length == 1) {
                            // String literal of length 1 is treated here as character literal.
                            // One additional check: the left type should be assignment compatible
                            // with type of the element of standard string, i.e., it should be
                            // CHAR{16}.
                            if (((CHAR_TYPE)left).width != 16) {
                                // Replace STRING_TYPE for CHAR_TYPE for more adequate diagnostics
                                right = new CHAR_TYPE(16);
                                err = true;
                            } else // left width == 16
                            {
                                // Creating CHAR_LITERAL node and replace
                                // original STRING_LITERAL node in the tree.
                                result = CHAR_LITERAL.create(str[0], right_part.sourceContext);
                            }
                        } else
                            err = true;
                    }
                } else
                    err = true;
            } else if (left is SET_TYPE && right is SET_TYPE) {
                SET_TYPE l = left as SET_TYPE;
                SET_TYPE r = right as SET_TYPE;
                if (l.width < r.width)
                    err = true;
            } else if (left is ENUM_TYPE && right is ENUM_TYPE) {
                // Two enumeration types should be the same;
                // that is, their comparison should give true:
                // see left==right at the beginning of the function.
                // If they do not give true then they are either incompatible
                // or the "right part" is a call to a "generic" standard procedure.
                if (left.enclosing != null && left.enclosing.name != null && right.enclosing == null)
                // This is the second case; it's OK
                { } else
                    err = true;
            } else if (left is OBJECT_TYPE) {
                if (right is OBJECT_TYPE) {
                    OBJECT_TYPE l = left as OBJECT_TYPE;
                    OBJECT_TYPE r = right as OBJECT_TYPE;
                    if (l.ObjectUnit != r.ObjectUnit)
                        err = true;
                } else if (right is INTERFACE_TYPE)
                    // The only possible case: right is NIL.
                    err = !(right_part is NULL);
                else
                    err = true;
            } else if (left is INTERFACE_TYPE) {
                if (((INTERFACE_TYPE)left).interfaces.Length == 0) {
                    // This is just OBJECT type; it is compatible with ANY type.
                    // No actions.
                } else if (right is INTERFACE_TYPE) {
                    // Both INTERFACE_TYPEs should have the same set of DEFINITION_DECLs
                    INTERFACE_TYPE l = left as INTERFACE_TYPE;
                    INTERFACE_TYPE r = right as INTERFACE_TYPE;

                    if (right_part is NULL)
                        err = false;
                    else
                        err = !sameInterface(l.interfaces, r.interfaces);
                } else if (right is OBJECT_TYPE) {
                    // OBJECT_TYPE should implement all the definitions from the INTERFACE_TYPE
                    INTERFACE_TYPE l = left as INTERFACE_TYPE;
                    OBJECT_DECL u = (OBJECT_DECL)(((OBJECT_TYPE)right).ObjectUnit);

                    // err = !sameInterface(l.interfaces,u.definitions);
                    err = !compatibleInterface(l.interfaces, u.definitions);
                }
            } else if (left is ARRAY_TYPE) {
                if (right is ARRAY_TYPE) {
                    ARRAY_TYPE l = left as ARRAY_TYPE;
                    ARRAY_TYPE r = right as ARRAY_TYPE;
                    if (l.dimensions.Length != r.dimensions.Length)
                        err = true;
                    else if (!l.isOpen && (!l.isMath && !r.isMath))
                        errArray = true;  // Cannot assign to non-open arrays, if both arrays aren't IsMath!
                    else {
                        err = !sameType(l.base_type, r.base_type);
                        if (err) //try to find an overloaded ':='
                        {
                            ASSIGNMENT_OPERATOR assign_op = new ASSIGNMENT_OPERATOR(":=");
                            if (assign_op.findBestOpDeclForBinaryOperator(l.base_type, r.base_type) != null)
                                err = false;
                        }
                    }

                    if (!err) {
                        if ((l.const_dimensions != null) && (l.const_dimensions[0] != 0) && (r.const_dimensions[0] != 0)) //if both arrays are static, their lengths have to be the same
                        {
                            for (int i = 0; i < l.dimensions.Length; i++) {
                                if (l.const_dimensions[i] != r.const_dimensions[i])
                                    err = true;
                            }
                        }
                    }

                    if (!isMathAndNotMathCompatible) {
                        if (l.isMath && !r.isMath) { err = true; } else if (!l.isMath && r.isMath) { err = true; }
                    }
                } else if ((right is EXTERNAL_TYPE)
                    && (((EXTERNAL_TYPE)right).entity is ArrayType)) {
                    ARRAY_TYPE l = left as ARRAY_TYPE;
                    ArrayType r = ((EXTERNAL_TYPE)right).entity as ArrayType;
                    if (l.dimensions.Length != r.Rank)
                        err = true;
                    else if (!l.isOpen)
                        errArray = true;  // Cannot assign to non-open arrays!
                    else { // Same = Assignment compatible in both directions
                        TYPE rt = new EXTERNAL_TYPE(r.ElementType);
                        err = !AssignmentCompatibilityS(l.base_type, rt) ||
                              !AssignmentCompatibilityS(rt, l.base_type);
                    }

                } else if (!(right_part is NULL))
                    err = true;
                }
                ////////////////////////
              else if (left is SPARSE_TYPE) {
                if (right is SPARSE_TYPE) {
                    SPARSE_TYPE l = left as SPARSE_TYPE;
                    SPARSE_TYPE r = right as SPARSE_TYPE;
                    if (l.dimensions.Length != r.dimensions.Length)
                    err = true;
                    err = !sameType(l.base_type, r.base_type);
                    //if (err) //try to find an overloaded ':='
                    //{
                    //    ASSIGNMENT_OPERATOR assign_op = new ASSIGNMENT_OPERATOR(":=");
                    //    if (assign_op.findBestOpDeclForBinaryOperator(l.base_type, r.base_type) != null)
                    //        err = false;
                    //}

                    //if (!err)
                    //{
                    //    if ((l.const_dimensions != null) && (l.const_dimensions[0] != 0) && (r.const_dimensions[0] != 0)) //if both arrays are static, their lengths have to be the same
                    //    {
                    //        for (int i = 0; i < l.dimensions.Length; i++)
                    //        {
                    //            if (l.const_dimensions[i] != r.const_dimensions[i])
                    //                err = true;
                    //        }
                    //    }
                    //}
                } else if (!(right_part is NULL))
                    err = true;
            }
                /////////////////////////
              else if (left is PROC_TYPE) {
                // Right part should be a procedure or a varable of a procedure type
                if (right is PROC_TYPE) {
                    // Check the matching...
                    err = !sameProcType((PROC_TYPE)left, (PROC_TYPE)right);
                } else if (right is INTERFACE_TYPE) {
                    // The only possible case: 'right' is NIL.
                    // Here we have to consider the _value_ but not _type_...
                    err = !(right_part is NULL);
                } else if (right_part != null) {
                    NODE res = right_part.resolve();
                    if (res is PROCEDURE_DECL) {
                        PROCEDURE_DECL procedure = res as PROCEDURE_DECL;
                        err = !sameProcType((PROC_TYPE)left, procedure);

                        // This is not a procedure call, so we should build a prototype
                        // for 'new Delegate(Procedure)' construct instead of the instance
                        // of the 'Procedure'.

                        // Check if we assign procedure for value type
                        // give warning if it is so
                        OBJECT_DECL enclobject = procedure.enclosing as OBJECT_DECL;
                        if (enclobject != null) {
                            if (enclobject.modifiers.Value)
                                ERROR.DelegateForMethodOfValueObject(procedure.name.Name, enclobject.sourceContext);
                        }

                        if (err) {
                            // To issue the adequate diagnostics
                            PROC_TYPE proc = new PROC_TYPE();
                            proc.parameters = ((PROCEDURE_DECL)res).parameters;
                            proc.return_type = right;
                            right = proc;
                        } else {
                            if (!procedure.IsStatic()) {   //For not static procedures create a delegate
                                NEW new_delegate = new NEW();
                                new_delegate.resolved_new_type = left;
                                new_delegate.arguments.Add(result);
                                new_delegate.sourceContext = result.sourceContext;
                                result = new_delegate;
                            }
                        }
                    } else
                        err = true;
                } else
                    err = true;
            } else if (left is EXTERNAL_TYPE) {
                TypeNode left_type_no_ref = (TypeNode)((EXTERNAL_TYPE)left).entity;
                //Remove reference if present
                if (left_type_no_ref is Reference)
                    left_type_no_ref = ((Reference)left_type_no_ref).ElementType;

                if (right is EXTERNAL_TYPE) {
                    TypeNode mrt = (TypeNode)((EXTERNAL_TYPE)right).entity;
                    do {
                        err = left_type_no_ref != mrt;
                        mrt = mrt.BaseType;
                    } while (err == true && mrt != null);


                    if (err) //Try if it is simple numeric type
                    {
                        TypeNode rtype = (TypeNode)((EXTERNAL_TYPE)right).entity;
                        TypeNode ltype = left_type_no_ref;

                        if (rtype.TypeCode != TypeCode.Object
                            && rtype.TypeCode != TypeCode.Empty
                            && rtype.TypeCode == ltype.TypeCode)
                            err = false;
                        else if (rtype.TypeCode == TypeCode.Int16)
                            err = !(ltype.TypeCode == TypeCode.Int32)
                                && !(ltype.TypeCode == TypeCode.Int64);
                        else if (rtype.TypeCode == TypeCode.Int32)
                            err = !(ltype.TypeCode == TypeCode.Int64)
                                //Allow assigning Int32 to Enumerations
                                //TODO: Better analysis is needed
                                && !(ltype.NodeType == NodeType.EnumNode);
                        else if (rtype.TypeCode == TypeCode.UInt16)
                            err = !(ltype.TypeCode == TypeCode.Int16)
                                && !(ltype.TypeCode == TypeCode.Int32)
                                && !(ltype.TypeCode == TypeCode.Int64)
                                && !(ltype.TypeCode == TypeCode.UInt32)
                                && !(ltype.TypeCode == TypeCode.UInt64);
                        else if (rtype.TypeCode == TypeCode.UInt32)
                            err = !(ltype.TypeCode == TypeCode.UInt64);
                        else if (rtype.TypeCode == TypeCode.Single)
                            err = !(ltype.TypeCode == TypeCode.Double);
                        else if (rtype.TypeCode == TypeCode.Decimal)
                            err = !(ltype.TypeCode == TypeCode.Double);
                        else if (rtype.TypeCode == TypeCode.SByte)
                            err = !(ltype.TypeCode == TypeCode.Int16)
                                && !(ltype.TypeCode == TypeCode.Int32)
                                && !(ltype.TypeCode == TypeCode.Int64);
                        else if (rtype.TypeCode == TypeCode.Byte)
                            err = !(ltype.TypeCode == TypeCode.Int16)
                                && !(ltype.TypeCode == TypeCode.Int32)
                                && !(ltype.TypeCode == TypeCode.Int64)
                                && !(ltype.TypeCode == TypeCode.UInt16)
                                && !(ltype.TypeCode == TypeCode.UInt32)
                                && !(ltype.TypeCode == TypeCode.UInt64);
                else
                            err = true;
                    }
                } else {
                    TypeNode lt = left_type_no_ref;
                    if (lt is Class && right_part is NULL) err = false;
                    else if (lt.TypeCode == TypeCode.Object) {
                        if (lt == SystemTypes.Object)
                        {
                            err = false; // Everything can be assigned to an object
                        }
                        else
                        if (right is OBJECT_TYPE)
                        {
                            // This object must be inherited by the objct on the right as definition
                            OBJECT_TYPE robj = (OBJECT_TYPE)right;
                            OBJECT_DECL objdecl = robj.objectUnit as OBJECT_DECL;
                            if (objdecl != null)
                            {
                                for (int k = 0, n = objdecl.definitions.Length; k < n; k++)
                                {
                                    if (objdecl.definitions[k] is EXTERNAL_DECL)
                                    {
                                        EXTERNAL_DECL edef = objdecl.definitions[k] as EXTERNAL_DECL;
                                        TypeNode type = edef.entity as TypeNode;
                                        if (type != null && type.IsAssignableTo(lt)) err = false;
                                    }
                                }
                            }
                        }else
                            err = true; 
                    } 
                    else if (lt.TypeCode == TypeCode.String) err = !(right is STRING_TYPE);
                    else if (lt.TypeCode == TypeCode.Int16)
                        err = !(right is INTEGER_TYPE &&
                        ((INTEGER_TYPE)right).width <= 16)
                        &&
                        !(right is CARDINAL_TYPE &&
                        ((CARDINAL_TYPE)right).width <= 16);
                    else if (lt.TypeCode == TypeCode.Int32)
                        err = !(right is INTEGER_TYPE &&
                        ((INTEGER_TYPE)right).width <= 32)
                        &&
                        !(right is CARDINAL_TYPE &&
                        ((CARDINAL_TYPE)right).width <= 32);
                    else if (lt.TypeCode == TypeCode.Int64)
                        err = !(right is INTEGER_TYPE &&
                        ((INTEGER_TYPE)right).width <= 64)
                        &&
                        !(right is CARDINAL_TYPE &&
                        ((CARDINAL_TYPE)right).width <= 64);
                    else if (lt.TypeCode == TypeCode.UInt16)
                        err = !(right is CARDINAL_TYPE &&
                        ((CARDINAL_TYPE)right).width <= 16);
                    else if (lt.TypeCode == TypeCode.UInt32)
                        err = !(right is CARDINAL_TYPE &&
                        ((CARDINAL_TYPE)right).width <= 32);
                    else if (lt.TypeCode == TypeCode.UInt64)
                        err = !(right is CARDINAL_TYPE &&
                        ((CARDINAL_TYPE)right).width <= 64);
                    else if (lt.TypeCode == TypeCode.Single)
                        err = !(right is REAL_TYPE &&
                        ((REAL_TYPE)right).width <= 32);
                    else if (lt.TypeCode == TypeCode.Double)
                        err = !(right is REAL_TYPE &&
                        ((REAL_TYPE)right).width <= 64);
                    else if (lt.TypeCode == TypeCode.Decimal)
                        err = !(right is REAL_TYPE) && !(right is FIXED_TYPE);
                    else if (lt.TypeCode == TypeCode.Boolean)
                        err = !(right is BOOLEAN_TYPE);
                    else if (lt.TypeCode == TypeCode.SByte) {
                        err = !(right is INTEGER_TYPE) && !(right is CARDINAL_TYPE);
                        if (!err) {
                            long w;
                            if (right is INTEGER_TYPE)
                                w = ((INTEGER_TYPE)right).width;
                            else
                                w = ((CARDINAL_TYPE)right).width;
                            err = w > 8;
                        }
                    } else if (lt.Name.Name == "Byte") {
                        err = !(right is CARDINAL_TYPE);
                        if (!err) {
                            long w = ((CARDINAL_TYPE)right).width;
                            err = w > 8;
                        }
                    } else
                        err = true;
                    }
            } else if (right is EXTERNAL_TYPE) {
                // Here left /= EXTERNAL_TYPE, see the previous else if

                if (((EXTERNAL_TYPE)right).entity is TypeNode) {
                    TypeNode rt = (TypeNode)((EXTERNAL_TYPE)right).entity;
                    if (rt.Name.Name == "String")
                        err = !(left is STRING_TYPE);
                    else if (rt.Name.Name == "SByte")
                        err = !(left is INTEGER_TYPE);
                    else if (rt.Name.Name == "Byte")
                        err = !(left is CARDINAL_TYPE) && !(left is INTEGER_TYPE);
                    else if (rt.Name.Name == "UInt16") {
                        err = !(left is CARDINAL_TYPE) && !(left is INTEGER_TYPE);
                        if (!err) {
                            long w;
                            if (left is INTEGER_TYPE)
                                w = ((INTEGER_TYPE)left).width;
                            else
                                w = ((CARDINAL_TYPE)left).width;
                            err = w < 16;
                        }
                    } else if (rt.Name.Name == "Int16")
                        err = !(left is INTEGER_TYPE) || ((INTEGER_TYPE)left).width < 16;
                    else if (rt.Name.Name == "Int32")
                        err = !(left is INTEGER_TYPE) || ((INTEGER_TYPE)left).width < 32;
                    else if (rt.Name.Name == "Int64")
                        err = !(left is INTEGER_TYPE) || ((INTEGER_TYPE)left).width < 64;
                    else if (rt.Name.Name == "UInt32") {
                        err = !(left is CARDINAL_TYPE) && !(left is INTEGER_TYPE);
                        if (!err) {
                            long w;
                            if (left is INTEGER_TYPE)
                                w = ((INTEGER_TYPE)left).width;
                            else
                                w = ((CARDINAL_TYPE)left).width;
                            err = w < 32;
                        }
                    } else if (rt.Name.Name == "UInt64") {
                        err = !(left is CARDINAL_TYPE) && !(left is INTEGER_TYPE);
                        if (!err) {
                            long w;
                            if (left is INTEGER_TYPE)
                                w = ((INTEGER_TYPE)left).width;
                            else
                                w = ((CARDINAL_TYPE)left).width;
                            err = w < 64;
                        }
                    } else if (rt.Name.Name == "Single")
                        err = !(left is REAL_TYPE);
                    else if (rt.Name.Name == "Double")
                        err = !(left is REAL_TYPE) || ((REAL_TYPE)left).width <= 32;
                    else if (rt.Name.Name == "Decimal") {
                        err = !(left is REAL_TYPE) && !(left is FIXED_TYPE);
                        if (!err) {
                            long w;
                            if (left is REAL_TYPE)
                                w = ((REAL_TYPE)left).width;
                            else
                                w = ((FIXED_TYPE)left).width;
                            err = w < 64;
                        }
                    } else if (rt.Name.Name == "Boolean")
                        err = !(left is BOOLEAN_TYPE);
                else
                        err = true;
                } else {
                    // Probably there is a method on the right side
                    // TO DO: Not sure with this case... 
                    if (((EXTERNAL_TYPE)right).entity is Method) {
                        Method m = (Method)((EXTERNAL_TYPE)right).entity;
                        if (
                            (left is PROC_TYPE) &&
                            (true /* TO DO: Put signature check here */)
                            )
                            err = false;
                    else
                            err = true;
                    } else {
                        ERROR.NotImplemented("This case of assignment compatibility check");
                    }
                }
            }
            // All other types are assignment incompatible
            else
                err = true;

            return result;
        }

        /// <summary>
        /// Returns true if conversion from t3 to t1 exists and is better (closer) than the conversion from t3 to t2
        /// Call this only if both conversions exist.
        /// </summary>
        public static bool IsBetterMatch(TYPE t1, TYPE t2, TYPE t3) {
            if (t2 == null || t2 == null)
                return true; //null always loses
            if (t1 == null || t1 == t2)
                return false;
            if (t1 == t3)
                return true; //t2 is different from t3 while t1 == t3, so t1 must be a better match
            if (t2 == t3)
                return false; //t1 is different from t3, while t2 == t3, so t1 cannot be a better match
            //t3 can go to t1 and t2 only via conversions. Try to establish which conversion is better (closer).
            bool t1tot2 = AssignmentCompatibilityS( t2, t1);
            bool t2tot1 = AssignmentCompatibilityS (t1, t2);
            if (t1tot2 && !t2tot1)
                return AssignmentCompatibilityS(t1, t3); //Can get from t3 to t2 via t1, but can't get from t3 to t1 via t2, so t3 is closer to t1
            if (t2tot1 && !t1tot2)
                return AssignmentCompatibilityS(t2, t3); //Get get from t3 to t1 via t2, but can't get from t3 to t2 via t1, so t2 is closer to t1            

            return false;
        }

        // sameType
        // --------
        //
        public static bool sameType(TYPE t1, TYPE t2) {
            if (t1 == t2)
                return true;

            if (t1 is UNKNOWN_TYPE)
                t1 = (TYPE)t1.resolve();
            if (t2 is UNKNOWN_TYPE)
                t2 = (TYPE)t2.resolve();

            if (t1 is UNKNOWN_TYPE && t2 is UNKNOWN_TYPE) {
                UNKNOWN_TYPE u1 = (UNKNOWN_TYPE)t1;
                UNKNOWN_TYPE u2 = (UNKNOWN_TYPE)t2;
                return u1.unknown == u2.unknown;
            }
            if (t1 is VOID_TYPE && t2 is VOID_TYPE) {
                return true;
            }
            if (t1 is BOOLEAN_TYPE && t2 is BOOLEAN_TYPE) {
                return true;
            }
            if (t1 is INTEGER_TYPE && t2 is INTEGER_TYPE) {
                return ((INTEGER_TYPE)t1).width == ((INTEGER_TYPE)t2).width;
            } else if (t1 is CARDINAL_TYPE && t2 is CARDINAL_TYPE) {
                return ((CARDINAL_TYPE)t1).width == ((CARDINAL_TYPE)t2).width;
            } else if (t1 is REAL_TYPE && t2 is REAL_TYPE) {
                return ((REAL_TYPE)t1).width == ((REAL_TYPE)t2).width;
            } else if (t1 is SET_TYPE && t2 is SET_TYPE) {
                return ((SET_TYPE)t1).width == ((SET_TYPE)t2).width;
            } else if (t1 is OBJECT_TYPE && t2 is OBJECT_TYPE) {
                return ((OBJECT_TYPE)t1).ObjectUnit == ((OBJECT_TYPE)t2).ObjectUnit;
            } else if (t1 is INTERFACE_TYPE && t2 is INTERFACE_TYPE) {
                INTERFACE_TYPE l = t1 as INTERFACE_TYPE;
                INTERFACE_TYPE r = t2 as INTERFACE_TYPE;
                return sameInterface(l.interfaces,r.interfaces);
            } else if (t1 is ARRAY_TYPE && t2 is ARRAY_TYPE) {
                ARRAY_TYPE l = t1 as ARRAY_TYPE;
                ARRAY_TYPE r = t2 as ARRAY_TYPE;
                if (l.dimensions.Length != r.dimensions.Length)
                    return false;
                if (!sameType(l.base_type, r.base_type))
                    return false;
                return true;
            } else if (t1 is PROC_TYPE && t2 is PROC_TYPE) {
                return sameProcType((PROC_TYPE)t1,(PROC_TYPE)t2);
            } else if (t1 is EXTERNAL_TYPE && t2 is EXTERNAL_TYPE) {
                return (t1 as EXTERNAL_TYPE).entity == (t2 as EXTERNAL_TYPE).entity;
            }
            // All other types are not the same
            return false;
        }

        // sameTypeForCase
        // ---------------
        //
        public static bool sameTypeForCase(TYPE caseType, TYPE mainType) {
            if (caseType == mainType)
                return true;  // CHAR_TYPEs are here

            if (caseType is UNKNOWN_TYPE)
                caseType = (TYPE)caseType.resolve();
            if (mainType is UNKNOWN_TYPE)
                mainType = (TYPE)mainType.resolve();

            if (caseType is INTEGER_TYPE && mainType is INTEGER_TYPE)
                return true;
            else if (caseType is CARDINAL_TYPE && mainType is CARDINAL_TYPE)
                return true;
            else if (caseType is CARDINAL_TYPE && mainType is INTEGER_TYPE)
                return true;

            // All other types are not legal for case statement
            return false;
        }

        // sameInterface
        // -------------
        // Checks whether two lists contain the same set of DEFINITION_DECLs.
        //
        private static bool sameInterface(UNIT_DECL_LIST l, UNIT_DECL_LIST r) {
            UNIT_DECL_LIST ll = reduceRelatedDefinitions(l);
            UNIT_DECL_LIST rr = reduceRelatedDefinitions(r);

            int L = ll.Length;
            if (L != rr.Length)
                return false;

            for (int i = 0; i < L; i++) {
                UNIT_DECL d = ll[i];
                for ( int j=0; j<L; j++ )
                    if ( (d == rr[j]) ||
                        ((d is DEFINITION_DECL) &&
                        (rr[j] is DEFINITION_DECL) && (((DEFINITION_DECL)(rr[j])).refines((DEFINITION_DECL)d)))
                        )
                        goto Exit;
                return false;
            Exit:
                continue;
            }
            return true;
        }

        // compatibleInterfaces
        // --------------------
        // Checks whether the second list of definition contains 
        // all definitions from the first list.
        //
        private static bool compatibleInterface(UNIT_DECL_LIST l, UNIT_DECL_LIST r) {
            UNIT_DECL_LIST ll = reduceRelatedDefinitions(l);
            UNIT_DECL_LIST rr = reduceRelatedDefinitions(r);

            for (int i = 0; i < ll.Length; i++) {
                UNIT_DECL d = (UNIT_DECL)ll[i].resolve();
                for (int j = 0; j < rr.Length; j++) {
                    NODE rrr = rr[j].resolve();
                    if (d == rrr)
                        goto Exit;
                    if ( d is DEFINITION_DECL && rrr is DEFINITION_DECL )
                        if ( d == (rrr as DEFINITION_DECL).base_definition )
                            goto Exit;
                }
                return false;
            Exit:
                continue;
            }
            return true;
        }

        // reduceRelatedDefinitions
        // ------------------------
        // The function looks through the list of definitions and builds
        // the "pure" subset: this subset doesn't contain definitions which
        // are refined by other definitions from the original list.
        //
        // Example:
        //            DEFINITION d1;            ... END d1.
        //            DEFINITION d2 REFINES d1; ... END d2.
        //
        // For the set { d1, d2 } the resulting set is { d2 } because d1 is
        // REFINEd by d2 (and therefore, is "hidden" by d2).
        //
        // The function is used in sameInterface() function.
        //
        private static UNIT_DECL_LIST reduceRelatedDefinitions(UNIT_DECL_LIST defs) {
            int L = defs.Length;
            UNIT_DECL_LIST res = new UNIT_DECL_LIST();

            for ( int i=0; i<L; i++ )
            {
                if ( defs[i] is UNKNOWN_DECL ) defs[i] = (UNIT_DECL)defs[i].resolve();
                if (defs[i] is UNKNOWN_DECL)
                {
                    res.Add(defs[i]); // Keep unknown
                    continue;
                }
                if ( !(defs[i] is DEFINITION_DECL) ) continue;
                DEFINITION_DECL u = defs[i] as DEFINITION_DECL;

                for (int j = 0; j < L; j++) {
                    if (u == defs[j])
                        continue;
                    DEFINITION_DECL def = defs[j] as DEFINITION_DECL;
                    if (def == null)
                        continue;  // def[j] is UNKNOWN_DECL; what to do???
                    if (def.refines(u))
                        goto Exit; // 'u' is refined; don't put it to the resulting list
                }
                // No other definition does not refine 'u'; put it to the list
                res.Add(u);
            Exit:
                continue;
            }
            return res;
        }

        private static bool sameProcType(PROC_TYPE procType1, PROC_TYPE procType2) {
            if (!sameType(procType1.return_type, procType2.return_type))
                return false;
            if (procType1.parameters.Length != procType2.parameters.Length)
                return false;

            for (int i = 0, n = procType1.parameters.Length; i < n; i++) {
                VARIABLE_DECL par1 = procType1.parameters[i];
                VARIABLE_DECL par2 = procType2.parameters[i];
                if (!sameType(par1.type, par2.type))
                    return false;
                if (((PARAMETER_DECL)par1).Reference != ((PARAMETER_DECL)par2).Reference)
                    return false;
            }
            return true;
        }

        public static bool sameProcType(PROC_TYPE procType, PROCEDURE_DECL procedure) {
            if (!sameType(procType.return_type, procedure.return_type))
                return false;
            if (procType.parameters.Length != procedure.paramCount)
                return false;

            for (int i = 0; i < procedure.paramCount; i++) {
                VARIABLE_DECL par1 = procType.parameters[i];
                VARIABLE_DECL par2 = procedure.parameters[i];
                if (!sameType(par1.type, par2.type))
                    return false;
                if (((PARAMETER_DECL)par1).Reference != ((PARAMETER_DECL)par2).Reference)
                    return false;
            }
            return true;
        }

        public static bool sameProc(PROCEDURE_DECL proc1, PROCEDURE_DECL proc2) {
            return sameProc(proc1 as ROUTINE_DECL,proc2 as ROUTINE_DECL);
        }

        public static bool sameProc(ROUTINE_DECL r1, ROUTINE_DECL r2) {
            if (!sameType(r1.return_type, r2.return_type))
                return false;
            if (r1.paramCount != r2.paramCount)
                return false;

            for (int i = 0; i < r1.paramCount; i++) {
                VARIABLE_DECL par1 = r1.parameters[i];
                VARIABLE_DECL par2 = r2.parameters[i];
                if (par1 == null || par2 == null) return false;
                if ( !sameType(par1.type,par2.type) ) return false;
                if ( ((PARAMETER_DECL)par1).Reference != ((PARAMETER_DECL)par2).Reference ) return false;
            }
            return true;
        }

        public static TYPE convertToZonnon(EXTERNAL_TYPE t) {
            Node external = t.entity;
            if (external is Struct) {
                if (external as Struct == SystemTypes.Int8)
                    return new INTEGER_TYPE(8);
                if (external as Struct == SystemTypes.Int16)
                    return new INTEGER_TYPE(16);
                if (external as Struct == SystemTypes.Int32)
                    return new INTEGER_TYPE(32);
                if (external as Struct == SystemTypes.Int64)
                    return new INTEGER_TYPE(64);
                if (external as Struct == SystemTypes.Double)
                    return new REAL_TYPE(64);
                if (external as Struct == SystemTypes.Single)
                    return new REAL_TYPE(32);
                if (external as Struct == SystemTypes.Char)
                    return new CHAR_TYPE(16);
                if (external as Struct == SystemTypes.Boolean)
                    return new BOOLEAN_TYPE();
                if (external as Struct == SystemTypes.String)
                    return new STRING_TYPE();
            } else {
                string name = (external as TypeNode).FullName;
                if (name == "System.Byte")
                    return new CARDINAL_TYPE(8);
                else
                    if (name == "System.SBtype")
                        return new INTEGER_TYPE(8);
                    else
                        if (name == "System.Int16")
                            return new INTEGER_TYPE(16);
                        else
                            if (name == "System.Int32")
                                return new INTEGER_TYPE(32);
                            else
                                if (name == "System.Int64")
                                    return new INTEGER_TYPE(64);
                                else
                                    if (name == "System.UInt16")
                                        return new CARDINAL_TYPE(16);
                                    else
                                        if (name == "System.UInt32")
                                            return new CARDINAL_TYPE(32);
                                        else
                                            if (name == "System.UInt64")
                                                return new CARDINAL_TYPE(64);
                                            else
                                                if (name == "System.Double")
                                                    return new REAL_TYPE(32);
                                                else
                                                    if (name == "System.Single")
                                                        return new REAL_TYPE(64);
                                                    else
                                                        if (name == "System.Boolean")
                                                            return new BOOLEAN_TYPE();
                                                        else
                                                            if (name == "System.Decimal")
                                                                return new FIXED_TYPE();
                                                            else
                                                                if (name == "System.String")
                                                                    return new STRING_TYPE(); /* else
                    if (external is Class)
                    {
                        OBJECT_TYPE cls = new OBJECT_TYPE();
                        cls.name = new QualifiedIdentifier(
                            new Identifier(name.Substring(0, name.IndexOf('+'))),
                            new Identifier(name.Substring(name.IndexOf('+')+1))
                            );                        
                        return cls;
                    }
                */
            }
            return t; //null; // t; -- to prevent infinite loop!.. TO DO: import problem
        }
    }

    // ANY_TYPE
    // =======
    // For generic functions which take parameters
    // of different possible types and/or return values
    // of different types.
    //
    public sealed class ANY_TYPE : TYPE {
        // Constructors
        public ANY_TYPE ( )        : base(ASTNodeType.ANY_TYPE) { }

        //-----------------------------------------------------

        public override NODE resolve ( )  { return this; }

        //-----------------------------------------------------

        public override bool validate ( ) { return true; }   // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            // resolve();
            // if ( !validate() ) return null;

            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return "any"; }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("GENERIC TYPE");
            report_extra();
        }
#endif
    }

    // UNKNOWN_TYPE
    // ============
    // For type which is not known yet (we know only its name):
    //
    // MODULE m1;
    //    IMPORT m2, obj;
    //    VAR x : m2.T; -- unknown type from m2 unit or namespace
    //        y : obj;  -- unknown object type
    //        z : T;    -- unknown type which should be declared later in this unit
    // END m.
    //
    // If a type is not known yet then the only thing we know about it
    // is its name (perhaps, dotted name). After processing the type name
    // the corresponding UNKNOWN_DECL will be created;
    // 'unknown' field just contains a reference to such a node node.
    //
    // More detailed:
    //
    // - If type has simple name which is not mentioned in IMPORT
    //   (hence this name denotes a local type name) and is not declared,
    //   then 'unknown' field contains a reference to an UNKNOWN_DECL node.
    //
    // - If type has a name (either simple or dotted) which is declared
    //   as IMPORTed and refers to an UNKNOWN_DECL then 'unknown' field
    //   just contains the reference to this UNKNOWN_DECL node.
    //
    public sealed class UNKNOWN_TYPE : TYPE {
        // Constructor
        public UNKNOWN_TYPE ( ) : base(ASTNodeType.UNKNOWN_TYPE) { }
        public UNKNOWN_TYPE(DECLARATION d)
            : base(ASTNodeType.UNKNOWN_TYPE) { resolutionType = Kind.Ordinary; unknown = d; real_type = null; }
        public UNKNOWN_TYPE(INDEXER ind)
            : base(ASTNodeType.UNKNOWN_TYPE) { resolutionType = Kind.Indexer; indexer = ind; real_type = null; }

        //-------------------------------------------------------------------------------------
        enum Kind { Indexer, Ordinary}
        
        private Kind resolutionType;

        public DECLARATION unknown;
        public TYPE        real_type;
        public INDEXER    indexer;

        //-----------------------------------------
        

        public static UNKNOWN_TYPE create(DECLARATION tp, SourceContext ctx) {
            UNKNOWN_TYPE ut = new UNKNOWN_TYPE(tp);
            ut.sourceContext = ctx;
            return ut;
        }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            if (resolutionType == Kind.Ordinary) {
                // If real_type exists then we have already done resolution
                if (real_type != null)
                    return real_type;

                // Extra action to prevent recursion in resolve() below...
                if (unknown is UNKNOWN_DECL && ((UNKNOWN_DECL)unknown).RealDeclaration != null)
                {
                    DECLARATION real = ((UNKNOWN_DECL)unknown).RealDeclaration;
                    if (!(real is TYPE_DECL) && !(real is OBJECT_DECL) && !(real is EXTERNAL_DECL) && !(real is IMPORT_DECL) && !(real is PROTOCOL_DECL)) {
                        if (!this.ErrorReported) {
                            ERROR.NoType(this.sourceContext, "declaration");
                            this.ErrorReported = true;
                        }
                        return this;
                    }
                }
                if(unknown is UNKNOWN_DECL)
                    unknown = (DECLARATION)unknown.resolve();
                if (unknown != null && (unknown is TYPE_DECL || unknown is OBJECT_DECL || unknown is EXTERNAL_DECL
                        || unknown is PROTOCOL_DECL || unknown is ACTIVITY_DECL))
                // Perhaps, resolution was successfull
                {
                    if (unknown is EXTERNAL_DECL)
                        real_type = EXTERNAL_TYPE.create(((EXTERNAL_DECL)unknown).entity);
                    else
                        real_type = unknown.type;

                    if (real_type != null) // Yes, it was successfull
                    {
                        unknown = null;
                        return real_type;
                    }
                } else if (unknown != null && (unknown is IMPORT_DECL) && (((IMPORT_DECL)unknown).imported_unit != null)) {
                    real_type = ((IMPORT_DECL)unknown).imported_unit.type;
                    if (real_type != null) // Yes, it was successfull
                    {
                        unknown = null;
                        return real_type;
                    }
                }
            } else //Indexer
            {
                if (indexer.left_part != null && indexer.left_part.type != null) {
                    if (indexer.left_part.type is EXTERNAL_TYPE) {
                            TypeNode ent = ((EXTERNAL_TYPE)indexer.left_part.type).entity as TypeNode;
                        if (ent != null) {
                                MemberList list = ent.GetMembersNamed(new Identifier("Item"));
                            if (list.Length != 0) {
                                    Property prop = list[0] as Property;
                                if (prop != null) {
                                        EXTERNAL_TYPE ext_type = new EXTERNAL_TYPE(prop.Type);
                                        ext_type.sourceContext = sourceContext;
                                        return ext_type;
                                    }
                                }
                            }
                    } else
                        if (indexer.left_part.type is OBJECT_TYPE && indexer.calls != null && indexer.calls.Get != null) {
                                return indexer.calls.Get.return_type;
                        } else {
                                TYPE type = (TYPE)indexer.left_part.type.resolve();
                                if (type is ARRAY_TYPE)
                                    return ((ARRAY_TYPE)(type)).base_type;
                                else if (type is STRING_TYPE)
                                    return STANDARD.Char.type;
                                else if (type is UNKNOWN_TYPE)
                                    return this; 
                            }
                    }
          
            }
            // Otherwise, cannot resolve (yet).
            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            this.resolve();
            if (real_type == null) {
                if (!unknown.ErrorReported) {
                    Identifier name = null;
                    if ( unknown.name != null )         name = unknown.name;
                    else if ( unknown is UNKNOWN_DECL ) name = ((UNKNOWN_DECL)unknown).RealDeclaration.name;
                    else                                name = Identifier.For("(noname)");
                        
                    ERROR.WrongTypeName(this.sourceContext,name.Name);
                    unknown.ErrorReported = true;
                }
                return false;
            }
            return real_type.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates type
        {
            get { return real_type; }
            set { real_type = value; }
        }

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            if ( real_type == null )  // unresolved!
            {
                if (ErrorReported)
                    return null;
                if ( unknown is UNKNOWN_DECL )
                    ERROR.UndeclaredUnit(unknown.sourceContext,unknown.name.Name);
                else
                    ERROR.WrongTypeName(unknown.sourceContext,unknown.name.Name);
                ErrorReported = true;
                return null;
            }
            real_type = (TYPE)real_type.resolve();

            node = real_type.convert();
            return node;
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("UNKNOWN TYPE");
            report_extra();

            if (unknown != null) {
                NODE.doShift(shift+NODE.reportShift);
                unknown.report_short();
                System.Console.WriteLine();
            } else if (real_type != null) {
                NODE.doShift(shift+NODE.reportShift);
                System.Console.Write("RESOLVED TO ");
                real_type.report_short();
                System.Console.WriteLine();
            } else
                System.Console.WriteLine("WRONG UNKNOWN TYPE");
        }
#endif
    }

    // ARRAY_TYPE
    // ==========
    // For all kinds of array types:
    //
    // ARRAY 10 OF T        -- usual (static) array
    // ARRAY 5, 20 OF REAL  -- static 2-dimensional array
    // ARRAY * OF T         -- dynamic array
    // ARRAY *, * OF T      -- dynamic 2-dimensional array
    // ARRAY 10, * OF T     -- dynamic array with one unknown bound
    // ARRAY OF T           -- open array (as parameter type)
    //
    // Common syntax is as follows:
    //
    //   ArrayType = ARRAY Length { "," Length } OF Type.
    //   Length = ConstExpression | "*" | Ident.
    //
    public sealed class ARRAY_TYPE : TYPE {
        // Constructor
        public ARRAY_TYPE ( ) : base(ASTNodeType.ARRAY_TYPE) { 
            dimensions = new EXPRESSION_LIST();
            // TODO: below is a fix. Figure out why null reference problem can happen
            const_dimensions = new int[1];
            const_dimensions[0] = 0;
        }

        //-------------------------------------------------------------------------------------

        public EXPRESSION_LIST  dimensions;
        public int[]            const_dimensions;
        public TYPE             base_type;
        public bool             isOpen;
        public bool             isMath;
        public MemberBinding    constructorCall;

        //-------------------------------------------------------------------------------------

        public static ARRAY_TYPE create() {
            ARRAY_TYPE arrayType = new ARRAY_TYPE();

            arrayType.base_type = null;
         // arrayType.dimensions -- already initialized
            arrayType.enclosing = null;
            arrayType.modifiers = null;
            arrayType.name = null;
         // arrayType.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor

            return arrayType;
        }

        public void finalize(TYPE elemType) {
            for ( int i=0, n=dimensions.Length; i<n; i++ )
                if ( dimensions[i] != null )
                    dimensions[i].enclosing = this;

            //const_dimensions = new int[dimensions.Length];

            if (elemType == null)
                return;
            // This is because of an error in type.

            base_type = elemType;
            if ( elemType.enclosing == null )
                elemType.enclosing = this;

            // Small check...
            if (isOpen && base_type is ARRAY_TYPE)
                if (!((ARRAY_TYPE)base_type).isOpen) {
                    // We have a case like 
                    // array * of array 64 of integer
                    ERROR.NonOpenArray(base_type.sourceContext.SourceText, sourceContext);                    
                }
        }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            for ( int i=0, n=dimensions.Length; i<n; i++ )
                if (dimensions[i] != null)
                    dimensions[i].resolve();

            if ( base_type != null )
                base_type = (TYPE)base_type.resolve();

            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (base_type == null)
                return false;
            if (!base_type.validate())
                return false;

            for (int i = 0, n = dimensions.Length; i < n; i++) {
                EXPRESSION dim = dimensions[i];

                if (dim == null)
                    continue;
                if (!dim.validate())
                    return false;
                if (!(dim.type is INTEGER_TYPE) && !(dim.type is CARDINAL_TYPE) && !dim.ErrorReported) {
                    ERROR.IllegalTypeOf(dim.type.ToString(),
                                        "array dimension "+(i+1).ToString(),
                                        dim.sourceContext);
                    dim.ErrorReported = true;
                    return false;
                }

                dimensions[i].resolve();
                EXPRESSION dimension = dimensions[i];
                object val = dimension.calculate();

                if (!dimension.ErrorReported)
                {

                if (val != null)
                {
                    int s;
                    if (val is long) s = (int)(long)val;
                    else if (val is ulong) s = (int)(ulong)val;
                    else /* int */ s = (int)val;
                    if (s < 0)
                    {
                            ERROR.NegativeConst("as array dimension", dimension.sourceContext);
                            dimension.ErrorReported = true;
                    }
                    else if (s == 0)
                    {
                        ERROR.ZeroConstant(dimension.sourceContext);
                        dimension.ErrorReported = true;
                    }
                }
                else
                {
                    ERROR.NonConstant(dimension.sourceContext, "array dimension " + i);
                    dimension.ErrorReported = true;
                    const_dimensions[i] = 1;
                    // arrType.Sizes[i] = 1;
                }
                }

            }
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility(SourceContext context) {
            if (base_type == null)
                return false;
            return base_type.checkVisibility(context);
        }
        //--------------------------------------------------------------------------------------
        public Node gerInitializerProcedureCode() {
            // TODO: Not needed while cases with not open inner arrays are prohibited
            return null;
        }

        public Node getConstructionCall(EXPRESSION_LIST arguments, SourceContext sourceContext) {
            if (isOpen) {
                if (constructorCall != null) {
                    MethodCall call = new MethodCall();
                    call.Callee = constructorCall;
                    call.Operands = new ExpressionList();
                    call.SourceContext = sourceContext;
                    call.NodeType = NodeType.Call;
                    for (int i = 0, n = arguments.Length; i < n; i++)
                    {
                        call.Operands.Add((Expression)arguments[i].convert());
                    }
                    return call;
                } else {
                    ConstructArray new_array = new ConstructArray();
                    new_array.ElementType = (TypeNode)base_type.convert();
                    new_array.Operands = new ExpressionList();
                    new_array.Rank = arguments.Length;

                    int len = Math.Min(arguments.Length, this.dimensions.Length);
                    for (int i = 0, n = len; i < n; i++)
                        new_array.Operands.Add((Expression)arguments[i].convert());

                    //if (isMath) {
                    //    Member constr = STANDARD.Data.GetConstructors()[0];
                    //    Construct construct = new Construct();
                    //    construct.Constructor = new MemberBinding(null, constr);
                    //    construct.Constructor.Type = SystemTypes.Type;

                    //    construct.Operands = new ExpressionList();
                    //    construct.Operands.Add(new_array);
                    //    construct.SourceContext = this.sourceContext;
                    //    return construct;
                    //}
                    return new_array;
                }
            } else// if(base_type is ARRAY_TYPE)
            {
                return null;
                //ForEach fs = new ForEach();
                //fs.SourceContext = sourceContext;
                //fs.Body = new Block();
                //fs.InductionVariable = new Identifier("arrElem");
                //fs.TargetVariable = 

                //AssignmentStatement init = new AssignmentStatement();
                //init.Source = ((ARRAY_TYPE)base_type).getConstructionCall(arguments);

                //fs.Body.Statements = new StatementList();
                //fs.Body.Statements.Add(init);
            }
        }

        //--------------------------------------------------------------------------------------
        private TypeNode originalType;

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if ( !validate() || ErrorReported) return null;            

            ArrayTypeExpression arrType = new ArrayTypeExpression();
            
            arrType.ElementType = base_type==null ? null : (TypeNode)base_type.convert();
            arrType.Rank = dimensions.Length;
            arrType.Sizes = null; // array type itself is always treated as open! - not new int[dimensions.Length];

            const_dimensions = new int[dimensions.Length];

            for (int i = 0, n = dimensions.Length; i < n; i++) {
                if (dimensions[i] == null) {
                    // Do nothing for this dimension
                    continue;
                } else {
                    dimensions[i].resolve();
                    if (dimensions[i].ErrorReported) continue;
                    EXPRESSION dimension = dimensions[i];
                    object val = dimension.calculate();
                    
                    if (val != null) {
                        int s;
                        if (val is long)
                            s = (int)(long)val;
                        else if (val is ulong)
                            s = (int)(ulong)val;
                        else /* int */
                            s = (int)val;
                        if (s < 0)
                            ERROR.NegativeConst("as array dimension", dimension.sourceContext);
                        else if (s == 0)
                            ERROR.ZeroConstant(dimension.sourceContext);
                        const_dimensions[i] = s;
                     // arrType.Sizes[i] = s;
                    } else {
                        ERROR.NonConstant(dimension.sourceContext,"array dimension "+i);
                        const_dimensions[i] = 1;
                     // arrType.Sizes[i] = 1;
                    }
                }
            }

            //if (isMath) {
            //    node = STANDARD.Data;
            //} else {
            node = arrType;
            //}

            originalType = arrType;
            return node;
        }

        public TypeNode GetOriginalType() {
            if (node == null)
                convert();
            return originalType;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString() {
            string dims = "";
            for (int i = 0, n = dimensions.Length; i < n; i++) {
                EXPRESSION dimension = dimensions[i];
                if (dimension == null) {
                    if ((const_dimensions == null) || (const_dimensions[i] == 0))
                        dims += "*";
                    else
                        dims += const_dimensions[i].ToString();
                } else {
                    if (const_dimensions == null) {
                        if (dimensions[i] != null) {
                            object val = dimensions[i].calculate();
                            if (val != null)
                                dims += val.ToString();
                        else
                            dims += "*";
                        } else
                            dims += "*";
                    } else
                        dims += const_dimensions[i].ToString();
                }
                if (i < n - 1)
                    dims += ",";
            }
            //dims += "]";

            string elem = base_type != null ? base_type.ToString() : "unknown type";

            if (isMath)
                return "array {math} " + dims + " of " + elem;
            else 
                return "array " + dims + " of " + elem;
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("ARRAY TYPE [{0}]",dimensions.Length);
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("BASE TYPE:");
            if ( base_type == null ) // because of an error
            {
                NODE.doShift(shift+2*NODE.reportShift);
                System.Console.WriteLine("<NO TYPE>");
            } else
                base_type.report(shift+2*NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("DIMENSIONS: {0}",dimensions.Length);
            for (int i = 0, n = dimensions.Length; i < n; i++) {
                if (dimensions[i] == null) {
                    NODE.doShift(shift+2*NODE.reportShift);
                    System.Console.WriteLine("*");
                } else {
                    dimensions[i].report(shift+2*NODE.reportShift);
                }
            }
        }
#endif
    }

    // SET_TYPE
    // =======
    // For sets of integer values
    //
    // SET
    // SET {32}
    //
    public sealed class SET_TYPE : TYPE {
        // Constructors
        public SET_TYPE ( )        : base(ASTNodeType.SET_TYPE) { }
        public SET_TYPE(long w)     : base(ASTNodeType.SET_TYPE) { width = w; }

        //-----------------------------------------------------

        public long width;

        //-----------------------------------------------------

        public override NODE resolve ( )  { return this; }

        //-----------------------------------------------------

        public override bool validate ( ) { return true; }   // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            // resolve();
            // if ( !validate() ) return null;

        //  if      ( width <=  8 ) node = (TypeNode)SystemTypes.UInt8;
        //  else if ( width <= 16 ) node = (TypeNode)SystemTypes.UInt16;
        //  else if ( width <= 32 ) node = (TypeNode)SystemTypes.UInt32;
        //  else if ( width <= 64 ) node = (TypeNode)SystemTypes.UInt64;
        //  else
        //  {
        //      ERROR.MaxTypeSize("SET","64",this.sourceContext);
        //      node = (TypeNode)SystemTypes.UInt64; 
        //  }
            if (width > 64)
                ERROR.MaxTypeSize("set", "64", this.sourceContext);
            node = (TypeNode)SystemTypes.UInt64;
            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return "set{"+width+"}"; }

        //--------------------------------------------------------------------------------------

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("SET TYPE width={0}",width);
            report_extra();
        }
#endif
    }

    // RANGE_TYPE
    // =======
    // For range of integers
    //
    // RANGE_SET
    // RANGE_SET {32}
    //
    public sealed class RANGE_TYPE : TYPE {
        // Constructors
        public RANGE_TYPE()
            : base(ASTNodeType.RANGE_TYPE) { }
        //public RANGE_TYPE(long w) : base(ASTNodeType.RANGE_TYPE) { width = w; }

        //-----------------------------------------------------

        //public long width;

        //-----------------------------------------------------

        public override NODE resolve() { return this; }

        //-----------------------------------------------------

        public override bool validate() { return true; }   // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility(SourceContext context) { return true; }

        //--------------------------------------------------------------------------------------

        public override Node convert() // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            node = STANDARD.Ranges;

            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString() { return "range"; }


        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("RANGE TYPE ");
            report_extra();
        }
#endif
    }


    // INTERFACE_TYPE
    // ==============
    // For types with postulated interfaces.
    // The syntax production for the type definition is:
    //
    //   ObjectType = OBJECT [ ImplementationClause ].
    //
    // Examples:
    //
    //   OBJECT             -- type with empty interface (i.e., _any_ type)
    //   OBJECT { d1, d2 }  -- type which implements d1 & d2 definitions
    //
    public sealed class INTERFACE_TYPE : TYPE {
        // Constructor
        public INTERFACE_TYPE ( ) : base(ASTNodeType.INTERFACE_TYPE) { interfaces = new UNIT_DECL_LIST(); }

        //-----------------------------------------------------

        // Not DEFINITION_LIST, because UNKNOWN_DECLs can be there
        public UNIT_DECL_LIST interfaces;

        //-----------------------------------------------------

        public static INTERFACE_TYPE create() {
            INTERFACE_TYPE interfaceType = new INTERFACE_TYPE();

         // interfaceType.enclosing -- will be set later
         // interfaceType.interfaces -- already initialized
         // interfaceType.modifiers -- already initialized; no values
            interfaceType.name = null;  // no name
         // interfaceType.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor

            return interfaceType;
        }

        //-----------------------------------------------------

        // addPostulatedDefinition
        // -----------------------
        // The function processes one qualified-id from the list
        // of "postulated definitions":
        //
        //     VAR x : OBJECT { d1, n.d2 };
        //                          ====
        //
        // The function evaluates the name (using the same rules as IMPORT)
        // and adds the name to the definition list of the interface type.
        //
        public void addPostulatedDefinition(IDENT_LIST qualName) {
            DESIGNATOR instance  = SELECTOR.processQualName(getEnclosingUnit(), qualName);
            DECLARATION entity = instance as INSTANCE != null ? ((INSTANCE)instance).entity : null;
            // Second attempt
            entity = entity == null ? (DECLARATION)instance.resolve() : entity;

            UNIT_DECL definition;

            if (entity == null) {
                // The error message has been already issued by
                // processImportName() function; nothing to do...
                return;
            }

            if ( entity is IMPORT_DECL )  // most typical case
            {
                definition = ((IMPORT_DECL)entity).imported_unit;
                goto ProcessDefinition;
            }
            if ( entity is DEFINITION_DECL ) // We have found the definition.
            {
                definition = (DEFINITION_DECL)entity;
                goto ProcessDefinition;
            }
            if (entity is IMPLEMENTATION_DECL) {
                IMPLEMENTATION_DECL implementation = entity as IMPLEMENTATION_DECL;
                definition = implementation.implemented_definition;
                // It is still unclear how to interpret the case if base_id names
                // an implementation, and this implementation doesn't have definition...
                if (definition == null)
                    goto WrongDefinition;
                goto ProcessDefinition;
            }
            if( entity is EXTERNAL_DECL && (((EXTERNAL_DECL)entity).entity is Interface)){
                //Interface interf = (((EXTERNAL_DECL)entity).entity as Interface;
                definition = (EXTERNAL_DECL)entity;
                goto ProcessDefinition;
            }
            if ( entity is UNKNOWN_DECL )
            {
                // This means that there wasn't definition with the given name,
                // and SELECTOR.processQualName() has created it.
                // Here we should use this unknown unit just as we've got
                // a real definition...
                definition = entity as UNKNOWN_DECL;
                goto ProcessDefinition;
            }

            // All other cases (e.g., module) are illegal.

        WrongDefinition:

            // Name '{0}' does not denote a definition as expected
            ERROR.WrongDefinitionName(entity.name.Name);
            return;

        ProcessDefinition:

            // Some semantic checks:
            // - Ensure this definition is not a duplicate one.
            if (interfaces.find(definition) != null) {
                // Error: duplicate declaration of <definition in postulated interface:> '{1}'
                ERROR.DuplicateUnit("definition in postulated interface:",qualName.ToString());
                return;
            }

            // Otherwise, just add the definition to the list.
            interfaces.Add(definition);
        }

        //-----------------------------------------------------

        public override NODE resolve() {
            for ( int i=0, n=interfaces.Length; i<n; i++ )
                if (interfaces[i] != null) interfaces[i] = (UNIT_DECL)interfaces[i].resolve();

            return this;
        }

        //-----------------------------------------------------

        public override bool validate ( )   // checks semantical correctness
        {
            for (int i = 0, n = interfaces.Length; i < n; i++)
            {
                if (interfaces[i].resolve() is UNKNOWN_DECL)
                {
                    ERROR.UnknownType(sourceContext, UNIT.generateFullName(interfaces[i]));
                    return false;
                }
                if (interfaces[i] == null || !interfaces[i].validate()) return false;
            }

            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility(SourceContext context) {
            for (int i = 0, n = interfaces.Length; i < n; i++) {
                DECLARATION definition = interfaces[i];
                if (definition == null) continue;
                if (definition is UNKNOWN_DECL) {
                    DECLARATION real = (DECLARATION)((UNKNOWN_DECL)definition).RealDeclaration;
                    if (real != null)
                        definition = real;
                }
                NODE current = CONTEXT.current_unit;

                bool withinTheScope = false;
                while (current != null) {
                    if (definition.enclosing == current)
                        withinTheScope = true;
                    current = current.enclosing;
                }

                if (definition.modifiers.Private && !this.ErrorReported && !withinTheScope) {
                    ERROR.PrivateDefinition(definition.name.Name,context);
                    this.ErrorReported = true;
                    return false;
                }
            }
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            // We generate OBJECT type (i.e., System.Object type)
            // for all postulated interface types.
            // The real rules for using interface type are checked
            // by the compiler itself.
            node = (TypeNode)SystemTypes.Object;

        //  if ( interfaces == null || interfaces.Length == 0 ) // this is just OBJECT type
        //      node = (TypeNode)SystemTypes.Object;
        //  else
        //  {
        //      // NOT IMPLEMENTED
        //  }
            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString() {
            string obj = "";
            for (int i = 0, n = interfaces.Length; i < n; i++) {
                UNIT_DECL interfac = interfaces[i];
                if ( interfac is UNKNOWN_DECL && ((UNKNOWN_DECL)interfac).RealDeclaration != null )
                    obj += (((UNKNOWN_DECL)interfac).RealDeclaration).name.Name;
                else
                    obj += interfaces[i].name.Name;
                if (i < interfaces.Length - 1)
                    obj += ",";
            }
            return "object{" + obj + "}";
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("INTERFACE TYPE");
            if (name != null)
                System.Console.Write(" {0}", name);
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("POSTULATED INTERFACES: ");
            if (interfaces == null || interfaces.Length == 0) {
                System.Console.WriteLine("MISSED");
            } else {
                System.Console.WriteLine("{0}",interfaces.Length);

                NODE.doShift(shift+2*NODE.reportShift);
                for (int i = 0, n = interfaces.Length; i < n; i++) {
                    DECLARATION interfac = interfaces[i];
                    if ( interfac == null )
                        System.Console.Write("NULL ");
                    else {
                        System.Console.Write("{0}:",interfac.unique);
                        if ( interfac.name != null )
                            System.Console.Write("{0} ",interfac.name.ToString());
                        else
                            System.Console.Write("{0} ","NONAME");
                    }
                }
                System.Console.WriteLine();
            }
        }
#endif
    }

    // OBJECT_TYPE
    // ===========
    // For all object types.
    //
    // OBJECT o; ... END o.
    // VAR x : o;           <=== x is of object type
    //
    public sealed class OBJECT_TYPE : TYPE {
        // Constructor
        public OBJECT_TYPE ( ) : base(ASTNodeType.OBJECT_TYPE) { }
        
        //-----------------------------------------------------

        public DECLARATION objectUnit;  // either (known) OBJECT_DECL or UNKNOWN_DECL
        public DECLARATION ObjectUnit {
            get {
                return objectUnit;
            }
            set {
                objectUnit = value;
                name = objectUnit.name;
            }
        }

        //-----------------------------------------------------

        public override NODE resolve() {
            ObjectUnit = (DECLARATION)ObjectUnit.resolve();
            return this;
        }

        //-----------------------------------------------------

        public override bool validate ( )   // checks semantical correctness
        {
            if (!(ObjectUnit is OBJECT_DECL))
                return false;
            return ObjectUnit.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        public bool IsValue() {
            if (ObjectUnit == null)
                return false; // The same problem as in EXTERNAL_TYPE
            //TODO: Do something smart about the line above
            return ObjectUnit.modifiers.Value;
        }

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility(SourceContext context) {
            NODE current = CONTEXT.current_unit;

            bool withinTheScope = false;
            while (current != null) {
                if (ObjectUnit.enclosing == current)
                    withinTheScope = true;
                current = current.enclosing;
            }

            if (!ObjectUnit.modifiers.Public && !withinTheScope) {
                if (!this.ErrorReported) {
                    ERROR.PrivateObject(ObjectUnit.name.Name,context);
                    this.ErrorReported = true;
                }
                return false;
            }
            return true;
        }

        //------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            node = (TypeNode)ObjectUnit.convertAndGetType();

            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return ObjectUnit.name.Name; }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("OBJECT TYPE");
            if ( ObjectUnit != null )
                System.Console.Write(" {0}:{1}",ObjectUnit.unique,ObjectUnit.name);
            report_extra();
        }

        public override void report_short() {
            System.Console.WriteLine("OBJECT TYPE {0}:{1}",ObjectUnit.unique,ObjectUnit.name.Name);
        }
#endif
    }

    // ACTIVITY_TYPE
    // =============
    //
    // OBJECT o; ACTIVITY a; ... END a END o.
    // VAR oo : o;
    // VAR x  : o.a;      <=== x is of activity type
    //
    public sealed class ACTIVITY_TYPE : TYPE {
        // Constructor
        public ACTIVITY_TYPE ( ) : base(ASTNodeType.ACTIVITY_TYPE) { }

        //-----------------------------------------------------

        public ROUTINE_DECL activity;  // either (known) ACTIVITY_DECL/ACTIVITY_SPEC or UNKNOWN_DECL

        //-----------------------------------------------------

        public override NODE resolve() {
            activity = (ACTIVITY_DECL)activity.resolve();
            return this;
        }

        //-----------------------------------------------------

        public override bool validate ( )   // checks semantical correctness
        {
            return activity.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility(SourceContext context) {
            NODE current = CONTEXT.current_unit;

            bool withinTheScope = false;
            while (current != null) {
                if (activity.enclosing == current)
                    withinTheScope = true;
                current = current.enclosing;
            }

            if (!activity.modifiers.Public && !withinTheScope) {
                if (!this.ErrorReported) {
                    ERROR.PrivateActivity(activity.name.Name,context);
                    this.ErrorReported = true;
                }
                return false;
            }
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            ACTIVITY_DECL act = (ACTIVITY_DECL)activity.resolve();

      ///// Obsolete
      //    // All activities are represented as classes derived
      //    // from the same base class Zonnon.RTL.Activity
      //    AssemblyNode rtlAssembly = AssemblyNode.GetAssembly(typeof(ZonnonActivity).Assembly);
      //    node = rtlAssembly.GetType(Identifier.For("Zonnon.RTL"),Identifier.For("Activity"));

         // if ( act.prototype == null )
                node = STANDARD.protocol.type.convert(); // Activities are always of the standard
                                                         // Protocol type.
         // else
         //     node = act.prototype.convert();

            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return activity.name.Name; }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("ACTIVITY TYPE");
            if ( activity != null )
                System.Console.Write(" {0}:{1}",activity.unique,activity.name);
            report_extra();
        }
#endif
    }

    // ABSTRACT_ACTIVITY_TYPE
    // ======================
    //
    // object O;
    //     activity A implements P; ... end A 
    // end O.
    //
    // var a : activity { P };  <=== a is of an abstract activity type
    // var o : O;
    //
    // o := new O;
    // a := new o.A;
    //
    public sealed class ABSTRACT_ACTIVITY_TYPE : TYPE {
        // Constructor
        public ABSTRACT_ACTIVITY_TYPE ( ) : base(ASTNodeType.ABSTRACT_ACTIVITY_TYPE) { }

        //-----------------------------------------------------

        public DECLARATION protocol;  // either (known) PROTOCOL_DECL or UNKNOWN_DECL

        //-----------------------------------------------------

        public static ABSTRACT_ACTIVITY_TYPE create(IDENT_LIST qualName) {
            ABSTRACT_ACTIVITY_TYPE result = new ABSTRACT_ACTIVITY_TYPE();
            if (qualName == null)
                goto Finish;

            DESIGNATOR  instance = SELECTOR.processQualName(null,qualName);
            DECLARATION entity = instance!=null ? (DECLARATION)instance.resolve() : null ;

            if (entity == null) {
                // The error message has been already issued by
                // processImportName() function; nothing to do...
                goto Finish;
            }

            if (entity is PROTOCOL_DECL || entity is UNKNOWN_DECL) {
                // This means that there wasn't a protocol with the given name,
                // and SELECTOR.processQualName() has created it.
                // Here we should use this unknown unit just as we've got
                // a real protocol...
            } else {
                // All other cases are illegal.
                // Name '{0}' does not denote a protocol as expected
                ERROR.WrongProtocolName(qualName.sourceContext,entity.name.Name);
                goto Finish;
            }
            result.protocol = entity;

        Finish:
         // result.enclosing
            return result;
        }

        public override NODE resolve() {
            if (protocol != null)
                protocol = (DECLARATION)protocol.resolve();
            return this;
        }

        //-----------------------------------------------------

        public override bool validate ( )   // checks semantical correctness
        {
            if (protocol == null)
                return true;
            return protocol.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility(SourceContext context) {
            if (protocol == null)
                return true;

            NODE current = CONTEXT.current_unit;

            bool withinTheScope = false;
            while (current != null) {
                if (this.enclosing == current)
                    withinTheScope = true;
                current = current.enclosing;
            }

            if (!protocol.modifiers.Public && !withinTheScope) {
                if (!this.ErrorReported) {
                    ERROR.PrivateProtocol(protocol.name.Name,context);
                    this.ErrorReported = true;
                }
                return false;
            }
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

        //  resolve();
        //  if ( !validate() ) return null;
        //
        //  ACTIVITY_DECL act = (ACTIVITY_DECL)activity.resolve();
        //
        //  // All activities are represented as classes derived
        //  // from the same base class Zonnon.RTL.Activity
        //  AssemblyNode rtlAssembly = AssemblyNode.GetAssembly(typeof(ZonnonActivity).Assembly);
        //  node = rtlAssembly.GetType(Identifier.For("Zonnon.RTL"),Identifier.For("Activity"));

            node = STANDARD.protocol.type.convert();
            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return "activity {"+protocol.name.Name+"}"; }

        //--------------------------------------------------------------------------------------

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("ABSTRACT ACTIVITY TYPE");
            if ( protocol != null )
                System.Console.Write(" {0}:{1}",protocol.unique,protocol.name);
            report_extra();
        }
#endif
    }

    // INTEGER_TYPE
    // ============
    // For all kinds of integer types. Notice the production:
    //
    //   Width = "{" Integer "}".
    //
    // Examples:
    //
    //   INTEGER
    //   INTEGER { 32}
    //
    public sealed class INTEGER_TYPE : TYPE {
        // Constructors
        public INTEGER_TYPE ( )        : base(ASTNodeType.INTEGER_TYPE) { width = 32; }
        public INTEGER_TYPE(long w) : base(ASTNodeType.INTEGER_TYPE) { width = w; }

        //-----------------------------------------------------------

        public long width;


        //-----------------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //-----------------------------------------------------

        public override bool validate ( ) { return true; }  // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node == null) {
                if (width <= 8)
                    node = SystemTypes.Int8;
                else if (width <= 16)
                    node = SystemTypes.Int16;
                else if (width <= 32)
                    node = SystemTypes.Int32;
                else if (width <= 64)
                    node = SystemTypes.Int64;
                else {
                    node = SystemTypes.Int64;
                    ERROR.MaxTypeSize("integer", "64", this.sourceContext);
            }
            }
            return node;
        }

        //--------------------------------------------------------------------------------------

        public override string ToString ( ) { return "integer{"+width+"}"; }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("INTEGER TYPE width={0}",width);
            report_extra();
        }
#endif
    }

    // REAL_TYPE
    // =========
    // For all kinds of real types.
    //
    // REAL
    // REAL { 64 }
    //
    public sealed class REAL_TYPE : TYPE {
        // Constructors
        public REAL_TYPE() : base(ASTNodeType.REAL_TYPE) { width = 64; }
        public REAL_TYPE(long w) : base(ASTNodeType.REAL_TYPE) { width = w; }

        //----------------------------------------------------

        public long width;

        //----------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //-----------------------------------------------------

        public override bool validate ( ) { return true; }  // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node == null) {
                // Single, Double --, Decimal
                if (width <= 32) {
                    //if (Math) {
                    //    node = STANDARD.Data;
                    //} else {
                    node = SystemTypes.Single;
                    //}
                } else if (width <= 64) {
                    //if (Math) {
                    //    node = STANDARD.Data;
                    //} else {
                    node = SystemTypes.Double;
                    //}
                } else if (width <= 128) {
                    node = SystemTypes.Decimal;
                } else {
                    node = SystemTypes.Decimal;
                    ERROR.MaxTypeSize("real","128",this.sourceContext);
                }
            }
            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return "real{"+width+"}"; }

        //-------------------------------------------------------------------------------------

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("REAL TYPE width={0}",width);
            report_extra();
        }
#endif
    }

    // FIXED_TYPE
    // ==========
    // For all kinds of real types.
    //
    // FIXED
    // FIXED { 64 }
    //
    public sealed class FIXED_TYPE : TYPE {
        // Constructors
        public FIXED_TYPE ( )        : base(ASTNodeType.FIXED_TYPE) { width = 96; }
        public FIXED_TYPE(long w) : base(ASTNodeType.FIXED_TYPE) { width = w; }

        //----------------------------------------------------

        public long width;

        //----------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //-----------------------------------------------------

        public override bool validate ( ) { return true; }  // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node == null)
                node = SystemTypes.Decimal;
            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return "fixed{"+width+"}"; }

        //-------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("FIXED TYPE width={0}",width);
            report_extra();
        }
#endif
    }

    // CHAR_TYPE
    // =========
    // For all kinds of character types.
    //
    // CHAR
    // CHAR { 16 }
    //
    public sealed class CHAR_TYPE : TYPE {
        // Constructors
        public CHAR_TYPE ( )        : base(ASTNodeType.CHAR_TYPE) { }
        public CHAR_TYPE(long w) : base(ASTNodeType.CHAR_TYPE) { width = w; }

        //-------------------------------------------------------------

        public long width;

        //-------------------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //-----------------------------------------------------

        public override bool validate ( ) { return true; }  // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node == null) {
                if (width <= 8)
                    node = SystemTypes.UInt8; // Byte
                else if (width <= 16)
                    node = SystemTypes.Char;
                else {
                    node = SystemTypes.Char;
                    ERROR.MaxTypeSize("CHAR", "16", this.sourceContext);
            }
            }
            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return "char{"+width+"}"; }


        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("CHAR TYPE width={0}",width);
            report_extra();
        }
#endif
    }

    // STRING_TYPE
    // ===========
    // System-supported string type.
    //
    // STRING
    //
    public sealed class STRING_TYPE : TYPE {
        // Constructors
        public STRING_TYPE ( )        : base(ASTNodeType.STRING_TYPE) { }


        //-------------------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //-----------------------------------------------------

        public override bool validate ( ) { return true; }  // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node == null)
                node = SystemTypes.String;
            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return "string"; }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("STRING TYPE");
            report_extra();
        }
#endif
    }

    // CARDINAL_TYPE
    // =============
    //
    // CARDINAL
    //
    public sealed class CARDINAL_TYPE : TYPE {
        // Constructors
        public CARDINAL_TYPE ( long w ) : base(ASTNodeType.CARDINAL_TYPE) { width = w; }


        //-------------------------------------------------------------

        public long width;

        //-------------------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //-----------------------------------------------------

        public override bool validate ( ) { return true; }  // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node == null) {
                if (width <= 8)
                    node = SystemTypes.UInt8;
                else if (width <= 16)
                    node = SystemTypes.UInt16;
                else if (width <= 32)
                    node = SystemTypes.UInt32;
                else if (width <= 64)
                    node = SystemTypes.UInt64;
                else {
                    node = SystemTypes.UInt64;
                    ERROR.MaxTypeSize("CARDINAL", "64", this.sourceContext);
                }
            }
            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return "cardinal{"+width+"}"; }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("CARDINAL TYPE");
            report_extra();
        }
#endif
    }

    // BOOLEAN_TYPE
    // ============
    // For boolean types: BOOLEAN
    // There is only one instance of this class in STANDARD module.
    //
    public sealed class BOOLEAN_TYPE : TYPE {
        // Constructor
        public BOOLEAN_TYPE ( ) : base(ASTNodeType.BOOLEAN_TYPE) { }

        //--------------------------------------------------

        public override NODE resolve ( ) { return this; }
        public override bool validate ( ) { return true; }  // checks semantical correctness
        public override TYPE type { get { return this; } set { } } // evaluates type
        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            return SystemTypes.Boolean;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return "boolean"; }

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("BOOLEAN TYPE");
            report_extra();
        }
#endif
    }

    // VOID_TYPE
    // =========
    // For procedures (which do not return values) and for operators
    // in case they don't return values.
    // This type does not appear in Zonnon programs explicitly.
    //
    public sealed class VOID_TYPE : TYPE {
        // Constructor
        public VOID_TYPE ( ) : base(ASTNodeType.VOID_TYPE) { }

        //--------------------------------------------------

        public override NODE resolve ( ) { return this; }
        public override bool validate ( ) { return true; }  // checks semantical correctness
        public override TYPE type { get { return this; } set { } } // evaluates type
        public override bool checkVisibility ( SourceContext context ) { return true; }

        //--------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            return SystemTypes.Void;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return "void"; }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("VOID TYPE");
            report_extra();
        }
#endif
    }

    // ENUM_TYPE
    // =========
    // For enumeration types.
    //
    // TYPE E = ( one, two, three );
    //          ...................
    //
    public sealed class ENUM_TYPE : TYPE {
        // Constructor
        public ENUM_TYPE ( ) : base(ASTNodeType.ENUM_TYPE) { enumerators = new ENUMERATOR_DECL_LIST(); }

        //-------------------------------------------------------

        public ENUMERATOR_DECL_LIST enumerators;


        //-------------------------------------------------------

        public override NODE find(Identifier name) {
            return enumerators.find(name);
        }

        //-------------------------------------------------------

        // create
        // ------
        //
        public static ENUM_TYPE create(IDENT_LIST ids) {
            ENUM_TYPE enumType = new ENUM_TYPE();

            enumType.enumerators = new ENUMERATOR_DECL_LIST();
         // enumType.enclosing = will be set later
            enumType.modifiers = null;
            enumType.name = null;  // no name
         // enumType.sourceContext

            for (int i = 0, n = ids.Length; i < n; i++) {
                // Check for duplication
                if (enumType.find(ids[i]) != null) {
                    ERROR.DuplicateDeclaration(ids[i].SourceContext,ids[i].Name);
                    continue;
                }
                ENUMERATOR_DECL enumerator = new ENUMERATOR_DECL(ids[i]);

                enumerator.enclosing = enumType;
                enumerator.modifiers = new MODIFIERS();
                enumerator.modifiers.Public = true;
             // enumerator.name
             // enumerator.sourceContext
                enumerator.val = i;
                enumerator.type = enumType;

                enumType.enumerators.Add(enumerator);
            }
            return enumType;
        }

        //-------------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //-------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            for ( int i=0, n=enumerators.Length; i<n; i++ )
                if (!enumerators[i].validate())
                    return false;

            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //-------------------------------------------------------------------------------------

        public override bool checkVisibility(SourceContext context) {
            if (!(enclosing is TYPE_DECL))
                return true;

            TYPE_DECL enum_decl = enclosing as TYPE_DECL;

            NODE current = CONTEXT.current_unit;

            bool withinTheScope = false;
            while (current != null){
                if (enum_decl.enclosing == current)
                    withinTheScope = true;
                current = current.enclosing;
            }

            if (!enum_decl.modifiers.Public && !withinTheScope) {
                if (!this.ErrorReported) {
                    ERROR.PrivateType(enum_decl.name.Name,context);
                    this.ErrorReported = true;
                }
                return false;
            }
            return true;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

         // resolve();
            if (!validate())
                return null;

            if (enclosing.enclosing is PROCEDURE_DECL) {
                if (!this.ErrorReported) {
                    ERROR.NotImplemented(enclosing.sourceContext,"local enum types and variables are");
                    this.ErrorReported = true;
                }
                return null;
            }
            if (enclosing.enclosing is DEFINITION_DECL) {
                if (!this.ErrorReported) {
                    ERROR.NotImplemented(enclosing.sourceContext,"enumeration types in definitions are");
                    this.ErrorReported = true;
                }
                return null;
            }

         // enum_type = SystemTypes.Enum;
            EnumNode enum_type = new EnumNode();
            node = enum_type;  // doing this immediately to prevent unnecessary recursion

         // enum_type.Attributes;
         // enum_type.BaseType = SystemTypes.Enum;  -- it is readonly?- how to set it?
         // enum_type.ClassSize;

            enum_type.DeclaringModule = CONTEXT.symbolTable;
       /////TREE.symbolTable.Types.Add(enum_type); -- wrong: enum_type should be in its enclosing type,
       /////                                       --        but not in the global table.
            if (this.enclosing != null) {
                if (this.enclosing is TYPE_DECL)
                    enum_type.Name = ((TYPE_DECL)(this.enclosing)).name;
                else  // PROTOCOL_DECL
                    enum_type.Name = Identifier.For("Keywords");
            }
            // otherwise will be set after return (doesn't make sense here)

            if ( enclosing is TYPE_DECL ) // no other variants?
            {
                TYPE_DECL type_decl = (TYPE_DECL)enclosing; // this.enclosing is always TYPE_DECL
                enum_type.DeclaringType = (TypeNode)type_decl.enclosing.convertAndGetType();
             // enum_type.DeclaringType = (TypeNode)CONTEXT.current_unit.convertAndGetType(); -- wrong
            } else if (enclosing is PROTOCOL_DECL) {
                enum_type.DeclaringType = (TypeNode)enclosing.convertAndGetType();
            }
            // No other variants?..

         // enum_type.DefaultMembers;
         // enum_type.ExplicitCoercionMethods;
            enum_type.Flags |= TypeFlags.Sealed;
         // enum_type.FullName;
         // enum_type.HidesBaseClassMember;
         // enum_type.ImplicitCoercionMethods;
         // enum_type.Interfaces;
            enum_type.Members = new MemberList();
         // enum_type.Namespace;
         // enum_type.NodeType;
         // enum_type.OverridesBaseClassMember;
         // enum_type.PackingSize;
            enum_type.SourceContext = base.sourceContext;
         // enum_type.TypeCode;
         // enum_type.UnderlyingType = SystemTypes.Int32; -- has been already set!? exception...

            MODIFIERS modifiers = enclosing.modifiers;
            if (modifiers.Public)
                enum_type.Flags |= TypeFlags.NestedPublic;
            else if (modifiers.Private)
                enum_type.Flags |= TypeFlags.NestedPrivate;
            else // No modifier specified; choosing default value
            {
                if (enclosing is MODULE_DECL || enclosing is DEFINITION_DECL)
                    enum_type.Flags |= TypeFlags.NestedPublic;
                else if (enclosing is OBJECT_DECL || enclosing is IMPLEMENTATION_DECL)
                    enum_type.Flags |= TypeFlags.NestedPrivate;
            }

            Field value_field = new Field();
            value_field.DeclaringType = enum_type;
            value_field.Flags |= FieldFlags.Public | FieldFlags.SpecialName | FieldFlags.RTSpecialName; // FieldFlags.Static
            value_field.Name = Identifier.For("value__");
            value_field.Type = SystemTypes.Int32;
            enum_type.Members.Add(value_field);

            for (int i = 0, n = enumerators.Length; i < n; i++) {
                
                Field field = new Field();
             // field.Attributes;
                field.DeclaringType = enum_type;
                field.DefaultValue = new Literal(enumerators[i].val,SystemTypes.Int32);
                field.Flags = FieldFlags.Public | FieldFlags.Static | FieldFlags.Literal |
                              FieldFlags.HasDefault;
             // field.Initializer;
                field.Name = enumerators[i].name;
             // field.NodeType;
                field.SourceContext = enumerators[i].sourceContext;
                /* - working version
                field.Type = SystemTypes.Int32;
                */
                field.Type = enum_type; // this.comvert()
                
                enum_type.Members.Add(field);
            }
         // node = enum_type;  -- already done (see above)
            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString ( ) { return this.enclosing.name.Name; }

        //-------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("ENUMERATION TYPE WITH {0} ENUMERATORS",enumerators.Length);
            report_extra();

            for ( int i=0, n=enumerators.Length; i<n; i++ )
                enumerators[i].report(shift+NODE.reportShift);
        }

        public override void report_short() {
            System.Console.Write("ENUMERATION TYPE {0}",this.unique);
        }
#endif
    }

    // PROC_TYPE
    // =========
    // For procedure types.
    //
    // TYPE P = PROCEDURE ( a : INTEGER ) : REAL;
    //          ................................
    //
    public sealed class PROC_TYPE : TYPE {
        // Constructor
        public PROC_TYPE()
            : base(ASTNodeType.PROC_TYPE) {
            parameters = new VARIABLE_DECL_LIST();
            return_type = null;
        }

        //-------------------------------------------------------------

        public VARIABLE_DECL_LIST parameters;
        public TYPE               return_type;

        //-------------------------------------------------------------

        public static PROC_TYPE create() {
            PROC_TYPE procedureType = new PROC_TYPE();

            procedureType.enclosing = null;
         // procedureType.modifiers -- already initialized
         // procedureType.name
         // procedureType.param_types -- already initialized
            procedureType.return_type = null;
         // procedureType.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor

            return procedureType;
        }

        //-------------------------------------------------------------

        public override NODE resolve() {
            for ( int i=0, n=parameters.Length; i<n; i++ )
                parameters[i] = (VARIABLE_DECL)(parameters[i].resolve());

            if ( return_type != null )
                return_type.resolve();

            return this;
        }

        //-------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            for ( int i=0, n=parameters.Length; i<n; i++ )
                if (!parameters[i].validate())
                    return false;

            return ( return_type != null ) && return_type.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility(SourceContext context) {
            for (int i = 0, n = parameters.Length; i < n; i++) {
                if (!parameters[i].type.checkVisibility(context))
                    return false;
            }
            if (return_type != null && !return_type.checkVisibility(context))
                return false;

            return true;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            DelegateNode del = new DelegateNode();
            node = del;  // to prevent infinite recursion

            if ( this.enclosing != null && this.enclosing is TYPE_DECL )
                del.Name = ((TYPE_DECL)(this.enclosing)).name;

            del.DeclaringType = (TypeNode)CONTEXT.current_unit.convertAndGetType();
            del.Parameters = new ParameterList();

            for (int i = 0, n = parameters.Length; i < n; i++) {
                PARAMETER_DECL parZ = (PARAMETER_DECL)parameters[i];
                Parameter par = (Parameter)parZ.convert();
                par.Name = Identifier.For("_p"+i+1);
                del.Parameters.Add(par);
            }
            del.ReturnType = (TypeNode)return_type.convert();
            del.Flags |= TypeFlags.Sealed;

            MODIFIERS modifiers = enclosing.modifiers;
            if (modifiers.Private)
                del.Flags |= TypeFlags.NestedPrivate;
            else
                del.Flags |= TypeFlags.NestedPublic;

            if (enclosing.enclosing is PROCEDURE_DECL) {
                if (!this.ErrorReported) {
                    ERROR.NotImplemented(enclosing.sourceContext,"local procedure types and variables are");
                    this.ErrorReported = true;
                }
                return null;
            }
            if (enclosing.enclosing is DEFINITION_DECL) {
                if (!this.ErrorReported) {
                    ERROR.NotImplemented(enclosing.sourceContext,"procedure types in definitions are");
                    this.ErrorReported = true;
                }
                return null;
            }

         // node = del;  -- see above
            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString() {
            string proc = "procedure(";

            for (int i = 0, n = parameters.Length; i < n; i++) {
                PARAMETER_DECL par = (PARAMETER_DECL)parameters[i];
                if (par.Reference)
                    proc += "var ";
                proc += parameters[i].type.ToString();
                if (i < parameters.Length - 1)
                    proc += ",";
            }
            proc += ")";

            if (return_type != null && !(return_type is VOID_TYPE)) {
                proc += ":";
                proc += return_type.ToString();
            }
            return proc;
        }

        //-----------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("PROCEDURE TYPE");
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("PARAMETER TYPES:");
            if ( parameters.Length == 0 )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine(" {0}",parameters.Length);
                for (int i = 0, n = parameters.Length; i < n; i++) {
                    parameters[i].type.report(shift+2*NODE.reportShift);
                    if (parameters[i].modifiers.Reference) {
                        NODE.doShift(shift+2*NODE.reportShift);
                        System.Console.WriteLine("BY REFERENCE ");
                    }
                }
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("RETURN TYPE:");
            if ( return_type == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                return_type.report(shift+2*NODE.reportShift);
             // System.Console.WriteLine(" {0}:{1}",return_type.get_unique,return_type.name.ToString());
            }
        }
#endif
    }

    // EXTERNAL_TYPE
    // -------------
    // The same as EXTERNAL_DECL, but for type:
    // For class from an external assembly.
    //
    public sealed class EXTERNAL_TYPE : TYPE {
        public Node entity;

        // Constructor
        public EXTERNAL_TYPE ( Node e ) : base(ASTNodeType.EXTERNAL_TYPE) 
        {
            System.Diagnostics.Debug.Assert(e != null);
            entity = e; node = e;
            if (entity is Identifier) name = entity as Identifier;
            else if (entity is TypeNode) name = ((TypeNode)entity).Name;
            else if (entity is Field) name = ((Field)entity).Type.Name;
        }

        public static EXTERNAL_TYPE create(Node entity) {
            EXTERNAL_TYPE external = new EXTERNAL_TYPE(entity);            
            return external;
        }

        private DECLARATION decl;


        //--------------------------------------------------

        public override NODE resolve ( ) { return this; }
        public override bool validate ( ) { return true; }  // checks semantical correctness
        public override TYPE type { get { return null; } set { } } // evaluates type
        public override bool checkVisibility ( SourceContext context ) { return true; }
        public bool IsValue() {
            TypeNode tn = entity as TypeNode;
            if (tn == null)
                return false; // TODO: Not the best way, but 100% complies to older implementations
            //TODO: Fix the line above            
            return tn.IsValueType;
        }

        //--------------------------------------------------------------------------------

        public override NODE find(Identifier name) {
            if (name == null)
                return null;
            if (entity == null)
                return null;
            
            if (entity is Identifier) {
                string entity_name = ((Identifier)entity).Name;

                TypeNode typ = EXTERNALS.findType(entity_name, name);
                if (typ != null)
                    return new EXTERNAL_DECL(typ);

            } else if (entity is TypeNode) {
                Node e = entity;
                do {
                    MemberList members = ((TypeNode)e).GetMembersNamed(name);
                    if (members != null && members.Length > 0)
                        return new EXTERNAL_DECL(members[0]);

                    e = ((TypeNode)e).BaseType;
                }
                while (e != null);
            } else if (entity is Field) {
                TypeNode t = ((Field)entity).Type;
                Node e = t;
                do {
                    MemberList members = ((TypeNode)e).GetMembersNamed(name);
                    if (members != null && members.Length > 0)
                        return new EXTERNAL_DECL(members[0]);

                    e = ((TypeNode)e).BaseType;
                }
                while (e != null);
            }

            return null;
        }

        //--------------------------------------------------------------------------------

        public override Node convert() {
            return node;  // i.e., return entity
        }

        //--------------------------------------------------------------------------------

        public override string ToString ( ) { return ((TypeNode)entity).Name.Name; }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("EXTERNAL TYPE {0}:{1}",unique,entity.NodeType.ToString());
            report_extra();
        }

        public override void report_short() {
            System.Console.WriteLine("EXTERNAL DECLARATION {0}:{1}",unique,entity.NodeType.ToString());
        }
#endif
    }

    // ====================================================================
    // 3 EXPRESSIONS
    // ====================================================================

    public abstract class EXPRESSION : NODE {
        public EXPRESSION ( ASTNodeType astNodeType, string c ) : base(astNodeType, null) { code = c; }

        //----------------------------------------------------------------

        public object val = null;
        public string code = null;

        public CALL call;
  
        public TYPE estimatedType = null; // If we want to add implisit convertion we ask expession to check itself
        // Basically it is used only for real constants in expressions
       

        //----------------------------------------------------------------

        public abstract object calculate ( );  // Calculates constant expressions

        public abstract override NODE resolve ( );
        public abstract override bool validate ( );
        public abstract override TYPE type { get; set; }

        public override Node convert() {
            if (call == null)
                return null;

            // Otherwise, operator overloading was found
            node = call.convert();
            return node;
        }
        //public abstract override void generateXML(XmlNode parent, XmlDocument docSource, string compilationFileName);
#if DEBUG
        public abstract override void report ( int shift );
#endif

        public EXPRESSION resolveOperator() {
            if (!(this is BINARY) && !(this is UNARY))
                return this;

            OPERATOR_DECL_LIST opList = new OPERATOR_DECL_LIST();
            if (CONTEXT.current_unit == null) /* An error? */
                return this;
            CONTEXT.current_unit.find_operators(opList,((EXPRESSION)this).code,true);
            if (opList.Length == 0)
                return this;

         // int candidates = 0;
            OPERATOR_DECL best = null;
            EXPRESSION operand = null;
            EXPRESSION operand1 = null;
            EXPRESSION operand2 = null;

            for (int i = 0, n = opList.Length; i < n; i++) {
                OPERATOR_DECL op = opList[i];
                if ( this is UNARY  && op.paramCount != 1 ) { opList[i] = null; continue; }
                if ( this is BINARY && op.paramCount != 2 ) { opList[i] = null; continue; }
             // candidates++;
                if (this is UNARY) {
                    operand = ((UNARY)this).operand;
                    if (!TYPE.AssignmentCompatibilityS(op.parameters[0].type, operand.type))
                        continue;
                    // Check whether fits better
                    if( best == null)
                        best = op;
                    else if(TYPE.IsBetterMatch(op.parameters[0].type, best.parameters[0].type, operand.type)){
                       best = op;
                    }
                } else // this is BINARY
                {
                    operand1 = ((BINARY)this).left_operand;
                    operand2 = ((BINARY)this).right_operand;
                    if (this.code == ":=") {
                        // We want to apply assignment only if the left part is exactly the same (no implicit casts)
                        Node firstOperand = op.parameters[0].type.node; // This can be reference;
                        // TODO: this shouldn't be string... but for externals we cant get right type yet
                        TypeNode firstOperandType = null;
                        if(firstOperand is Reference) 
                            firstOperandType = ((Reference)firstOperand).ElementType;
                        else 
                            firstOperandType = firstOperand as TypeNode;
                        TypeNode targetAssignmentType = null;
                        if (operand1.type == null)
                            continue;
                        if (operand1.type.node == null) 
                            targetAssignmentType = (TypeNode)operand1.type.convert();
                        else 
                            targetAssignmentType = (TypeNode)operand1.type.node;
                        if (firstOperandType != targetAssignmentType)
                            continue;
                    } else {
                        if (!TYPE.AssignmentCompatibilityS(op.parameters[0].type, operand1.type))
                            continue;
                    }
                    if (!TYPE.AssignmentCompatibilityS(op.parameters[1].type, operand2.type))
                        continue;

                    if (best == null)
                        best = op;
                    else
                        if (TYPE.IsBetterMatch(op.parameters[1].type, best.parameters[1].type, operand2.type)) {
                        best = op;
                    }
                }
            }
            if (best != null) {
                if (this is UNARY) {
                    return makeOperatorCall(best, operand, null);
                } else // this is BINARY
                {
                    return makeOperatorCall(best, operand1, operand2);
                }
            }
         // if ( candidates != 0 )
         //     ERROR.SystemErrorIn("resolving operators","no appropriate operator");

            return this;
        }

        /************************/
        public OPERATOR_DECL findBestOpDeclForUnaryOperator(TYPE type) {
            if (!(this is UNARY))
                return null;

            OPERATOR_DECL_LIST opList = new OPERATOR_DECL_LIST();
            if (CONTEXT.current_unit == null) /* An error? */
                return null;
            CONTEXT.current_unit.find_operators(opList, ((EXPRESSION)this).code, true);
            if (opList.Length == 0)
                return null;

            // int candidates = 0;
            OPERATOR_DECL best = null;

            for (int i = 0, n = opList.Length; i < n; i++) {
                OPERATOR_DECL op = opList[i];
                if (this is UNARY && op.paramCount != 1) { opList[i] = null; continue; }
                // candidates++;

                if (!TYPE.AssignmentCompatibilityS(op.parameters[0].type, type))
                    continue;
                // Check whether fits better
                if (best == null)
                    best = op;
                else if (TYPE.IsBetterMatch(op.parameters[0].type, best.parameters[0].type, type)) {
                    best = op;
                }
            }
            //if (best != null)
            //{
            //    return makeOperatorCall(best, operand, null);
            //}
            return best;
        }

        /************************/
        public OPERATOR_DECL findBestOpDeclForBinaryOperator(TYPE type1, TYPE type2) {
            if (!(this is BINARY))
                return null;

            OPERATOR_DECL_LIST opList = new OPERATOR_DECL_LIST();
            if (CONTEXT.current_unit == null) /* An error? */
                return null;
            CONTEXT.current_unit.find_operators(opList, ((EXPRESSION)this).code, true);
            if (opList.Length == 0)
                return null;

            // int candidates = 0;
            OPERATOR_DECL best = null;

            for (int i = 0, n = opList.Length; i < n; i++) {
                OPERATOR_DECL op = opList[i];
                if (this is BINARY && op.paramCount != 2) { opList[i] = null; continue; }
                // candidates++;
                
                if (this.code == ":=") {
                    // We want to apply assignment only if the left part is exactly the same (no implicit casts)
                    Node firstOperand = op.parameters[0].type.node; // This can be reference;
                    // TODO: this shouldn't be string... but for externals we cant get right type yet
                    TypeNode firstOperandType = null;
                    if (firstOperand is Reference)
                        firstOperandType = ((Reference)firstOperand).ElementType;
                    else
                        firstOperandType = firstOperand as TypeNode;
                    TypeNode targetAssignmentType = null;
                    if (type1 == null)
                        continue;
                    if (type1.node == null)
                        targetAssignmentType = (TypeNode)type1.convert();
                    else
                        targetAssignmentType = (TypeNode)type1.node;
                    if (firstOperandType != targetAssignmentType)
                        continue;
                } else {
                    if (!TYPE.AssignmentCompatibilityS(op.parameters[0].type, type1))
                        continue;
                }
                if (!TYPE.AssignmentCompatibilityS(op.parameters[1].type, type2))
                    continue;

                if (best == null)
                    best = op;
                else
                    if (TYPE.IsBetterMatch(op.parameters[1].type, best.parameters[1].type, type2)) {
                        best = op;
                    }
            }
            //if (best != null)
            //{
            //    return makeOperatorCall(best, operand1, operand2);
            //}
            return best;
        }
        /************************/

        private CALL makeOperatorCall(OPERATOR_DECL op, EXPRESSION operand1, EXPRESSION operand2) {
            CALL call = new CALL();
            if (op.external) {
                INSTANCE ins = INSTANCE.create(op);
                ins.name = op.name;
                ins.modifiers = op.modifiers;
                ins.sourceContext = this.sourceContext;
                call.callee = ins;
            } else {
                call.callee = INSTANCE.create(op);
            }
            call.arguments = new EXPRESSION_LIST();
            call.arguments.Add(operand1);
            if ( operand2 != null )
                call.arguments.Add(operand2);
            call.sourceContext = this.sourceContext;
            return call;
        }

		//public abstract override void generateXML(XmlNode parent, XmlDocument docSource);

        // extendProcType
        // --------------
        // Is called in conditions of IF, WHILE/REPEAT...
        //
        public EXPRESSION extendProcType() {
            NODE decl = this.resolve();

            bool proc  = !(this is CALL) && (decl is PROCEDURE_DECL) && (((PROCEDURE_DECL)decl).paramCount == 0);
            bool proc_type  = (this.type is PROC_TYPE) && (((PROC_TYPE)this.type).parameters.Length == 0);
            bool ext_proc = !(this is CALL) && (decl is EXTERNAL_DECL)
                && (((EXTERNAL_DECL)decl).entity is Method)
                && (((Method)(((EXTERNAL_DECL)decl).entity)).Parameters.Length == 0);

            // Generate call instead of expression if needed
            if (proc || proc_type || ext_proc)
                return BINARY.makeCall(this);
            return this; //Else keep the same
        }
    }

    // =========================================================================
    // 3.1 UNARY EXPRESSIONS
    // =========================================================================

    // UNARY
    // =====
    // For all kinds of unary expressions in Zonnon:
    // unary plus, unary minus, and negation, and for
    // unary expressions with overloaded (in particular, user-defined)
    // unary operators.
    //
    public abstract class UNARY : EXPRESSION {
        // Constructor
        public UNARY(ASTNodeType astNodeType, string c) : base(astNodeType, c) { ovlOp = null; }

        //--------------------------------------------------------------------

        public EXPRESSION operand;  // Operand of the unary expression.

		public XmlNode xmlUnaryNode;

        protected QualifiedIdentifier ovlOp;

        //--------------------------------------------------------------------

        protected override bool containsErrorReport() {
            return operand.ErrorReported;
        }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            return (operand!=null)?operand.findScopeAtContext(line, col, documentName):null;
        }

        public override NODE resolve() {
            if (operand == null) {
                return this;
            }
            NODE decl = operand.resolve();
            if ((decl is PROCEDURE_DECL) && (operand.type is PROC_TYPE)) {
                if (((PROCEDURE_DECL)decl).paramCount == 0) {
                    // The operand of a unary operator is a _procedure_ or _procedure_type_.
                    // We always treat this as a procedure CALL with no arguments!
                    operand = BINARY.makeCall(operand);
                }
            }
            return this;
        }

        //---------------------------------------------------------------------

        public override Node convert ( )  // Generates CCI node for the operand.
        {
            // If operator overloading, just generate the call.
            if (base.convert() != null)
                return node;

            // The function just returns the sub-tree but doesn't assign it
            // to the NODE.node member. This will be done by a derived class.
            UnaryExpression unary = new UnaryExpression();
         // unary.NodeType = will be added by convert() of a derived class
            unary.Operand = (Expression)operand.convert();
            unary.SourceContext = base.sourceContext;

            return unary;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            return operand.calculate();
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (operand == null)
                return false;
            if (!operand.validate())
                return false;
         // return ( base.type != null );
            return true;
        }

        //-------------------------------------------------------------------------------------

        // Evaluates operand's type;
        // is not used separately but is called from derived classes.
        public override TYPE type {
            get { return operand.type; }
            set { }
        }

        protected TYPE evaluateOperandType() {
            if (operand == null)
                return null;
            TYPE t = operand.type;
            if (t is EXTERNAL_TYPE)
                t = TYPE.convertToZonnon((EXTERNAL_TYPE)t);
            return t;
        }

        //-------------------------------------------------------------------------------------
        protected MethodCall GetElemWiseArrayCall(NodeType opType, TYPE resType) {
            MethodCall call = new MethodCall();
            call.Operands = new ExpressionList();

            if (operand.type is ARRAY_TYPE) {
                if (!(operand is INDEXER)) {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseArrayOp(
                        ((ARRAY_TYPE)operand.type).dimensions.Length,
                        ((ARRAY_TYPE)operand.type).base_type.convert() as TypeNode,
                        null,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));

                    call.Operands.Add(operand.convert() as Expression);
                } else {
                    call.Operands.Add(((INDEXER)operand).left_part.convert() as Expression);

                    EXPRESSION_LIST indices = ((INDEXER)operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }

                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseArrayOp(
                        ((ARRAY_TYPE)((INDEXER)operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)operand).left_part.type).base_type.convert() as TypeNode,
                        ((INDEXER)operand).indices,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));
                }
            }

            call.Type = resType.convert() as TypeNode;
            return call;
        }

        //-------------------------------------------------------------------------------------
        protected MethodCall GetElemWiseSparseCall(NodeType opType, TYPE resType) {
            MethodCall call = new MethodCall();
            call.Operands = new ExpressionList();

            if (operand.type is SPARSE_TYPE) {
                call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseSparseOp(
                        ((SPARSE_TYPE)operand.type).dimensions.Length,
                        ((SPARSE_TYPE)operand.type).base_type.convert() as TypeNode,
                        ((SPARSE_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));

                call.Operands.Add(operand.convert() as Expression);
            }

            call.Type = resType.convert() as TypeNode;
            return call;
        }

        //-------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            NODE.doShift(shift);
            System.Console.WriteLine("OPERAND line={0}", this.sourceContext.StartLine.ToString());
            operand.report(shift+NODE.reportShift);
        }
#endif
    }

    // NEGATION
    // ========
    // For Zonnon predefined 'negation' operator: ~expr,
    // and for overloading negation operators.
    //
    public sealed class NEGATION : UNARY {
        // Constructor
        public NEGATION ( ) : base(ASTNodeType.NEGATION, "~") { }

        NodeType opNegation; //operation for IsMath operations with arrays

        //---------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression negation = (Expression)base.convert();
            if (node != null)
                return node;

            negation.NodeType = NodeType.LogicalNot;

            if (operand.type is ARRAY_TYPE) {
                negation.NodeType = opNegation;
                return GetElemWiseArrayCall(opNegation, type);
            }

            node = negation;
            return node;
        }

        //-----------------------------------------------------------------------

        public override object calculate ( ) // Calculates constant expression: ~expr
        {
            if (base.val != null)
                return val;

            object v = base.calculate();
            if (v == null)
                return null; // fail

            if (!(v is bool)) {
                ERROR.SystemErrorIn("NEGATION.calculate","illegal operand type(s)");
                return null;
            }
            base.val = !((bool)v);
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check type!!!!

            if ((operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "~", operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------
        /// <summary>
        /// returns the result type of this operation with a variable of type type
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private TYPE GetType(TYPE type, bool wasArray) {
            if (type == null)
                return null;

            if (type != null && type is BOOLEAN_TYPE) {
                // Legal types for the operand of '~': BOOLEAN.
                // Result type for negation: BOOLEAN.
                opNegation = NodeType.LogicalNot;
                internal_type = new BOOLEAN_TYPE();
                return internal_type;
            }

            if (type is ARRAY_TYPE) {
                int arrayRank = 0;
                TYPE returnArrayBaseType;

                ARRAY_TYPE res = new ARRAY_TYPE();
                res.isMath = true;
                res.isOpen = true;
                returnArrayBaseType = GetType(((ARRAY_TYPE)type).base_type, true);
                if (returnArrayBaseType == null)
                    return null;

                if (type is ARRAY_TYPE) {
                    arrayRank = ((ARRAY_TYPE)type).dimensions.Length;

                    res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)type).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                }

                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;

                return res;
            }

            if (!CONTEXT.firstPass) {
                NODE call = null;
                if (!wasArray) {
                    call = base.resolveOperator();
                } else {
                    OPERATOR_DECL op = base.findBestOpDeclForUnaryOperator(type);
                    if (op == null)
                        return null; //this operation was not declared

                    opNegation = NodeType.MethodCall;
                    ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                    return op.return_type;
                }
                if (call is CALL) {
                    this.call = (CALL)call;
                    internal_type = call.type;
                    return call.type;
                }
            }

            return null;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates negation's type
        {
            get {
                if (internal_type != null)
                    return internal_type;

                TYPE type = base.evaluateOperandType();

                internal_type = GetType(type, false);

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    if ( type != null )
                        ERROR.IllegalTypeForUnOperator(this.sourceContext,"~",type.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("NEGATION ~; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // UNARY_MINUS
    // ===========
    // For Zonnon predefined unary minus operator: -expr,
    // and for overloading '-' operators.
    //
    public sealed class UNARY_MINUS : UNARY {
        // Constructor
        public UNARY_MINUS ( ) : base(ASTNodeType.UNARY_MINUS, "-") { }

        NodeType opMinus; //operation for IsMath operations with arrays

        //---------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression un_minus = (Expression)base.convert();
            if (node != null)
                return node;

            if (type is SET_TYPE)
                un_minus.NodeType = NodeType.Not;
            else
                un_minus.NodeType = NodeType.Neg;

            if (operand.type is ARRAY_TYPE) {
				un_minus.NodeType = opMinus;                
				return GetElemWiseArrayCall(opMinus, type);
            }

            if (operand.type is SPARSE_TYPE) {
                un_minus.NodeType = opMinus;
                return GetElemWiseSparseCall(opMinus, type);
            }

            node = un_minus;
            return node;
        }

        //-----------------------------------------------------------------------

        public override object calculate ( ) // Calculates constant expression: -expr
        {
            if (base.val != null)
                return val;

            object v = base.calculate();
            if (v == null)
                return null; // fail

            if ( type is SET_TYPE ) { base.val = ~(uint)v; return base.val; }

            // Possible types: ulong/long, double
            if (!(v is long) && !(v is ulong) && !(v is double)) {
                ERROR.SystemErrorIn("UNARY_MINUS.calculate","illegal operand type(s)");
                return null;
            }

            if (v is long)
                base.val = -(long)v;
            else if (v is ulong)
                base.val = -(long)(ulong)v;
            else if (v is double)
                base.val = -(double)v;

            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check type!!!
            if ((operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "-", operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            // NG: why do we change something in validate??!
            //if ( this.operand.type is CARDINAL_TYPE )
            //{
            //    INTEGER_TYPE target_type = new INTEGER_TYPE(((CARDINAL_TYPE)this.operand.type).width+1);
            //    operand = new TYPE_CONV(operand,target_type);
            //}

            return base.validate();
        }

        //-------------------------------------------------------------------------------------
        /// <summary>
        /// returns the result type of this operation with a variable of type type
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private TYPE GetType(TYPE type, bool wasArray) {
            if (type == null)
                return null;

            if (type != null && (type is INTEGER_TYPE || type is CARDINAL_TYPE ||
                                       type is REAL_TYPE)) {
                // Legal types for the operand of '-': INTEGER, CARDINAL, REAL, SET.
                // Result type for unary minus: INTEGER for CARDINAL type, and
                //                              THE SAME TYPE for other legal types.
                // (and IsMath arrays of course)
                opMinus = NodeType.Neg;
                if (type is CARDINAL_TYPE) {
                    return new INTEGER_TYPE(((CARDINAL_TYPE)type).width * 2 ); // NG: It wasn't *2 in the version from EZ
                } else
                    return type;
            }
            if (type != null && (type is SET_TYPE)) {
                opMinus = NodeType.Not;
                return type;
            }

            if (type is ARRAY_TYPE) {
                int arrayRank = 0;
                TYPE returnArrayBaseType;

                ARRAY_TYPE res = new ARRAY_TYPE();
                res.isMath = true;
                res.isOpen = true;
                returnArrayBaseType = GetType(((ARRAY_TYPE)type).base_type, true);
                if (returnArrayBaseType == null)
                    return null;

                if (type is ARRAY_TYPE) {
                    arrayRank = ((ARRAY_TYPE)type).dimensions.Length;
                    
                    res.const_dimensions = new int[arrayRank];
                    
                    if (((ARRAY_TYPE)type).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                }

                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;

                return res;
            }

            if (type is SPARSE_TYPE) {
                int arrayRank = 0;
                TYPE returnArrayBaseType;

                SPARSE_TYPE res = new SPARSE_TYPE();
                returnArrayBaseType = GetType(((SPARSE_TYPE)type).base_type, true);
                if (returnArrayBaseType == null)
                    return null;

                arrayRank = ((SPARSE_TYPE)type).dimensions.Length;

                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;
                res.isVector = arrayRank == 1;

                return res;
            }

            if (!CONTEXT.firstPass) {
                NODE call = null;
                if (!wasArray) {
                    call = base.resolveOperator();
                } else {
                    OPERATOR_DECL op = base.findBestOpDeclForUnaryOperator(type);
                    if (op == null)
                        return null; //this operation was not declared

                    opMinus = NodeType.MethodCall;
                    ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                    return op.return_type;
                }
                if (call is CALL) {
                    this.call = (CALL)call;
                    internal_type = call.type;
                    return call.type;
                }
            }

            return null;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates type of unary minus
        {
            get {
                if (internal_type != null)
                    return internal_type;

                TYPE type = base.evaluateOperandType();

                internal_type = GetType(type, false);

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForUnOperator(this.sourceContext, "-", (type == null) ? "unknown type" : type.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("UNARY MINUS -; line={0},  TYPE={1}", this.sourceContext.StartLine.ToString(), type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // UNARY_PLUS
    // ==========
    // For Zonnon predefined unary plus operator: +expr,
    // and for overloading '+' operators.
    //
    public sealed class UNARY_PLUS : UNARY {
        // Constructor
        public UNARY_PLUS ( ) : base(ASTNodeType.UNARY_PLUS, "+") { }

        NodeType opPlus; //operation for IsMath operations with arrays

        //---------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression un_plus = (Expression)base.convert();
            if (node != null)
                return node;

			un_plus.NodeType = NodeType.UnaryPlus;

            if (operand.type is ARRAY_TYPE) {
				un_plus.NodeType = opPlus;
                return GetElemWiseArrayCall(opPlus, type);
            }

            if (operand.type is SPARSE_TYPE) {
                un_plus.NodeType = opPlus;
                return GetElemWiseSparseCall(opPlus, type);
            }

            node = un_plus;
            return node;
        }

        //-----------------------------------------------------------------------

        public override object calculate ( ) // Calculates constant expression: +expr
        {
            if (base.val != null)
                return base.val;

            object v = base.calculate();
            if (v == null)
                return null; // fail

            base.val = v;
            return v;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check type!!!

            if ((operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "+", operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------
        /// <summary>
        /// returns the result type of this operation with a variable of type type
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private TYPE GetType(TYPE type, bool wasArray) {
            if (type == null)
                return null;

            if (type != null && (type is INTEGER_TYPE || type is CARDINAL_TYPE ||
                                       type is REAL_TYPE || type is SET_TYPE)) {
                // Legal types for the operand of unary '+': INTEGER, CARDINAL, REAL, SET.
                // Result type for unary minus: THE SAME TYPE.
                // (and IsMath arrays of course)
                opPlus = NodeType.UnaryPlus;
                return type;
            }

            if (type is ARRAY_TYPE) {
                int arrayRank = 0;
                TYPE returnArrayBaseType;

                ARRAY_TYPE res = new ARRAY_TYPE();
                res.isMath = true;
                res.isOpen = true;
                returnArrayBaseType = GetType(((ARRAY_TYPE)type).base_type, true);
                if (returnArrayBaseType == null)
                    return null;

                if (type is ARRAY_TYPE) {
                    arrayRank = ((ARRAY_TYPE)type).dimensions.Length;

                    res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)type).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                }

                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;

                return res;
            }

            if (type is SPARSE_TYPE) {
                int arrayRank = 0;
                TYPE returnArrayBaseType;

                SPARSE_TYPE res = new SPARSE_TYPE();
                returnArrayBaseType = GetType(((SPARSE_TYPE)type).base_type, true);
                if (returnArrayBaseType == null)
                    return null;

                arrayRank = ((SPARSE_TYPE)type).dimensions.Length;

                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;
                res.isVector = arrayRank == 1;

                return res;
            }

            if (!CONTEXT.firstPass) {
                NODE call = null;
                if (!wasArray) {
                    call = base.resolveOperator();
                } else {
                    OPERATOR_DECL op = base.findBestOpDeclForUnaryOperator(type);
                    if (op == null)
                        return null; //this operation was not declared

                    opPlus = NodeType.MethodCall;
                    ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                    return op.return_type;
                }
                if (call is CALL) {
                    this.call = (CALL)call;
                    internal_type = call.type;
                    return call.type;
                }
            }

            return null;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates type of unary plus
        {
            get {
                if (internal_type != null)
                    return internal_type;

                TYPE type = base.evaluateOperandType();

                internal_type = GetType(type, false);

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForUnOperator(this.sourceContext, "+", (type == null) ? "unknown type" : type.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }


        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("UNARY PLUS +; line={0}, TYPE={1}", this.sourceContext.StartLine.ToString(), type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // TYPE_CONV
    // =========
    // This is the node for type conversions.
    // there are 2 cases where this node occurs:
    //
    // - For "extending" types for assignments; see TYPE.AssignmentCompatible();
    //
    // - As the representation of type cast between intrinsic types, e.g.,
    //
    //    TYPE I16 = INTEGER{16};
    //         I64 = INTEGER{64};
    //
    //    VAR  i : I16; j : I64;
    //
    //    i := j;        // illegal
    //    i := j{I16};   // legal  ====== NOW it looks like i := I16(j);
    //
    // Notice that TYPE_CONV nodes should be (and are) created only for _legal_
    // conversions, that is, for the conversions which can be expressed by CCI.
    //
    public sealed class TYPE_CONV : UNARY {
        // Constructor
        public TYPE_CONV(EXPRESSION expr, TYPE type)
            : base(ASTNodeType.TYPE_CONV, null) {
            base.operand = expr;
            targetType = type;
            this.sourceContext = expr.sourceContext;
        }
        
        //---------------------------------------------------------------------

        public static EXPRESSION checkTypeConversion(EXPRESSION expr) {
            if (!(expr is CALL))
                return expr;

            CALL call = expr as CALL;
            if (call.callee == null || call.callee.name == null)
                return expr;

            TYPE type = TYPE.evaluateTypeName(call.callee.name, 0); //RM: thre was .reslove() here which is bad in fact as it it too early
            if (type == null)
                return expr;

            EXPRESSION_LIST args = call.arguments;
            int L = args.Length;

            if (L < 1 || L > 2) {
                ERROR.IllegalArgsInTypeConversion();
                return expr;
            }

            long s = -1;
            if (args[1] != null) {
                // Check the second parameter and construct the target type
                EXPRESSION width = args[1];

                object val = width.calculate();
                if (val == null) {
                    ERROR.IllegalWidthInTypeConversion();
                    return expr;
                }
                s = (long)val;
            }
            if (s != -1)
                type = TYPE.evaluateTypeName(call.callee.name, s);

            EXPRESSION source = args[0];
            if (source is STRING_LITERAL) {
                string str = ((STRING_LITERAL)source).str;
                if (str.Length == 1) {
                    // String literal of length 1 is treated here as character literal.
                    // Creating CHAR_LITERAL node and replace
                    // original STRING_LITERAL node in the tree.
                    source = CHAR_LITERAL.create(str[0], source.sourceContext);
                }
            }
            return new TYPE_CONV(source, type);            
        }

        //---------------------------------------------------------------------

        public TYPE targetType;

        //---------------------------------------------------------------------

        public override NODE resolve() {
            base.resolve();  // resolving operand
            if (targetType != null) {
                targetType = (TYPE)targetType.resolve();
                this.type = targetType;
            }
            return this;
        }

        //---------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;
            
            resolve();
            
            if (!validate())
                return null;

            Expression expr = (Expression)operand.convert();

            TypeNode targetCCIType = (TypeNode)targetType.convert();
            TYPE sourceType = operand.type;

            if (sourceType is ARRAY_TYPE) {
                MethodCall call_math = new MethodCall();
                call_math.Operands = new ExpressionList();

                //////////
                if (!(operand is INDEXER)) {
                    call_math.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseArrayScalarOp(
                        ((ARRAY_TYPE)sourceType).dimensions.Length,
                        ((ARRAY_TYPE)sourceType).base_type.convert() as TypeNode,
                        null,
                        targetCCIType as TypeNode,
                        ((ARRAY_TYPE)sourceType).dimensions.Length,
                        targetCCIType as TypeNode,
                        NodeType.Castclass,
                        null,
                        this.sourceContext));

                    call_math.Operands.Add(expr);
                    //call_math.Operands.Add(right_operand.convert() as Expression);
                } else {
                    call_math.Operands.Add(((INDEXER)operand).left_part.convert() as Expression);
                    //call_math.Operands.Add(right_operand.convert() as Expression);

                    EXPRESSION_LIST indices = ((INDEXER)operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call_math.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call_math.Operands.Add(cur_range.from.convert() as Expression);
                                call_math.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call_math.Operands.Add(cur_range.to.convert() as Expression);
                                call_math.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call_math.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call_math.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call_math.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call_math.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call_math.Operands.Add(indices[i].convert() as Expression);
                        }
                    }

                    call_math.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseArrayScalarOp(
                        ((ARRAY_TYPE)((INDEXER)operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)operand).left_part.type).base_type.convert() as TypeNode,
                        ((INDEXER)operand).indices,
                        targetCCIType as TypeNode,
                        ((ARRAY_TYPE)((INDEXER)operand).left_part.type).dimensions.Length,
                        targetCCIType as TypeNode,
                        NodeType.Castclass,
                        null,
                        this.sourceContext));
                }
                call_math.Type = type.convert() as TypeNode;
                return call_math;
                ////////////
            }

            if ( targetCCIType == null ) // an error was detected before...
                return null;
            if (expr is QualifiedIdentifier) {
                // Need to find methos 
                QualifiedIdentifier qid = (QualifiedIdentifier)expr;
                TypeNode type = (qid.Qualifier is MemberBinding)? ((MemberBinding)qid.Qualifier).BoundMember as TypeNode
                    : qid.Qualifier.Type as TypeNode;
                Method m = null;
                if(type != null && qid != null)
                    m = type.GetMethod(qid.Identifier, new TypeNode[0]);
            if(m != null) // It is a method, but not a field
                // Make it a call
                // ch := char(r.GetChar);            
            {
                expr = new MethodCall(expr, new ExpressionList(), NodeType.Call, expr.Type, sourceContext);
            }
            }

            BinaryExpression result = new BinaryExpression(expr,new MemberBinding(null,targetCCIType),
                                                           NodeType.Castclass);
            result.SourceContext = operand.sourceContext;
            node = result;

            if (targetCCIType.TypeCode == TypeCode.String) {
                MethodCall convert = new MethodCall();
                convert.Callee = new QualifiedIdentifier(expr, Identifier.For("ToString"));
                convert.Operands = new ExpressionList();  // no args
                convert.SourceContext = operand.sourceContext;
                convert.Type = SystemTypes.String;
                node = convert;
            } else if (sourceType is REAL_TYPE) {
                if (((REAL_TYPE)sourceType).width <= 64) {
                    switch (targetCCIType.TypeCode) {
                        case TypeCode.Decimal:
                            result = new BinaryExpression(expr, new MemberBinding(null, targetCCIType),
                                                          NodeType.Castclass);
                            result.SourceContext = operand.sourceContext;
                            node = result;
                            break;
                        case TypeCode.Int32:
                            result = new BinaryExpression(expr, new MemberBinding(null, targetCCIType),
                                                          NodeType.Castclass);
                            result.SourceContext = operand.sourceContext;
                            node = result;
                            break;
                    }
                }
            }

            if (node == null)
                node = expr;
            return node;
        }

        //-----------------------------------------------------------------------

        public override object calculate ( ) // Calculates constant expression
        {
            object val = base.calculate();
            if (val == null)
                return null;

            if (targetType is INTEGER_TYPE) {
                if (val is double)
                    return (long)(double)val;
                else if (val is ulong)
                    return (long)(ulong)val;
                else
                    return null;
            } else if (targetType is CARDINAL_TYPE) {
                if (val is double)
                    return (ulong)(double)val;
                else if (val is ulong)
                    return (ulong)(long)val;
                else
                    return null;
            }
            if (targetType is REAL_TYPE) {
                if (val is double)
                    return (double)val;
                else if (val is ulong)
                    return (double)(ulong)val;
            else
                return null;
            } else
                return null;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check type!!!
            if (operand == null)
                return false;
            if (!operand.validate())
                return false;
            if ((operand.type is ARRAY_TYPE) && (!((ARRAY_TYPE)operand.type).isMath))
                return false;
            // return ( base.type != null );
			return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                //if (internal_type == null)
                //{
                    internal_type = targetType;
                if (operand.type is ARRAY_TYPE) {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;

                        int arrayRank = ((ARRAY_TYPE)operand.type).dimensions.Length;
                        
                        res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)operand.type).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)operand.type).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }

                        res.dimensions = new EXPRESSION_LIST(arrayRank);
                        res.dimensions.Length = arrayRank;
                        res.base_type = targetType;

                        internal_type = res;
                    }
                //}
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("TYPE CONVERSION TO ");
            if ( type != null )
                System.Console.Write("{0}; TYPE={0}, line={1}",type.ToString(), this.sourceContext.StartLine.ToString());
            else
                System.Console.Write("nothing");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

/****************************************
    // USER_UNARY
    // ==========
    // For user-defined unary operators.
    //
    public sealed class USER_UNARY : UNARY
    {
        // Constructor
        public USER_UNARY ( OPERATOR_DECL op ) : base() { user_operator = op; }

        //---------------------------------------------------------------------

        public OPERATOR_DECL user_operator;

        //---------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if ( node != null ) return node;

            base.resolve();
            if ( !validate() ) return null;

            node = (Expression)base.convert();

            return node;
        }

        //-----------------------------------------------------------------------

        public override object calculate ( ) // Calculates constant expression: -expr
        {
            return null;  // cannot calculate user-defined expression.
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Checking operand
            if ( !base.validate() ) return false;
            // Checking operator itself
            if ( !user_operator.validate() ) return false;
            // Comparing operand's type with type of operator's parameter

            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates type of a user-defined operator
        {
            get
            {
                // Here the type is just the type returned by the operator
                if ( internal_type == null )
                {
                    // Taking just the type returned by user operator
                    internal_type = user_operator.type;
                }
                return internal_type;
            }
            set
            {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report ( int shift )
        {
            report_unique(shift);
            System.Console.Write("USER_DEFINED UNARY {0} ",this.name.Name);
            if ( type != null )
                System.Console.Write("; TYPE={0}",type.ToString());
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }
**************************/

    // ===============================================================================
    // 3.2 BINARY EXPRESSIONS
    // ===============================================================================

    public abstract class BINARY : EXPRESSION {
        // Constructor
        public BINARY(ASTNodeType astNodeType, string c) : base(astNodeType, c) { ovlOp = null; }

        //----------------------------------------------------------------------------

        public EXPRESSION left_operand;
        public EXPRESSION right_operand;

        protected QualifiedIdentifier ovlOp;
		
		// used for Xml Processing in derived classes
		public XmlNode xmlBinaryNode;

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            if(left_operand!=null) scope = left_operand.findScopeAtContext(line, col, documentName);
            if(scope == null && right_operand != null) scope = right_operand.findScopeAtContext(line, col, documentName);
            return scope;
        }


        protected override bool containsErrorReport() {
            return ((left_operand!= null) && left_operand.ErrorReported) || ((left_operand!= null) && right_operand.ErrorReported);
        }
        //----------------------------------------------------------------------------

        public override NODE resolve() {
            if ( left_operand != null )  { left_operand.resolve(); }
            if ( right_operand != null ) { right_operand.resolve(); }
            return this;
        }

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            // If operator overloading, just generate the call.
            if (base.convert() != null)
                return node;

            BinaryExpression binary = new BinaryExpression();
         // binary.NodeType = will be added by convert() of a derived class
            Node op1 = null;
            Node op2 = null;

            // If type of one of operands is not the result type we have to
            // insert conversion. Overwise we have problems
            // with operations like real{32} + real{64}

            if (left_operand != null && right_operand != null) {
                left_operand.estimatedType = right_operand.type;
                right_operand.estimatedType = left_operand.type;
                op1 = left_operand.convert();
                op2 = right_operand.convert();
            }

            if (op1 is Expression)
                binary.Operand1 = (Expression)op1;
            if (op2 is Expression)
                binary.Operand2 = (Expression)op2;

            binary.SourceContext = base.sourceContext;
            binary.Type = (TypeNode)type.convert();
            return binary;
        }

        //--------------------------------------------------------------------

        public abstract override object calculate ( );   // Calculates constant expressions
        // All actions are in calculate{Left,Right}() and in derived classes

        protected object calculateLeft  ( ) { if ( left_operand == null ) return null; return left_operand.calculate(); }
        protected object calculateRight ( ) { if ( right_operand == null ) return null; return right_operand.calculate(); }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (left_operand == null || right_operand == null)
                return false;
            if (!left_operand.validate() || !right_operand.validate())
                return false;
            return ( this.type != null );
        }

        //-------------------------------------------------------------------------------------

        public abstract override TYPE type  // evaluates operand's type
        {
            get;
            set; // All actions are in evaluate_{Left,Right}Type() and in derived classes
        }

        protected TYPE evaluateLeftType() {
            if (left_operand == null)
                return null;
            TYPE t = left_operand.type;
            if (t is EXTERNAL_TYPE)
                t = TYPE.convertToZonnon((EXTERNAL_TYPE)t);
            return t;
        }

        protected TYPE evaluateRightType() {
            if (right_operand == null)
                return null;
            TYPE t = right_operand.type;
            if (t is EXTERNAL_TYPE)
                t = TYPE.convertToZonnon((EXTERNAL_TYPE)t);
            return t;
        }

        // extendProcTypes
        // ---------------
        // Is called in derived classes before evaluate{Left,Right}Type()
        //
        protected void extendProcTypes() {
            if (left_operand == null || right_operand == null)
                return;

            NODE l_decl = left_operand.resolve();
            NODE r_decl = right_operand.resolve();

            bool left_proc  = !(left_operand is CALL) && (l_decl is PROCEDURE_DECL) && (((PROCEDURE_DECL)l_decl).paramCount == 0);
            bool right_proc = !(right_operand is CALL) && (r_decl is PROCEDURE_DECL) && (((PROCEDURE_DECL)r_decl).paramCount == 0);
            bool left_proc_type  = (left_operand.type is PROC_TYPE) && (((PROC_TYPE)left_operand.type).parameters.Length == 0);
            bool right_proc_type = (right_operand.type is PROC_TYPE) && (((PROC_TYPE)right_operand.type).parameters.Length == 0);

            if (this is EQUAL || this is NON_EQUAL) {
                if (left_proc && right_proc) {
                    // p1 = p2, where p1,p2 - procedures.
                    // We always treat this as comparison of the two call results,
                    // but not comaprision of two entities.

                    // Replace operands for corresponding calls.
                    left_operand  = makeCall(left_operand);
                    right_operand = makeCall(right_operand);
                } else if ((left_proc || left_proc_type) && (right_proc || right_proc_type)) {
                    // p == pp  OR  pp = p  OR  pp1=pp2
                    //
                    // where p - procedure, pp,pp1,pp2 - variables of a proc.type.
                    // We treat this as a comparison of _variables_ but not calls.
                    //
                    // We just issue warning here.
                    ERROR.SimpleComparison(this.sourceContext);
                } else if (left_proc || left_proc_type) {
                    left_operand = makeCall(left_operand);
                } else if (right_proc || right_proc_type) {
                    right_operand = makeCall(right_operand);
                }
            } else {
                // For all other binary operators, if an operand is procedure
                // or is of a procedure type, it is always treated as a call.
                //
                // Generate calls for operand(s) which are in fact calls.

                if (left_proc || left_proc_type)
                    left_operand = makeCall(left_operand);
                if (right_proc || right_proc_type)
                    right_operand = makeCall(right_operand);
            }
        }

        public static CALL makeCall(EXPRESSION operand) {
            CALL call = new CALL();
            call.arguments = new EXPRESSION_LIST();
            call.callee = (DESIGNATOR)operand;
            call.sourceContext = operand.sourceContext;
            return call;
        }

        protected MethodCall GetElemWiseArrayOrArrayCall(NodeType opType, TYPE resType) {
            MethodCall call = new MethodCall();
            call.Operands = new ExpressionList();

            if (left_operand.type is ARRAY_TYPE) // Array - Scalar
            {
                if (!(left_operand is INDEXER)) {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseArrayScalarOp(
                        ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                        null,
                        right_operand.type.convert() as TypeNode,
                        ((ARRAY_TYPE)resType).dimensions.Length,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));

                    call.Operands.Add(left_operand.convert() as Expression);
                    call.Operands.Add(right_operand.convert() as Expression);
                } else {
                    call.Operands.Add(((INDEXER)left_operand).left_part.convert() as Expression);
                    call.Operands.Add(right_operand.convert() as Expression);

                    EXPRESSION_LIST indices = ((INDEXER)left_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }

                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseArrayScalarOp(
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                        ((INDEXER)left_operand).indices,
                        right_operand.type.convert() as TypeNode,
                        ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));
                }
            } else        //Scalar - Array
            {
                if (!(right_operand is INDEXER)) {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseScalarArrayOp(
                        ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                        left_operand.type.convert() as TypeNode,
                        ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                        null,
                        ((ARRAY_TYPE)resType).dimensions.Length,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));

                    call.Operands.Add(left_operand.convert() as Expression);
                    call.Operands.Add(right_operand.convert() as Expression);
                } else {
                    call.Operands.Add(left_operand.convert() as Expression);
                    call.Operands.Add(((INDEXER)right_operand).left_part.convert() as Expression);

                    EXPRESSION_LIST indices = ((INDEXER)right_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }

                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseScalarArrayOp(
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                        left_operand.type.convert() as TypeNode,
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                        ((INDEXER)right_operand).indices,
                        ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));
                }
            }

            call.Type = resType.convert() as TypeNode;
            return call;
        }

        protected MethodCall GetElemWiseArrayAndArrayCall(NodeType opType, TYPE resType) {
            MethodCall call = new MethodCall();
            call.Operands = new ExpressionList();

            bool leftIsIndexer = left_operand is INDEXER;
            bool rightIsIndexer = right_operand is INDEXER;

            if (!leftIsIndexer)
                call.Operands.Add(left_operand.convert() as Expression);
            else
                call.Operands.Add(((INDEXER)left_operand).left_part.convert() as Expression);
            if (!rightIsIndexer)
                call.Operands.Add(right_operand.convert() as Expression);
            else
                call.Operands.Add(((INDEXER)right_operand).left_part.convert() as Expression);

            if (leftIsIndexer) {
                EXPRESSION_LIST indices = ((INDEXER)left_operand).indices;
                for (int i = 0; i < indices.Length; i++) {
                    if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                        call.Operands.Add(indices[i].convert() as Expression);
                    } else if (indices[i].type is RANGE_TYPE) {
                        if (indices[i] is ARRAY_RANGE) {
                            ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                            call.Operands.Add(cur_range.from.convert() as Expression);
                            call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                            call.Operands.Add(cur_range.to.convert() as Expression);
                            call.Operands.Add(cur_range.by.convert() as Expression);
                        } else //it's range_type variable
                        {
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                            call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                        }
                    } else if (indices[i].type is ARRAY_TYPE) {
                        call.Operands.Add(indices[i].convert() as Expression);
                    }
                }
            }
            if (rightIsIndexer) {
                EXPRESSION_LIST indices = ((INDEXER)right_operand).indices;
                for (int i = 0; i < indices.Length; i++) {
                    if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                        call.Operands.Add(indices[i].convert() as Expression);
                    } else if (indices[i].type is RANGE_TYPE) {
                        if (indices[i] is ARRAY_RANGE) {
                            ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                            call.Operands.Add(cur_range.from.convert() as Expression);
                            call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                            call.Operands.Add(cur_range.to.convert() as Expression);
                            call.Operands.Add(cur_range.by.convert() as Expression);
                        } else //it's range_type variable
                        {
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                            call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                        } 
                    } else if (indices[i].type is ARRAY_TYPE) {
                        call.Operands.Add(indices[i].convert() as Expression);
                    }
                }
            }

            if (!leftIsIndexer) {
                if (!rightIsIndexer) {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseArrayArrayOp(
                        ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                        ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                        null,
                        null,
                        ((ARRAY_TYPE)resType).dimensions.Length,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));
                } else {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseArrayArrayOp(
                        ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                        null,
                        ((INDEXER)right_operand).indices,
                        ((ARRAY_TYPE)resType).dimensions.Length,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));
                }
            } else {
                if (!rightIsIndexer) {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseArrayArrayOp(
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                        ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                        ((INDEXER)left_operand).indices,
                        null,
                        ((ARRAY_TYPE)resType).dimensions.Length,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));
                } else {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseArrayArrayOp(
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                        ((INDEXER)left_operand).indices,
                        ((INDEXER)right_operand).indices,
                        ((ARRAY_TYPE)resType).dimensions.Length,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));
                }
            }

            call.Type = resType.convert() as TypeNode;
            return call;
        }

        protected MethodCall GetElemWiseSparseAndSparseCall(NodeType opType, TYPE resType) {
            MethodCall call = new MethodCall();
            call.Operands = new ExpressionList();
            call.Operands.Add(left_operand.convert() as Expression);
            call.Operands.Add(right_operand.convert() as Expression);

            if (resType is SPARSE_TYPE)
                call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseSparseSparseOp(
                        ((SPARSE_TYPE)left_operand.type).dimensions.Length,
                        ((SPARSE_TYPE)right_operand.type).dimensions.Length,
                        ((SPARSE_TYPE)left_operand.type).base_type.convert() as TypeNode,
                        ((SPARSE_TYPE)right_operand.type).base_type.convert() as TypeNode,
                        ((SPARSE_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));
            else //it's IsMath array type
                call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetElementWiseSparseSparseOp(
                        ((SPARSE_TYPE)left_operand.type).dimensions.Length,
                        ((SPARSE_TYPE)right_operand.type).dimensions.Length,
                        ((SPARSE_TYPE)left_operand.type).base_type.convert() as TypeNode,
                        ((SPARSE_TYPE)right_operand.type).base_type.convert() as TypeNode,
                        ((ARRAY_TYPE)resType).base_type.convert() as TypeNode,
                        opType,
                        ovlOp,
                        this.sourceContext));

            call.Type = resType.convert() as TypeNode;
            return call;
        }

        protected MethodCall GetGeneralizedArrayOrArrayCall(NodeType opType, TYPE resType) {
            MethodCall call = new MethodCall();
            call.Operands = new ExpressionList();

            if (left_operand.type is ARRAY_TYPE) // Array - Scalar
            {
                if (!(left_operand is INDEXER)) {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetGeneralizedArrayScalarOp(
                        ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                        right_operand.type.convert() as TypeNode,
                        null,
                        opType,
                        ovlOp,
                        this.sourceContext));

                    call.Operands.Add(left_operand.convert() as Expression);
                    call.Operands.Add(right_operand.convert() as Expression);
                } else {
                    call.Operands.Add(((INDEXER)left_operand).left_part.convert() as Expression);
                    call.Operands.Add(right_operand.convert() as Expression);

                    EXPRESSION_LIST indices = ((INDEXER)left_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }

                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetGeneralizedArrayScalarOp(
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                        right_operand.type.convert() as TypeNode,
                        ((INDEXER)left_operand).indices,
                        opType,
                        ovlOp,
                        this.sourceContext));
                }
            } else        //Scalar - Array
            {
                if (!(right_operand is INDEXER)) {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetGeneralizedScalarArrayOp(
                        ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                        left_operand.type.convert() as TypeNode,
                        ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                        null,
                        opType,
                        ovlOp,
                        this.sourceContext));

                    call.Operands.Add(left_operand.convert() as Expression);
                    call.Operands.Add(right_operand.convert() as Expression);
                } else {
                    call.Operands.Add(left_operand.convert() as Expression);
                    call.Operands.Add(((INDEXER)right_operand).left_part.convert() as Expression);

                    EXPRESSION_LIST indices = ((INDEXER)right_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }

                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetGeneralizedScalarArrayOp(
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                        left_operand.type.convert() as TypeNode,
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                        ((INDEXER)right_operand).indices,
                        opType,
                        ovlOp,
                        this.sourceContext));
                }
            }

            call.Type = resType.convert() as TypeNode;
            return call;
        }

        protected MethodCall GetGeneralizedArrayAndArrayCall(NodeType opType, TYPE resType) {
            MethodCall call = new MethodCall();
            call.Operands = new ExpressionList();

            bool leftIsIndexer = left_operand is INDEXER;
            bool rightIsIndexer = right_operand is INDEXER;

            if (!leftIsIndexer)
                call.Operands.Add(left_operand.convert() as Expression);
            else
                call.Operands.Add(((INDEXER)left_operand).left_part.convert() as Expression);
            if (!rightIsIndexer)
                call.Operands.Add(right_operand.convert() as Expression);
            else
                call.Operands.Add(((INDEXER)right_operand).left_part.convert() as Expression);

            if (leftIsIndexer) {
                EXPRESSION_LIST indices = ((INDEXER)left_operand).indices;
                for (int i = 0; i < indices.Length; i++) {
                    if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                        call.Operands.Add(indices[i].convert() as Expression);
                    } else if (indices[i].type is RANGE_TYPE) {
                        if (indices[i] is ARRAY_RANGE) {
                            ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                            call.Operands.Add(cur_range.from.convert() as Expression);
                            call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                            call.Operands.Add(cur_range.to.convert() as Expression);
                            call.Operands.Add(cur_range.by.convert() as Expression);
                        } else //it's range_type variable
                        {
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                            call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                        }
                    } else if (indices[i].type is ARRAY_TYPE) {
                        call.Operands.Add(indices[i].convert() as Expression);
                    }
                }
            }
            if (rightIsIndexer) {
                EXPRESSION_LIST indices = ((INDEXER)right_operand).indices;
                for (int i = 0; i < indices.Length; i++) {
                    if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                        call.Operands.Add(indices[i].convert() as Expression);
                    } else if (indices[i].type is RANGE_TYPE) {
                        if (indices[i] is ARRAY_RANGE) {
                            ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                            call.Operands.Add(cur_range.from.convert() as Expression);
                            call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                            call.Operands.Add(cur_range.to.convert() as Expression);
                            call.Operands.Add(cur_range.by.convert() as Expression);
                        } else //it's range_type variable
                        {
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                            call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                            call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                        }
                    } else if (indices[i].type is ARRAY_TYPE) {
                        call.Operands.Add(indices[i].convert() as Expression);
                    }
                }
            }

            if (!leftIsIndexer) {
                if (!rightIsIndexer) {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetGeneralizedArrayArrayOp(
                        ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                        ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                        null,
                        null,
                        opType,
                        ovlOp,
                        this.sourceContext));
                } else {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetGeneralizedArrayArrayOp(
                        ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                        null,
                        ((INDEXER)right_operand).indices,
                        opType,
                        ovlOp,
                        this.sourceContext));
                }
            } else {
                if (!rightIsIndexer) {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetGeneralizedArrayArrayOp(
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                        ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                        ((INDEXER)left_operand).indices,
                        null,
                        opType,
                        ovlOp,
                        this.sourceContext));
                } else {
                    call.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetGeneralizedArrayArrayOp(
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                        ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                        ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                        ((INDEXER)left_operand).indices,
                        ((INDEXER)right_operand).indices,
                        opType,
                        ovlOp,
                        this.sourceContext));
                }
            }

            call.Type = resType.convert() as TypeNode;
            return call;
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            NODE.doShift(shift);
            System.Console.WriteLine("LEFT OPERAND");
            if (left_operand == null) {
                NODE.doShift(shift);
                System.Console.WriteLine("MISSED");
            } else
                left_operand.report(shift+NODE.reportShift);
            NODE.doShift(shift);
            System.Console.WriteLine("RIGHT OPERAND");
            if (right_operand == null) {
                NODE.doShift(shift);
                System.Console.WriteLine("MISSED");
            } else
                right_operand.report(shift+NODE.reportShift);
        }
#endif
    }

    public sealed class ASSIGNMENT_OPERATOR : BINARY {
        public ASSIGNMENT_OPERATOR ( string c ) : base(ASTNodeType.ASSIGNMENT_OPERATOR, c) { }

        public override object calculate() { return null; }
        public override Node convert()     { return null; }
        public override TYPE type          { get { return null; } set { } }
    }

    // PLUS
    // ====
    //
    public sealed class PLUS : BINARY {
        // Constructor
        public PLUS ( ) : base(ASTNodeType.PLUS, "+") { }

        NodeType opPlus; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val,type, sourceContext);
                return node;
            }

            // Operands are converted by base.convert()
            Expression plus = (Expression)base.convert();
            if (node != null)
                return node;

            if ( left_operand.type is SET_TYPE ) // the second type should be also SET
            {
                // Adding set to set; it is implemented as 'OR'
                plus.NodeType = NodeType.Or;
            } else if (left_operand.type is STRING_TYPE) {
                plus.NodeType = NodeType.Add;
            } else if ((left_operand.type is CARDINAL_TYPE) && (right_operand.type is CARDINAL_TYPE)) {
                plus.NodeType = NodeType.Add_Ovf_Un;
            } else if (((left_operand.type is REAL_TYPE) || (right_operand.type is REAL_TYPE))
                &&
                  !(left_operand.type is ARRAY_TYPE) && !(right_operand.type is ARRAY_TYPE)) {
                plus.NodeType = NodeType.Add;
            } else if (((left_operand.type is INTEGER_TYPE) || (right_operand.type is INTEGER_TYPE))
                &&
                  !(left_operand.type is ARRAY_TYPE) && !(right_operand.type is ARRAY_TYPE)) {
				plus.NodeType = NodeType.Add_Ovf;
            } else if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opPlus, type);
            } else if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opPlus, type);
            } else if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opPlus, type);
            } else // "Simple" types
			{
				plus.NodeType = NodeType.Add;
			}
            node = plus;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;
            checked{
                try {
                    if (type is SET_TYPE)
                        base.val = (ulong)val1 | (ulong)val2;

                      // Possible types: long/ulong, double, string
                    else if (val1 is ulong && val2 is ulong)
                        base.val = (ulong)val1 + (ulong)val2;
                    else if (val1 is ulong && val2 is long)
                        base.val = (long)(ulong)val1 + (long)val2;
                    else if (val1 is ulong && val2 is double)
                        base.val = (double)(ulong)val1 + (double)val2;
                    else if (val1 is long && val2 is ulong)
                        base.val = (long)val1 + (long)(ulong)val2;
                    else if (val1 is long && val2 is long)
                        base.val = (long)val1 + (long)val2;
                    else if (val1 is long && val2 is double)
                        base.val = (double)(long)val1 + (double)val2;
                    else if (val1 is double && val2 is ulong)
                        base.val = (double)val1 + (double)(ulong)val2;
                    else if (val1 is double && val2 is long)
                        base.val = (double)val1 + (double)(long)val2;
                    else if (val1 is double && val2 is double)
                        base.val = (double)val1 + (double)val2;
                    else if (val1 is string && val2 is string)
                        base.val = (string)val1 + (string)val2;
                    else {
                        ERROR.SystemErrorIn("PLUS.calculate", "illegal operand type(s)");
                        return null;
                    }
                } catch (OverflowException) {
                ERROR.ConstantComputationOverflow(sourceContext);
                return null;
            }
        }
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((opPlus == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            //#region compute math
            //{
            //    MathTypeCheckResult mathCheckResult;
            //    if (MATH_TYPE.CheckElementWise(left_operand.type, right_operand.type, new MathTypeCheckErrorInfo(sourceContext, "+")).TryGetValue(out mathCheckResult)) {
            //        if (mathCheckResult.ResultType == null) {
            //            ErrorReported = true;
            //            return false;
            //        } else {
            //            return true;
            //        }
            //    }
            //}
            //#endregion

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "+", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "+", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "+", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false; 
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, "+", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }

                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "+", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public TYPE GetType(TYPE type1, TYPE type2, ref NodeType opPlus_) {
            TYPE t = GetType(type1, type2, false);
            opPlus_ = opPlus;
            return t;
        }
        
        //-------------------------------------------------------------------------------------

        /// <summary>
        /// returns the result type of the sum of two variables of types
        /// type1 and type2
        /// </summary>
        /// <param name="type1"></param>
        /// <param name="type2"></param>
        /// <returns></returns>
        private TYPE GetType(TYPE type1, TYPE type2, bool wasArray) {
            if (type1 == null || type2 == null)
                return null;

            // Legal types for operands of binary '+': INTEGER, CARDINAL, REAL, SET.
            //
            // Result types for binary plus: INTEGER  + INTEGER  => INTEGER;
            //                               CARDINAL + INTEGER  => INTEGER
            //                               CARDINAL + CARDINAL => CARDINAL
            //                               INTEGRAL + REAL     => REAL;
            //                               REAL     + REAL     => REAL;
            //                               SET      + SET      => SET;
            // ????????                      STRING   + STRING   => STRING.
            // All other combinations are illegal.

            long w1, w2;

            if (type1 is INTEGER_TYPE && type2 is INTEGER_TYPE) {
                w1 = ((INTEGER_TYPE)type1).width;
                w2 = ((INTEGER_TYPE)type2).width;
                opPlus = NodeType.Add_Ovf;
                return new INTEGER_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is CARDINAL_TYPE && type2 is CARDINAL_TYPE) {
                w1 = ((CARDINAL_TYPE)type1).width;
                w2 = ((CARDINAL_TYPE)type2).width;
                opPlus = NodeType.Add_Ovf_Un;
                return new CARDINAL_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is INTEGER_TYPE && type2 is CARDINAL_TYPE) {
                w1 = ((INTEGER_TYPE)type1).width;
                w2 = ((CARDINAL_TYPE)type2).width;
                opPlus = NodeType.Add_Ovf;
                return new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
            }
            if (type1 is CARDINAL_TYPE && type2 is INTEGER_TYPE) {
                w1 = ((CARDINAL_TYPE)type1).width;
                w2 = ((INTEGER_TYPE)type2).width;
                opPlus = NodeType.Add_Ovf;
                return new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
            }
            if (type1 is REAL_TYPE && (type2 is INTEGER_TYPE || type2 is CARDINAL_TYPE) ||
                      type2 is REAL_TYPE && (type1 is INTEGER_TYPE || type1 is CARDINAL_TYPE)) {
                opPlus = NodeType.Add;
                return new REAL_TYPE(64); // 32 
            }
            if (type1 is REAL_TYPE && type2 is REAL_TYPE) {
                w1 = ((REAL_TYPE)type1).width;
                w2 = ((REAL_TYPE)type2).width;
                opPlus = NodeType.Add;
                return new REAL_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is SET_TYPE && type2 is SET_TYPE) {
                w1 = ((SET_TYPE)type1).width;
                w2 = ((SET_TYPE)type2).width;
                opPlus = NodeType.Or;
                return new SET_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is STRING_TYPE && type2 is STRING_TYPE) {
                return new STRING_TYPE();
            }

            if (!CONTEXT.firstPass) {
                NODE call = null;
                if (!wasArray) {
                    call = base.resolveOperator();
                } else {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1, type2);
                    if (op == null)
                        return null; //this operation was not declared

                    opPlus = NodeType.MethodCall;
                    ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                    return op.return_type;
                }
                if (call is CALL) {
                    this.call = (CALL)call;
                    opPlus = NodeType.MethodCall;
                    return call.type;
                }
            }

            if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                if (rank_left != rank_right) { return null; } else {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    res.const_dimensions = new int[rank_left];
                    
                    if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be calculated now
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                return null;
                            else {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                                
                            }
                            res.isOpen = false;
                        }
                    }
                    
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;

                    res.base_type = GetType(((ARRAY_TYPE)type1).base_type, ((ARRAY_TYPE)type2).base_type, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }
            }

            if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)type2).dimensions.Length;

                if (rank_left != rank_right) { return null; } else {
                    SPARSE_TYPE res = new SPARSE_TYPE();
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;
                    res.isVector = rank_left == 1;

                    res.base_type = GetType(((SPARSE_TYPE)type1).base_type, ((SPARSE_TYPE)type2).base_type, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }
            }

            if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                //2 cases are possible: 
                //array-scalar plus => array
                //scalar-array plus => array

                int arrayRank = 0;
                TYPE returnArrayBaseType;

                ARRAY_TYPE res = new ARRAY_TYPE();
                res.isMath = true;
                res.isOpen = true;

                if (type1 is ARRAY_TYPE) {
                    arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                    returnArrayBaseType = GetType(((ARRAY_TYPE)type1).base_type, type2, true);
                    if (returnArrayBaseType == null)
                        return null;

                    res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                } else {
                    arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                    returnArrayBaseType = GetType(type1, ((ARRAY_TYPE)type2).base_type, true);
                    if (returnArrayBaseType == null)
                        return null;

                    res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                }

                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;

                return res;
            }

            return null;
        }
        
        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for binary +
        {
            get {
                if ( internal_type != null && !(internal_type is ANY_TYPE) )
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ANY_TYPE || type2 is ANY_TYPE) {
                    internal_type = new ANY_TYPE();
                    return internal_type;
                }

                //#region compute math
                //{
                //    MathTypeCheckResult mathTypeResult;
                //    if (MATH_TYPE.CheckElementWise(type1, type2, null).TryGetValue(out mathTypeResult)) {
                //        return mathTypeResult.ResultType;
                //    }
                //}
                //#endregion

                internal_type = GetType(type1, type2, false);

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext,"+",type1.ToString(),type2.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("PLUS +; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // MINUS
    // =====
    //
    public sealed class MINUS : BINARY {
        // Constructor
        public MINUS ( ) : base(ASTNodeType.MINUS, "-") { }

        NodeType opMinus; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val,type, sourceContext);
                return node;
            }
            Expression minus = (Expression)base.convert();
            if (node != null)
                return node;

			if ( left_operand.type is SET_TYPE ) // the second type should be also SET
			{
				// Subtracting sets:
				// s1-s2 == s1 * (-s2)
				BinaryExpression min = minus as BinaryExpression;

				UnaryExpression right = new UnaryExpression();
				right.Operand = min.Operand2;
				right.NodeType = NodeType.Not;

				BinaryExpression mult = new BinaryExpression();
				mult.Operand1 = min.Operand1;
				mult.Operand2 = right;
				mult.NodeType = NodeType.And;

				node = mult;
            } else if ((left_operand.type is CARDINAL_TYPE) && (right_operand.type is CARDINAL_TYPE)) {
                minus.NodeType = NodeType.Sub_Ovf_Un;
				node = minus;
            } else if (((left_operand.type is REAL_TYPE) || (right_operand.type is REAL_TYPE))
                &&
                  !(left_operand.type is ARRAY_TYPE) && !(right_operand.type is ARRAY_TYPE)) {
                minus.NodeType = NodeType.Sub;
                node = minus;
            } else if (((left_operand.type is INTEGER_TYPE) || (right_operand.type is INTEGER_TYPE))
                &&
                  !(left_operand.type is ARRAY_TYPE) && !(right_operand.type is ARRAY_TYPE)) {
				minus.NodeType = NodeType.Sub_Ovf;
				node = minus;
            } else if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opMinus, type);
            } else if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opMinus, type);
            } else if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opMinus, type);
            } else // "Simple" types
			{
				minus.NodeType = NodeType.Sub;				
				node = minus;
			}
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;
            try {
                checked {
                    if (type is SET_TYPE) /* s1-s2 == s1 * (-s2) */
                        base.val = (ulong)val1 & ~(ulong)val2;
                // Possible types: long/ulong, double
                    else if (val1 is ulong && val2 is ulong)
                        base.val = (ulong)val1 - (ulong)val2;
                    else if (val1 is ulong && val2 is long)
                        base.val = (long)(ulong)val1 - (long)val2;
                    else if (val1 is ulong && val2 is double)
                        base.val = (double)(ulong)val1 - (double)val2;
                    else if (val1 is long && val2 is ulong)
                        base.val = (long)val1 - (long)(ulong)val2;
                    else if (val1 is long && val2 is long)
                        base.val = (long)val1 - (long)val2;
                    else if (val1 is long && val2 is double)
                        base.val = (double)(long)val1 - (double)val2;
                    else if (val1 is double && val2 is ulong)
                        base.val = (double)val1 - (double)(ulong)val2;
                    else if (val1 is double && val2 is long)
                        base.val = (double)val1 - (double)(long)val2;
                    else if (val1 is double && val2 is double)
                        base.val = (double)val1 - (double)val2;
                    else {
                    ERROR.SystemErrorIn("MINUS.calculate","illegal operand type(s)");
                    return null;
                }
            }
            } catch (OverflowException) {
            ERROR.ConstantComputationOverflow(sourceContext);
            return null;
        }

            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((opMinus == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            //#region compute math
            //{
            //    MathTypeCheckResult mathCheckResult;
            //    if (MATH_TYPE.CheckElementWise(left_operand.type, right_operand.type, new MathTypeCheckErrorInfo(sourceContext, "+")).TryGetValue(out mathCheckResult)) {
            //        if (mathCheckResult.ResultType == null) {
            //            ErrorReported = true;
            //            return false;
            //        } else {
            //            return true;
            //        }
            //    }
            //}
            //#endregion

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "-", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "-", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "-", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, "-", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }

                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "-", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        /// <summary>
        /// returns the result type of the subtraction of two variables of types
        /// type1 and type2
        /// </summary>
        /// <param name="type1"></param>
        /// <param name="type2"></param>
        /// <returns></returns>
        private TYPE GetType(TYPE type1, TYPE type2, bool wasArray) {
            if (type1 == null || type2 == null)
                return null;

            // Legal types for operands of binary '-': INTEGER, CARDINAL, REAL, SET.
            //
            // Result types for binary minuw: INTEGER  - INTEGER  => INTEGER;
            //                                CARDINAL - INTEGER  => INTEGER
            //                                CARDINAL - CARDINAL => CARDINAL
            //                                INTEGRAL - REAL     => REAL;
            //                                REAL     - REAL     => REAL;
            //                                SET      - SET      => SET.
            // All other combinations are illegal.

            long w1, w2;

            if (type1 is INTEGER_TYPE && type2 is INTEGER_TYPE) {
                w1 = ((INTEGER_TYPE)type1).width;
                w2 = ((INTEGER_TYPE)type2).width;
                opMinus = NodeType.Sub_Ovf;
                return new INTEGER_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is CARDINAL_TYPE && type2 is CARDINAL_TYPE) {
                w1 = ((CARDINAL_TYPE)type1).width;
                w2 = ((CARDINAL_TYPE)type2).width;
                opMinus = NodeType.Sub_Ovf_Un;
                return new CARDINAL_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is INTEGER_TYPE && type2 is CARDINAL_TYPE) {
                w1 = ((INTEGER_TYPE)type1).width;
                w2 = ((CARDINAL_TYPE)type2).width;
                opMinus = NodeType.Sub_Ovf;
                return new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
            }
            if (type1 is CARDINAL_TYPE && type2 is INTEGER_TYPE) {
                w1 = ((CARDINAL_TYPE)type1).width;
                w2 = ((INTEGER_TYPE)type2).width;
                opMinus = NodeType.Sub_Ovf;
                return new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
            }
            if (type1 is REAL_TYPE && (type2 is INTEGER_TYPE || type2 is CARDINAL_TYPE) ||
                      type2 is REAL_TYPE && (type1 is INTEGER_TYPE || type1 is CARDINAL_TYPE)) {
                opMinus = NodeType.Sub;
                return new REAL_TYPE(64); // 32 
            }
            if (type1 is REAL_TYPE && type2 is REAL_TYPE) {
                w1 = ((REAL_TYPE)type1).width;
                w2 = ((REAL_TYPE)type2).width;
                opMinus = NodeType.Sub;
                return new REAL_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is SET_TYPE && type2 is SET_TYPE) {
                w1 = ((SET_TYPE)type1).width;
                w2 = ((SET_TYPE)type2).width;
                return new SET_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is STRING_TYPE && type2 is STRING_TYPE) {
                return new STRING_TYPE();
            }

            if (!CONTEXT.firstPass) {
                NODE call = null;
                if (!wasArray) {
                    call = base.resolveOperator();
                } else {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1, type2);
                    opMinus = NodeType.MethodCall;
                    ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                    return op.return_type;
                }
                if (call is CALL) {
                    this.call = (CALL)call;
                    opMinus = NodeType.MethodCall;
                    return call.type;
                }
            }

            //#region compute math
            //{
            //    MATH_TYPE mathType1;
            //    MATH_TYPE mathType2;
            //    if (type1.Is(out mathType1) && type2.Is(out mathType2)) {
            //        ComputeType mathTypeDetails1;
            //        ComputeType mathTypeDetails2;
            //        if (mathType1.Details.TryGetValue(out mathTypeDetails1) && mathType2.Details.TryGetValue(out mathTypeDetails2)) {
            //            if (mathTypeDetails1.ScalarType != mathTypeDetails2.ScalarType) {
            //                return null;
            //            }
            //            if (mathTypeDetails1.Rank == 0 || mathTypeDetails1.Rank == mathTypeDetails2.Rank) {
            //                return mathType2;
            //            } else if (mathTypeDetails2.Rank == 0) {
            //                return mathType1;
            //            } else {
            //                return null;
            //            }
            //        }
            //    }
            //}
            //#endregion

            if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                if (rank_left != rank_right) { return null; } else {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    res.const_dimensions = new int[rank_left];

                    if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be calculated now
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                return null;
                            else
                                res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                            res.isOpen = false;
                        }
                    }

                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;

                    res.base_type = GetType(((ARRAY_TYPE)type1).base_type, ((ARRAY_TYPE)type2).base_type, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }
            }

            if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)type2).dimensions.Length;

                if (rank_left != rank_right) { return null; } else {
                    SPARSE_TYPE res = new SPARSE_TYPE();
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;
                    res.isVector = rank_left == 1;

                    res.base_type = GetType(((SPARSE_TYPE)type1).base_type, ((SPARSE_TYPE)type2).base_type, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }
            }

            if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                //2 cases are possible: 
                //array-scalar minus => array
                //scalar-array minus => array

                int arrayRank = 0;
                TYPE returnArrayBaseType;

                ARRAY_TYPE res = new ARRAY_TYPE();
                res.isMath = true;
                res.isOpen = true;

                if (type1 is ARRAY_TYPE) {
                    arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                    returnArrayBaseType = GetType(((ARRAY_TYPE)type1).base_type, type2, true);
                    if (returnArrayBaseType == null)
                        return null;

                    res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                } else {
                    arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                    returnArrayBaseType = GetType(type1, ((ARRAY_TYPE)type2).base_type, true);
                    if (returnArrayBaseType == null)
                        return null;

                    res.const_dimensions = new int[arrayRank];
                    
                    if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                }

                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;

                return res;
            }

            return null;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for binary -
        {
            get {
                if ( internal_type != null && !(internal_type is ANY_TYPE) )
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                internal_type = GetType(type1, type2, false);

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    this.ErrorReported = true;
                    ERROR.IllegalTypeForBinOperator(this.sourceContext,"-",type1.ToString(),type2.ToString());
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }


        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("MUNIS -; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // MULTIPLY
    // ========
    //
    public sealed class MULTIPLY : BINARY {
        // Constructor
        public MULTIPLY() : base(ASTNodeType.MULTIPLY, "*") { ovlOpPlus = null; }

        private NodeType opPlus, opMult; //operations for IsMath operations with arrays

        private QualifiedIdentifier ovlOpPlus; //for matrix-matrix multiplication we need 2 overloaded operations, the first is declared in BINARY
        private bool isRetTypeSystem; //Whether the return type is a system type (like int or double)

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val,type, sourceContext);
                return node;
            }
            Expression mult = (Expression)base.convert();
            if (node != null)
                return node;

            if (type is ARRAY_TYPE) {
                TYPE t1 = ((ARRAY_TYPE)type).base_type;
                if ((t1 is INTEGER_TYPE) || (t1 is CARDINAL_TYPE) ||
                (t1 is REAL_TYPE) || (t1 is SET_TYPE))
                    isRetTypeSystem = true;
            else
                    isRetTypeSystem = false;
            } else {
                if ((type is INTEGER_TYPE) || (type is CARDINAL_TYPE) ||
                (type is REAL_TYPE) || (type is SET_TYPE))
                    isRetTypeSystem = true;
                else
                    isRetTypeSystem = false;
            }

            if ( left_operand.type is SET_TYPE ) // the second type should be also SET
            {
                // Multiplying sets; it is implemented as &
                mult.NodeType = NodeType.And;
                node = mult;
                return node;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {

                bool leftIsIndexer = left_operand is INDEXER;
                bool rightIsIndexer = right_operand is INDEXER;

                MethodCall call = new MethodCall();
                call.Operands = new ExpressionList();

                if (!leftIsIndexer) {
                    //bool __gpu__ = true;
                    //if (__gpu__) {
                    //    MemberBinding expr = new MemberBinding(left_operand.convert() as Expression, STANDARD.Data.GetProperty(Identifier.For("HostArray")));
                    //    BinaryExpression cast = new BinaryExpression(expr, new MemberBinding(null, ((ARRAY_TYPE)left_operand.type).GetOriginalType()),
                    //                                   NodeType.Castclass);
                    //    call.Operands.Add(cast);
                    //} else {
                    call.Operands.Add(left_operand.convert() as Expression);
                    //}
                } else
                    call.Operands.Add(((INDEXER)left_operand).left_part.convert() as Expression);
                if (!rightIsIndexer) {
                    //bool __gpu__ = true;
                    //if (__gpu__) {
                    //    MemberBinding expr = new MemberBinding(right_operand.convert() as Expression, STANDARD.Data.GetProperty(Identifier.For("HostArray")));
                    //    BinaryExpression cast = new BinaryExpression(expr, new MemberBinding(null, ((ARRAY_TYPE)right_operand.type).GetOriginalType()),
                    //                                   NodeType.Castclass);
                    //    call.Operands.Add(cast);
                    //} else {
                    call.Operands.Add(right_operand.convert() as Expression);
                    //}
                } else {
                    call.Operands.Add(((INDEXER)right_operand).left_part.convert() as Expression);
                }

                if (leftIsIndexer) {
                    EXPRESSION_LIST indices = ((INDEXER)left_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }
                if (rightIsIndexer) {
                    EXPRESSION_LIST indices = ((INDEXER)right_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }

                if (!leftIsIndexer) {
                    if (!rightIsIndexer) {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMatrixMultiplication(
                            ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                            null,
                            null,
                            ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                            (type is ARRAY_TYPE) ? ((ARRAY_TYPE)type).base_type.convert() as TypeNode : type.convert() as TypeNode,
                            isRetTypeSystem,
                            opPlus,
                            ovlOpPlus,
                            opMult,
                            ovlOp,
                                this.sourceContext
                            )
                        );
                    } else {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMatrixMultiplication(
                            ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                            null,
                            ((INDEXER)right_operand).indices,
                            ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                            (type is ARRAY_TYPE) ? ((ARRAY_TYPE)type).base_type.convert() as TypeNode : type.convert() as TypeNode,
                            isRetTypeSystem,
                            opPlus,
                            ovlOpPlus,
                            opMult,
                            ovlOp,
                            this.sourceContext));
                    }
                } else {
                    if (!rightIsIndexer) {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMatrixMultiplication(
                            ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                            ((INDEXER)left_operand).indices,
                            null,
                            ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                            (type is ARRAY_TYPE) ? ((ARRAY_TYPE)type).base_type.convert() as TypeNode : type.convert() as TypeNode,
                            isRetTypeSystem,
                            opPlus,
                            ovlOpPlus,
                            opMult,
                            ovlOp,
                            this.sourceContext));
                    } else {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMatrixMultiplication(
                            ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                            ((INDEXER)left_operand).indices,
                            ((INDEXER)right_operand).indices,
                            ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                            (type is ARRAY_TYPE) ? ((ARRAY_TYPE)type).base_type.convert() as TypeNode : type.convert() as TypeNode,
                            isRetTypeSystem,
                            opPlus,
                            ovlOpPlus,
                            opMult,
                            ovlOp,
                            this.sourceContext));
                    } 
                }

                call.Type = type.convert() as TypeNode;
                return call;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                MethodCall call = new MethodCall();
                call.Operands = new ExpressionList();
                call.Operands.Add(left_operand.convert() as Expression);
                call.Operands.Add(right_operand.convert() as Expression);

                call.Callee = new MemberBinding(null,
                    CONTEXT.globalMath.GetSparseMatrixMultiplication(
                        ((SPARSE_TYPE)left_operand.type).dimensions.Length,
                        ((SPARSE_TYPE)right_operand.type).dimensions.Length,
                        ((SPARSE_TYPE)left_operand.type).base_type.convert() as TypeNode,
                        ((SPARSE_TYPE)right_operand.type).base_type.convert() as TypeNode,
                        (type is SPARSE_TYPE) ? ((SPARSE_TYPE)type).base_type.convert() as TypeNode : type.convert() as TypeNode,
                        opPlus,
                        opMult,
                        this.sourceContext));

                call.Type = type.convert() as TypeNode;
                return call;
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opMult, type);
            }

            // else -- "Simple" types
            if ((left_operand.type is CARDINAL_TYPE) && (right_operand.type is CARDINAL_TYPE)) {
                mult.NodeType = NodeType.Mul_Ovf_Un;//error on Mono
#if ROTOR
                mult.NodeType = NodeType.Mul;
#endif
            } else if ((left_operand.type is REAL_TYPE) || (right_operand.type is REAL_TYPE)) {
                mult.NodeType = NodeType.Mul;
            } else if ((left_operand.type is INTEGER_TYPE) || (right_operand.type is INTEGER_TYPE)) {
				mult.NodeType = NodeType.Mul_Ovf;
            } else {
				mult.NodeType = NodeType.Mul;
			}
            node = mult;
        //  BinaryExpression b = new BinaryExpression();
        //  b.Operand1 = mult;
        //  b.Operand2 = new MemberBinding(null,SystemTypes.Int32);
        //  b.NodeType = NodeType.Castclass;
        //  node = b;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            if (type is SET_TYPE)
                base.val = (ulong)val1 & (ulong)val2;

            // Possible types: long/ulong, double
            else if (val1 is ulong && val2 is ulong)
                base.val = (ulong)val1 * (ulong)val2;
            else if (val1 is ulong && val2 is long)
                base.val = (long)(ulong)val1 * (long)val2;
            else if (val1 is ulong && val2 is double)
                base.val = (double)(ulong)val1 * (double)val2;
            else if (val1 is long && val2 is ulong)
                base.val = (long)val1 * (long)(ulong)val2;
            else if (val1 is long && val2 is long)
                base.val = (long)val1 * (long)val2;
            else if (val1 is long && val2 is double)
                base.val = (double)(long)val1 * (double)val2;
            else if (val1 is double && val2 is ulong)
                base.val = (double)val1 * (double)(ulong)val2;
            else if (val1 is double && val2 is long)
                base.val = (double)val1 * (double)(long)val2;
            else if (val1 is double && val2 is double)
                base.val = (double)val1 * (double)val2;
            else {
                ERROR.SystemErrorIn("MULTIPLY.calculate","illegal operand type(s)");
                return null;
            }
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check types ???!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((opMult == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "*", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "*", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                //matrix-matrix multiplication
                //arrays have to be 1 or 2 dimensional

                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left == 2) && ((rank_right == 1) || (rank_right == 2))) {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[1] != 0) &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0) &&
                        ((((ARRAY_TYPE)left_operand.type).const_dimensions[1] !=
                        ((ARRAY_TYPE)right_operand.type).const_dimensions[0]))) {
                        ERROR.IncompatibleSizes(this.sourceContext, "*", left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false;
                    }
                } else if ((rank_left == 1) && ((rank_right == 1) || (rank_right == 2))) {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0) &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0) &&
                        ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] !=
                        ((ARRAY_TYPE)right_operand.type).const_dimensions[0]))) {
                        ERROR.IncompatibleSizes(this.sourceContext, "*", left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false;
                    }
                } else // if ((rank_left < 1) || (rank_left > 2) || (rank_right < 1) || (rank_right > 2))
                {
                    ERROR.IncorrectRanksForBinMatrixOp(this.sourceContext, "*",
                        left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }

                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return true;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        /// <summary>
        /// returns the result type of the multiplication of two variables of types
        /// type1 and type2
        /// </summary>
        /// <param name="type1"></param>
        /// <param name="type2"></param>
        /// <returns></returns>
        private TYPE GetType(TYPE type1, TYPE type2, bool was1Array, bool was2Array) {
            if (type1 == null || type2 == null)
                return null;

            // Legal types for operands of binary '*': INTEGER, CARDINAL, REAL, SET.
            //
            // Result types for binary *: INTEGER  * INTEGER  => INTEGER;
            //                            CARDINAL * CARDINAL => CARDINAL;
            //                            CARDINAL * INTEGER  => INTEGER;
            //                            INTEGER  * REAL     => REAL;
            //                            REAL     * REAL     => REAL;
            //                            SET      * SET      => SET.
            // All other combinations are illegal.

            long w1, w2;

            if (type1 is INTEGER_TYPE && type2 is INTEGER_TYPE) {
                w1 = ((INTEGER_TYPE)type1).width;
                w2 = ((INTEGER_TYPE)type2).width;
                opPlus = NodeType.Add_Ovf;
                opMult = NodeType.Mul_Ovf;
                return new INTEGER_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is CARDINAL_TYPE && type2 is CARDINAL_TYPE) {
                w1 = ((CARDINAL_TYPE)type1).width;
                w2 = ((CARDINAL_TYPE)type2).width;
                opPlus = NodeType.Add_Ovf_Un;
                opMult = NodeType.Mul_Ovf_Un; //error on Mono
#if ROTOR
                opMult = NodeType.Mul;
#endif
                return new CARDINAL_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is INTEGER_TYPE && type2 is CARDINAL_TYPE) {
                w1 = ((INTEGER_TYPE)type1).width;
                w2 = ((CARDINAL_TYPE)type2).width;
                opPlus = NodeType.Add_Ovf;
                opMult = NodeType.Mul_Ovf;
                return new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2*w1) : w2));
            }
            if (type1 is CARDINAL_TYPE && type2 is INTEGER_TYPE) {
                w1 = ((CARDINAL_TYPE)type1).width;
                w2 = ((INTEGER_TYPE)type2).width;
                opPlus = NodeType.Add_Ovf;
                opMult = NodeType.Mul_Ovf;
                return new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
            }
            if (type1 is REAL_TYPE && (type2 is INTEGER_TYPE || type2 is CARDINAL_TYPE) ||
                      type2 is REAL_TYPE && (type1 is INTEGER_TYPE || type1 is CARDINAL_TYPE)) {
                opPlus = NodeType.Add;
                opMult = NodeType.Mul;
                return new REAL_TYPE(64); // 32 
            }
            if (type1 is REAL_TYPE && type2 is REAL_TYPE) {
                w1 = ((REAL_TYPE)type1).width;
                w2 = ((REAL_TYPE)type2).width;
                opPlus = NodeType.Add;
                opMult = NodeType.Mul;
                return new REAL_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is SET_TYPE && type2 is SET_TYPE) {
                w1 = ((SET_TYPE)type1).width;
                w2 = ((SET_TYPE)type2).width;
                opPlus = NodeType.Or;
                opMult = NodeType.And;
                return new SET_TYPE(w1 > w2 ? w1 : w2);
            }

            if (!CONTEXT.firstPass) {
                NODE call = null;
                if (!was1Array && !was2Array) {
                    call = base.resolveOperator();
                } else {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1, type2);
                    if (op == null)
                        return null; //this operation was not declared
                    opMult = NodeType.MethodCall;
                    opPlus = 0;
                    ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                    if (was1Array ^ was2Array) //it wasn't matrix-matrix multiplication, it was array-scalar multiplication => we don't need opPlus
                    {
                        return op.return_type;
                    } else //matrix-matrix multiplication, we have to define plus
                    {
                        PLUS plus = new PLUS();
                        plus.left_operand = left_operand;
                        plus.right_operand = right_operand;
                        TYPE typePlus = plus.GetType(op.return_type, op.return_type, ref opPlus);
                        if (typePlus == null) {
                            OPERATOR_DECL op1 = plus.findBestOpDeclForBinaryOperator(op.return_type, op.return_type);
                            if (op1 == null)
                                return null;
                            opPlus = NodeType.MethodCall;
                            ovlOpPlus = (INSTANCE.create(op1)).convert() as QualifiedIdentifier;
                            typePlus = op1.return_type;
                        }
                        return typePlus;
                    }
                }
                if (call is CALL) {
                    this.call = (CALL)call;
                    opMult = NodeType.MethodCall;
                    return call.type;
                }
            }

            if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                //3 cases are possible: 
                //matrix-matrix multiplication => matrix (2d array)
                //matrix-vector multiplication => vector (1d array)
                //vector-vector multiplication => scalar

                int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                if ((rank_left == 2) && (rank_right == 2)) {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    res.const_dimensions = new int[2];
                    res.dimensions = new EXPRESSION_LIST(2);
                    res.dimensions.Length = 2;

                    if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be calculated now
                        if (((ARRAY_TYPE)left_operand.type).const_dimensions[1] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[0])
                            return null;
                        res.const_dimensions[0] = ((ARRAY_TYPE)type1).const_dimensions[0];
                        res.const_dimensions[1] = ((ARRAY_TYPE)type2).const_dimensions[1];
                        res.isOpen = false;
                    }

                    res.base_type = GetType(((ARRAY_TYPE)type1).base_type, ((ARRAY_TYPE)type2).base_type, true, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }

                if (((rank_left == 2) && (rank_right == 1)) ||
                    ((rank_left == 1) && (rank_right == 2))) {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    res.const_dimensions = new int[1];
                    res.dimensions = new EXPRESSION_LIST(1);
                    res.dimensions.Length = 1;

                    if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be calculated now
                        if (rank_left == 2) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[1] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[0])
                                return null;
                            res.const_dimensions[0] = ((ARRAY_TYPE)type1).const_dimensions[0];
                        } else {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[0] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[0])
                                return null;
                            res.const_dimensions[0] = ((ARRAY_TYPE)type1).const_dimensions[0];
                        }
                        res.isOpen = false;
                    }

                    res.base_type = GetType(((ARRAY_TYPE)type1).base_type, ((ARRAY_TYPE)type2).base_type, true, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }

                if ((rank_left == 1) && (rank_right == 1)) {
                    if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                        if (((ARRAY_TYPE)left_operand.type).const_dimensions[0] !=
                            ((ARRAY_TYPE)right_operand.type).const_dimensions[0])
                            return null;
                    }

                    return GetType(((ARRAY_TYPE)type1).base_type, ((ARRAY_TYPE)type2).base_type, true, true);
                }

                return null;
            }

            if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                //3 cases are possible: 
                //matrix-matrix multiplication => matrix (2d array)
                //matrix-vector multiplication => vector (1d array)
                //vector-vector multiplication => scalar

                int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)type2).dimensions.Length;

                if ((rank_left == 2) && (rank_right == 2)) {
                    SPARSE_TYPE res = new SPARSE_TYPE();
                    res.dimensions = new EXPRESSION_LIST(2);
                    res.dimensions.Length = 2;
                    res.isVector = false;

                    res.base_type = GetType(((SPARSE_TYPE)type1).base_type, ((SPARSE_TYPE)type2).base_type, true, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }

                if (((rank_left == 2) && (rank_right == 1)) ||
                    ((rank_left == 1) && (rank_right == 2))) {
                    SPARSE_TYPE res = new SPARSE_TYPE();
                    res.dimensions = new EXPRESSION_LIST(1);
                    res.dimensions.Length = 1;
                    res.isVector = true;

                    res.base_type = GetType(((SPARSE_TYPE)type1).base_type, ((SPARSE_TYPE)type2).base_type, true, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }

                if ((rank_left == 1) && (rank_right == 1)) {
                    return GetType(((SPARSE_TYPE)type1).base_type, ((SPARSE_TYPE)type2).base_type, true, true);
                }

                return null;
            }

            if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                //2 cases are possible: 
                //array-scalar multiplication => array
                //scalar-array multiplication => array

                int arrayRank = 0;
                TYPE returnArrayBaseType;

                ARRAY_TYPE res = new ARRAY_TYPE();
                res.isMath = true;
                res.isOpen = true;

                if (type1 is ARRAY_TYPE) {
                    arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                    returnArrayBaseType = GetType(((ARRAY_TYPE)type1).base_type, type2, true, false);
                    if (returnArrayBaseType == null)
                        return null;

                    res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                } else {
                    arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                    returnArrayBaseType = GetType(type1, ((ARRAY_TYPE)type2).base_type, false, true);
                    if (returnArrayBaseType == null)
                        return null;

                    res.const_dimensions = new int[arrayRank];
                    
                    if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                }

                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;

                return res;
            }

            return null;
        }
        
        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for binary *
        {
            get {
                if ( internal_type != null && !(internal_type is ANY_TYPE) )
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                internal_type = GetType(type1, type2, false, false);

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext,"*",type1.ToString(),type2.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }


        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("MULTIPLY *; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // DIVIDE
    // ======
    //
    public sealed class DIVIDE : BINARY {
        // Constructor
        public DIVIDE ( ) : base(ASTNodeType.DIVIDE, "/") { }

        private NodeType opDiv; //operations for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val,type, sourceContext);
                return node;
            }

            Expression div = (Expression)base.convert();
            if (node != null)
                return node;

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opDiv, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                /**********************************/
                MethodCall call = new MethodCall();
                call.Operands = new ExpressionList();

                bool leftIsIndexer = left_operand is INDEXER;
                bool rightIsIndexer = right_operand is INDEXER;

                if (!leftIsIndexer)
                    call.Operands.Add(left_operand.convert() as Expression);
                else
                    call.Operands.Add(((INDEXER)left_operand).left_part.convert() as Expression);
                if (!rightIsIndexer)
                    call.Operands.Add(right_operand.convert() as Expression);
                else
                    call.Operands.Add(((INDEXER)right_operand).left_part.convert() as Expression);

                if (leftIsIndexer) {
                    EXPRESSION_LIST indices = ((INDEXER)left_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }
                if (rightIsIndexer) {
                    EXPRESSION_LIST indices = ((INDEXER)right_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }

                if (!leftIsIndexer) {
                    if (!rightIsIndexer) {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMainRightLUDivisionOp(
                            ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                            null,
                            null,
                            left_operand.type,
                            right_operand.type,
                            type,
                            this.sourceContext));
                    } else {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMainRightLUDivisionOp(
                            ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                            null,
                            ((INDEXER)right_operand).indices,
                            left_operand.type,
                            right_operand.type,
                            type,
                            this.sourceContext));
                    }
                } else {
                    if (!rightIsIndexer) {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMainRightLUDivisionOp(
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                            ((INDEXER)left_operand).indices,
                            null,
                            left_operand.type,
                            right_operand.type,
                            type,
                            this.sourceContext));
                    } else {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMainRightLUDivisionOp(
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                            ((INDEXER)left_operand).indices,
                            ((INDEXER)right_operand).indices,
                            left_operand.type,
                            right_operand.type,
                            type,
                            this.sourceContext));
                    }
                }

                call.Type = type.convert() as TypeNode;
                return call;
            }


            if ( left_operand.type is SET_TYPE ) // the second type must be also SET
            {
                // Multiplying sets; it is implemented as
                //
                // s1 / s2 == (s1-s2) + (s2-s1)
                //
                // that is, (s1 & ~s2 | s2 & ~s1);

                BinaryExpression org = div as BinaryExpression;
                BinaryExpression main = new BinaryExpression();
                BinaryExpression left = new BinaryExpression();

                UnaryExpression neg1 = new UnaryExpression();
                neg1.Operand = org.Operand2;
                neg1.NodeType = NodeType.Not;
                neg1.Type = org.Operand2.Type;

                left.Operand1 = org.Operand1;
                left.Operand2 = neg1;
                left.NodeType = NodeType.And;
                left.Type = org.Type;

                BinaryExpression right = new BinaryExpression();

                UnaryExpression neg2 = new UnaryExpression();
                neg2.Operand = org.Operand1;
                neg2.NodeType = NodeType.Not;
                neg2.Type = org.Operand1.Type;

                right.Operand1 = org.Operand2;
                right.Operand2 = neg2;
                right.NodeType = NodeType.And;
                right.Type = org.Type;

                main.Operand1 = left;
                main.Operand2 = right;
                main.NodeType = NodeType.Or;
                main.Type = org.Type;

                node = main;
                return node;
            }
         // else -- "Simple" types

            div.NodeType = NodeType.Div;  // Div opcode in CLI is the common one for all kinds of division

            // Herman Venter:
            // You have to wrap the division expression with a UnaryExpression
            // with NodeType.Ckfinite. Unfortunately Resolver would not deal 
            // correctly with this, so you either have to wait for the updated drop,
            // or you have to override Resolver.InferTypeOfUnaryExpression.
            UnaryExpression checkInfinite = new UnaryExpression();
            checkInfinite.NodeType = NodeType.Ckfinite;
            checkInfinite.Operand = div;
            checkInfinite.Type = div.Type;

            node = checkInfinite; // div;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            if (type is SET_TYPE) {
                // s1 / s2 == (s1-s2)+(s2-s1)
                base.val = ((ulong)val1 & ~(ulong)val2) | ((ulong)val2 & ~(ulong)val1);
            } else {
                // Possible types: long/ulong, double
                if ( ( val2 is long   && ((long)val2   == 0  ) ) ||
                     ( val2 is ulong  && ((ulong)val2  == 0L ) ) ||
                     (val2 is double && ((double)val2 == 0.0))) {
                    ERROR.ZeroDivisor(base.right_operand.sourceContext);
                    return null;
                }
                // ======================================================================
                // "Normal" division now ALWAYS gives REAL value - as in Pascal & Oberon!
                // ======================================================================
                double v1 = 0, v2 = 0;
                bool err = false;

                if (val1 is long)
                    v1 = (double)(long)val1;
                else if (val1 is ulong)
                    v1 = (double)(ulong)val1;
                else if (val1 is double)
                    v1 = (double)val1;
                else
                    err = true;

                if (val2 is long)
                    v2 = (double)(long)val2;
                else if (val2 is ulong)
                    v2 = (double)(ulong)val2;
                else if (val2 is double)
                    v2 = (double)val2;
                else
                    err = true;

                if (err) {
                    ERROR.SystemErrorIn("DIVIDE.calculate","illegal operand type(s)");
                    return null;
                }
                base.val = v1/v2;
            }
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check types ???!!!
            if ((opDiv == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            object val2 = base.calculateRight();
            if (val2 != null) {
                if (val2 is double) {
                    if ((double)val2 == 0.0) {
                        ERROR.ZeroDivisor(right_operand.sourceContext);
                        return false;
                    }
                }
                if (val2 is long) {
                    if ((long)val2 == 0) {
                        ERROR.ZeroDivisor(right_operand.sourceContext);
                        return false;
                    }
                } else if (val2 is ulong) {
                    if ((ulong)val2 == 0) {
                        ERROR.ZeroDivisor(right_operand.sourceContext);
                        return false;
                    }
                }
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "/", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "/", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_right == 2) && ((rank_left == 1) || (rank_left == 2))) {
                    if (((ARRAY_TYPE)right_operand.type).const_dimensions[1] != 0) {
                        if ((((ARRAY_TYPE)right_operand.type).const_dimensions[0] !=
                        ((ARRAY_TYPE)right_operand.type).const_dimensions[1])) {
                            ERROR.MatrixIsNotSquare(this.sourceContext, "/", right_operand.type.ToString());
                            ErrorReported = true;
                            return false;
                        }
                        if (((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0) {
                            if (rank_left == 1) {
                                if ((((ARRAY_TYPE)right_operand.type).const_dimensions[1] !=
                                    ((ARRAY_TYPE)left_operand.type).const_dimensions[0])) {
                                    ERROR.IncompatibleSizes(this.sourceContext, "/", left_operand.type.ToString(), right_operand.type.ToString());
                                    ErrorReported = true;
                                    return false;
                                }
                            } else if (rank_left == 2) {
                                if ((((ARRAY_TYPE)right_operand.type).const_dimensions[1] !=
                                    ((ARRAY_TYPE)left_operand.type).const_dimensions[1])) {
                                    ERROR.IncompatibleSizes(this.sourceContext, "/", left_operand.type.ToString(), right_operand.type.ToString());
                                    ErrorReported = true;
                                    return false;
                                }
                            }
                        }
                    }
                } else // if ((rank_right != 2) && ((rank_left != 1) || (rank_left != 2))
                {
                    ERROR.IncorrectRanksForBinMatrixOp(this.sourceContext, "/",
                        left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }

                return true;
            }

            // For integer operands, doing the conversion to real
            if ((left_operand!=null) && (left_operand.type is INTEGER_TYPE))
                left_operand = new TYPE_CONV(left_operand,new REAL_TYPE());
            if ((right_operand != null) && right_operand.type is INTEGER_TYPE)
                right_operand = new TYPE_CONV(right_operand,new REAL_TYPE());

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        /// <summary>
        /// returns the result type of the division of two variables of types
        /// type1 and type2
        /// </summary>
        /// <param name="type1"></param>
        /// <param name="type2"></param>
        /// <returns></returns>
        private TYPE GetType(TYPE type1, TYPE type2, bool wasArray) {
            if (type1 == null || type2 == null)
                return null;

            // Legal types for operands of binary '/': INTEGER, REAL, SET.
            //
            // ======================================================================
            // "Normal" division now ALWAYS gives REAL value - as in Pascal & Oberon!
            // ======================================================================
            //
            // INTEGRAL: { INTEGER + CARDINAL }
            //
            // Result types for binary /: INTEGRAL / INTEGRAL => REAL;
            //                            INTEGRAL / REAL     => REAL;
            //                            REAL     / INTEGRAL => REAL;
            //                            REAL     / REAL     => REAL;
            //                            SET      / SET      => SET.
            // All other combinations are illegal.
            //(excluding IsMath operations with IsMath arrays of course)

            long w1, w2;

            if ((type1 is INTEGER_TYPE || type1 is CARDINAL_TYPE || type1 is REAL_TYPE) &&
                     (type2 is INTEGER_TYPE || type2 is CARDINAL_TYPE || type2 is REAL_TYPE)) {
                opDiv = NodeType.Div;
                return new REAL_TYPE(64); 
            }

            if (type1 is SET_TYPE && type2 is SET_TYPE) {
                opDiv = NodeType.Div;
                w1 = ((SET_TYPE)type1).width;
                w2 = ((SET_TYPE)type2).width;
                return new SET_TYPE(w1 > w2 ? w1 : w2);
            }

            if (!CONTEXT.firstPass) {
                NODE call = null;
                if (!wasArray) {
                    call = base.resolveOperator();
                } else {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1, type2);
                    if (op == null)
                        return null; //this operation was not declared
                    opDiv = NodeType.MethodCall;
                    ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                    return op.return_type;
                }
                if (call is CALL) {
                    this.call = (CALL)call;
                    opDiv = NodeType.MethodCall;
                    return call.type;
                }
            }

            if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                //2 cases are possible: 
                //array-scalar division => array
                //scalar-array division => array

                int arrayRank = 0;
                TYPE returnArrayBaseType;

                ARRAY_TYPE res = new ARRAY_TYPE();
                res.isMath = true;
                res.isOpen = true;

                if (type1 is ARRAY_TYPE) {
                    arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                    returnArrayBaseType = GetType(((ARRAY_TYPE)type1).base_type, type2, true);
                    if (returnArrayBaseType == null)
                        return null;

                    res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                } else {
                    arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                    returnArrayBaseType = GetType(type1, ((ARRAY_TYPE)type2).base_type, true);
                    if (returnArrayBaseType == null)
                        return null;

                    res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                }

                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;

                return res;
            }

            return null;
        }
        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for /
        {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (!CONTEXT.firstPass) {
                    NODE call = null;
                    call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        opDiv = NodeType.MethodCall;
                        return call.type;
                    }
                }

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if ((rank_left == 2) && (rank_right == 2)) {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[2];
                        res.dimensions = new EXPRESSION_LIST(2);
                        res.dimensions.Length = 2;
                        if (((ARRAY_TYPE)type1).base_type is REAL_TYPE)
                            res.base_type = new REAL_TYPE(((REAL_TYPE)((ARRAY_TYPE)type1).base_type).width);
                        else if (((ARRAY_TYPE)type2).base_type is REAL_TYPE)
                            res.base_type = new REAL_TYPE(((REAL_TYPE)((ARRAY_TYPE)type2).base_type).width);
                        else
                            res.base_type = new REAL_TYPE();

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            if (((ARRAY_TYPE)right_operand.type).const_dimensions[0] !=
                                        ((ARRAY_TYPE)right_operand.type).const_dimensions[0])
                                return null; //matrix is not square
                            if (((ARRAY_TYPE)right_operand.type).const_dimensions[1] !=
                                    ((ARRAY_TYPE)left_operand.type).const_dimensions[1])
                                return null; //lengths don't match
                            res.const_dimensions[0] = ((ARRAY_TYPE)type1).const_dimensions[0];
                            res.const_dimensions[1] = ((ARRAY_TYPE)type2).const_dimensions[0];
                            res.isOpen = false;
                        }

                        return res;
                    } else if ((rank_right == 2) && (rank_left == 1)) {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[1];
                        res.dimensions = new EXPRESSION_LIST(1);
                        res.dimensions.Length = 1;
                        if (((ARRAY_TYPE)type1).base_type is REAL_TYPE)
                            res.base_type = new REAL_TYPE(((REAL_TYPE)((ARRAY_TYPE)type1).base_type).width);
                        else if (((ARRAY_TYPE)type2).base_type is REAL_TYPE)
                            res.base_type = new REAL_TYPE(((REAL_TYPE)((ARRAY_TYPE)type2).base_type).width);                        
                        else
                            res.base_type = new REAL_TYPE();

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            if (((ARRAY_TYPE)right_operand.type).const_dimensions[0] !=
                                        ((ARRAY_TYPE)right_operand.type).const_dimensions[0])
                                return null; //matrix is not square
                            if (((ARRAY_TYPE)right_operand.type).const_dimensions[1] !=
                                        ((ARRAY_TYPE)left_operand.type).const_dimensions[0])
                                return null; //lengths don't match
                            res.const_dimensions[0] = ((ARRAY_TYPE)type2).const_dimensions[0];
                        }
                        return res;
                    }

                    return null;
                }

                internal_type = GetType(type1, type2, false);

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    this.ErrorReported = true;
                    ERROR.IllegalTypeForBinOperator(this.sourceContext, "/", type1.ToString(), type2.ToString());
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("DIVIDE /; TYPE={0}; line={1}",type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // LeftDivision
    // ====
    //
    public sealed class LEFTDIVISION : BINARY {
        // Constructor
        public LEFTDIVISION() : base(ASTNodeType.LEFTDIVISION, "\\") { }

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val, type, sourceContext);
                return node;
            }
            Expression div = (Expression)base.convert();
            if (node != null)
                return node;

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                /**********************************/
                MethodCall call = new MethodCall();
                call.Operands = new ExpressionList();

                bool leftIsIndexer = left_operand is INDEXER;
                bool rightIsIndexer = right_operand is INDEXER;

                if (!leftIsIndexer)
                    call.Operands.Add(left_operand.convert() as Expression);
                else
                    call.Operands.Add(((INDEXER)left_operand).left_part.convert() as Expression);
                if (!rightIsIndexer)
                    call.Operands.Add(right_operand.convert() as Expression);
                else
                    call.Operands.Add(((INDEXER)right_operand).left_part.convert() as Expression);

                if (leftIsIndexer) {
                    EXPRESSION_LIST indices = ((INDEXER)left_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }
                if (rightIsIndexer) {
                    EXPRESSION_LIST indices = ((INDEXER)right_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }

                if (!leftIsIndexer) {
                    if (!rightIsIndexer) {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMainLeftLUDivisionOp(
                            ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                            null,
                            null,
                            left_operand.type,
                            right_operand.type,
                            type,
                            this.sourceContext));
                    } else {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMainLeftLUDivisionOp(
                            ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                            null,
                            ((INDEXER)right_operand).indices,
                            left_operand.type,
                            right_operand.type,
                            type,
                            this.sourceContext));
                    }
                } else {
                    if (!rightIsIndexer) {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMainLeftLUDivisionOp(
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                            ((INDEXER)left_operand).indices,
                            null,
                            left_operand.type,
                            right_operand.type,
                            type,
                            this.sourceContext));
                    } else {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMainLeftLUDivisionOp(
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                            ((INDEXER)left_operand).indices,
                            ((INDEXER)right_operand).indices,
                            left_operand.type,
                            right_operand.type,
                            type,
                            this.sourceContext));
                    }
                }

                call.Type = type.convert() as TypeNode;
                return call;
            }

            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            // Check types ???!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "\\", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "\\", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left == 2) && ((rank_right == 1) || (rank_right == 2))) {
                    if (((ARRAY_TYPE)left_operand.type).const_dimensions[1] != 0) {
                        if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] !=
                        ((ARRAY_TYPE)left_operand.type).const_dimensions[1])) {
                            ERROR.MatrixIsNotSquare(this.sourceContext, "/", left_operand.type.ToString());
                            ErrorReported = true;
                            return false;
                        }
                        if (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0) {
                            if ((((ARRAY_TYPE)left_operand.type).const_dimensions[1] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[0])) {
                                ERROR.IncompatibleSizes(this.sourceContext, "\\", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                } else // if ((rank_left != 2) (rank_right != 1) || (rank_right != 2))
                {
                    ERROR.IncorrectRanksForBinMatrixOp(this.sourceContext, "\\",
                        left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }

                return true;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for binary +
        {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if ((rank_left == 2) && (rank_right == 2)) {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[2];
                        res.dimensions = new EXPRESSION_LIST(2);
                        res.dimensions.Length = 2;
                        if (((ARRAY_TYPE)type1).base_type is REAL_TYPE)
                            res.base_type = new REAL_TYPE(((REAL_TYPE)((ARRAY_TYPE)type1).base_type).width);
                        else if (((ARRAY_TYPE)type2).base_type is REAL_TYPE)
                            res.base_type = new REAL_TYPE(((REAL_TYPE)((ARRAY_TYPE)type2).base_type).width);
                        else
                            res.base_type = new REAL_TYPE();                        

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[0] !=
                                        ((ARRAY_TYPE)left_operand.type).const_dimensions[0])
                                return null; //matrix is not square
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[1] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[0])
                                return null; //lengths don't match
                            res.const_dimensions[0] = ((ARRAY_TYPE)type1).const_dimensions[0];
                            res.const_dimensions[1] = ((ARRAY_TYPE)type2).const_dimensions[1];
                            res.isOpen = false;
                        }

                        return res;
                    } else if ((rank_left == 2) && (rank_right == 1)) {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[1];
                        res.dimensions = new EXPRESSION_LIST(1);
                        res.dimensions.Length = 1;
                        if (((ARRAY_TYPE)type1).base_type is REAL_TYPE)
                            res.base_type = new REAL_TYPE(((REAL_TYPE)((ARRAY_TYPE)type1).base_type).width);
                        else if (((ARRAY_TYPE)type2).base_type is REAL_TYPE)
                            res.base_type = new REAL_TYPE(((REAL_TYPE)((ARRAY_TYPE)type2).base_type).width);
                        else
                            res.base_type = new REAL_TYPE();                        
                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[0] !=
                                        ((ARRAY_TYPE)left_operand.type).const_dimensions[0])
                                return null; //matrix is not square
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[1] !=
                                        ((ARRAY_TYPE)right_operand.type).const_dimensions[0])
                                return null; //lengths don't match
                            res.const_dimensions[0] = ((ARRAY_TYPE)type1).const_dimensions[0];
                        }
                        return res;
                    }

                    return null;
                }

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext, "*", type1.ToString(), type2.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("LEFTDIVISION \\; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    // ARRAY RANGE
    // ==========
    //
    public sealed class ARRAY_RANGE : EXPRESSION {
        // Constructor

        public EXPRESSION from, to, by;
        public bool wasToWritten; //specifies whether the upper border (to) was written or not
        //if smb writes ..-1, to == -1, but we should say that it's a mistake,
        //if smb writes .., to == -1 too, but we should assign the length of the array in this dimension

        public ARRAY_RANGE()
            : base(ASTNodeType.ARRAY_RANGE, "..") {
            from = INTEGER_LITERAL.create(0, 32);
            to = INTEGER_LITERAL.create(-1, 32);
            by = INTEGER_LITERAL.create(1, 32);
        }

        //----------------------------------------------------------------------------
        public void finalize() {
            //from
            if (!((from.type is INTEGER_TYPE) && ((from.type as INTEGER_TYPE).width == 32))) {
                if (from is INTEGER_LITERAL) {
                    INTEGER_LITERAL il = INTEGER_LITERAL.create(-1, 32);
                    il.integer = (from as INTEGER_LITERAL).integer;
                    from = il;
                } else //((from.type is INTEGER_TYPE) || (from.type is CARDINAL_TYPE))
                {
                    //this is made in order to avoid changing of type for instances if they are range variables
                    MULTIPLY mult = new MULTIPLY();
                    mult.left_operand = from;
                    mult.right_operand = INTEGER_LITERAL.create(1, 8);
                    INTEGER_TYPE it = new INTEGER_TYPE(32);
                    mult.type = it;
                    from = mult;
                }
            }

            //to
            if (!((to.type is INTEGER_TYPE) && ((to.type as INTEGER_TYPE).width == 32))) {
                if (to is INTEGER_LITERAL) {
                    INTEGER_LITERAL il = INTEGER_LITERAL.create(-1, 32);
                    il.integer = (to as INTEGER_LITERAL).integer;
                    to = il;
                } else {
                    MULTIPLY mult = new MULTIPLY();
                    mult.left_operand = to;
                    mult.right_operand = INTEGER_LITERAL.create(1, 8);
                    INTEGER_TYPE it = new INTEGER_TYPE(32);
                    mult.type = it;
                    to = mult;
                }
            }

            //by
            if (!((by.type is INTEGER_TYPE) && ((by.type as INTEGER_TYPE).width == 32))) {
                if (by is INTEGER_LITERAL) {
                    INTEGER_LITERAL il = INTEGER_LITERAL.create(-1, 32);
                    il.integer = (by as INTEGER_LITERAL).integer;
                    by = il;
                } else {
                    MULTIPLY mult = new MULTIPLY();
                    mult.left_operand = by;
                    mult.right_operand = INTEGER_LITERAL.create(1, 8);
                    INTEGER_TYPE it = new INTEGER_TYPE(32);
                    mult.type = it;
                    by = mult;
                }
            }
        }

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            //MethodCall constructor = new MethodCall();
            //constructor.Callee = new MemberBinding(null, STANDARD.Ranges.GetConstructors()[0]);
            //constructor.Callee.SourceContext = this.sourceContext;
            //constructor.Operands = new ExpressionList();

            //constructor.Operands.Add(from.convert() as Expression);
            //constructor.Operands.Add(to.convert() as Expression);
            //constructor.Operands.Add(by.convert() as Expression);
            
            //node = constructor;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            return null;
        }

        //-----------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            // Check type??!!!
            TYPE type_from = from.type;
            TYPE type_to = to.type;
            TYPE type_by = by.type;

            if (type_from == null || type_to == null || type_by == null) 
                return false;

            if ((!type_from.validate()) || (!type_to.validate()) || (!type_by.validate()))
                return false; //message must be issued before

            if (!(type_from is INTEGER_TYPE || type_from is CARDINAL_TYPE)) {
                ERROR.IllegalTypeOf(type_from.ToString(), "range lower border", sourceContext);
                return false;
            }
            if (!(type_to is INTEGER_TYPE || type_to is CARDINAL_TYPE)) {
                ERROR.IllegalTypeOf(type_to.ToString(), "range upper border", sourceContext);
                return false;
            }
            if (!(type_by is INTEGER_TYPE || type_by is CARDINAL_TYPE)) {
                ERROR.IllegalTypeOf(type_by.ToString(), "range step", sourceContext);
                return false;
            }

            //if we can calculate from and to, then from has to be < to
            if (!wasToWritten)
                return true;
            if (from.calculate() == null)
                return true;
            if (to.calculate() == null)
                return true;
            LESS_EQUAL le = new LESS_EQUAL();
            le.left_operand = from;
            le.right_operand = to;
            if (!((bool)le.calculate())) {
                ERROR.IncorrectConstantRange(sourceContext, from.ToString(), to.ToString());
                ErrorReported = true;
                return false;
            }

            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for binary +
        {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                // base.extendProcTypes();
                TYPE type_from = from.type;
                TYPE type_to = to.type;
                TYPE type_by = by.type;

                if (type_from == null || type_to == null || type_by == null)
                    return null;

                return new RANGE_TYPE();

                //if (type1 is ANY_TYPE || type2 is ANY_TYPE)
                //{
                //    internal_type = new ANY_TYPE();
                //    return internal_type;
                //}
                //else if (!CONTEXT.firstPass)
                //{
                //    NODE call = base.resolveOperator();
                //    if (call is CALL)
                //    {
                //        this.call = (CALL)call;
                //        internal_type = call.type;
                //    }
                //}

                //if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported)
                //{
                //    ERROR.IllegalTypeOf("", "range arguments", sourceContext);
                //    this.ErrorReported = true;
                //}
                //return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("Array Range ..; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            //base.report(shift + NODE.reportShift);
        }
#endif

        //----------------------------------------------------------------------------

        public override NODE resolve() {
            if (from != null) { from.resolve(); }
            if (to != null) { to.resolve(); }
            if (by != null) { by.resolve(); }
            return this;
        }
    }


    // RANGE STEP
    // ==========
    //
    [Obsolete]
    public sealed class RANGESTEP : BINARY {
        // Constructor
        public RANGESTEP() : base(ASTNodeType.RANGESTEP, "by") { }

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;


            // Operands are converted by base.convert()
            Expression plus = (Expression)base.convert();
            if (node != null)
                return node;

            node = plus;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            // Check type??!!!
            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for binary +
        {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ANY_TYPE || type2 is ANY_TYPE) {
                    internal_type = new ANY_TYPE();
                    return internal_type;
                } else if (!CONTEXT.firstPass) {
                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                    }
                }

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext, "+", type1.ToString(), type2.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("Range Step Operation \\; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }


    // EXPRESSION ARRAY (MATRIX ASSIGNMENT)
    // ==========
    //
    public sealed class EXPR_ARRAY_ASSIGNMENT : STATEMENT {
        // Constructor

        public class EXPR_ARRAY_ITEM {
            public EXPRESSION expr;
            public System.Collections.Generic.List<int> indexList;

            public EXPR_ARRAY_ITEM()
                : base() {
                indexList = new System.Collections.Generic.List<int>();
            }
        }

        public EXPR_ARRAY_ASSIGNMENT()
            : base(ASTNodeType.EXPR_ARRAY_ASSIGNMENT) {
            right_part = new System.Collections.Generic.List<EXPR_ARRAY_ITEM>();
            dimensions = new System.Collections.Generic.List<int>();
        }

        //--------------------------------------------------

        public DESIGNATOR receiver;
        public System.Collections.Generic.List<EXPR_ARRAY_ITEM> right_part;
        public System.Collections.Generic.List<int> dimensions;

        //--------------------------------------------------

        public static EXPR_ARRAY_ASSIGNMENT create() {
            EXPR_ARRAY_ASSIGNMENT assignment = new EXPR_ARRAY_ASSIGNMENT();

            assignment.enclosing = null;
            assignment.modifiers = null;
            assignment.name = null;

            // assignment.sourceContext

            return assignment;
        }

        public void finalize(NODE enclosing, EXPRESSION designator) {
            if (designator == null)
                return;

            designator.enclosing = this;

            this.receiver = (DESIGNATOR)designator;

            this.receiver.enclosing = this;
            if (this.right_part == null)
                return; // can be null because of parsing errors

            // Semantic processing (types etc.)

            base.finalize(enclosing);
        }

        //--------------------------------------------------

        public override NODE resolve() {
            if (receiver is INDEXER)
                ((INDEXER)receiver).write = true;
            receiver.resolve();

            foreach (EXPR_ARRAY_ITEM item in right_part) {
                if (item != null && item.expr != null)
                    item.expr.resolve();
                else
                    return null;
            }
            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            bool res1 = receiver.validate();
            if (!res1) {
                ERROR.WrongAssignmentLeft(sourceContext);
                return false;
            }

            NODE l = receiver.resolve();

            TYPE left_type_to_compare = l.type;
            if (left_type_to_compare is ARRAY_TYPE) {
                if (l is INDEXER) {
                    left_type_to_compare = ((ARRAY_TYPE)(((INDEXER)l).left_part.type)).base_type;
                } else {
                    left_type_to_compare = ((ARRAY_TYPE)left_type_to_compare).base_type;
                }
            }
            

            foreach (EXPR_ARRAY_ITEM item in right_part) {
                bool res2 = item.expr.validate();
                if (!res2) {
                    ERROR.WrongAssignmentRight(sourceContext);
                    return false;
                }

                TYPE right_type = item.expr.type;

                // Temporary check; this should not occur if predefined procs are well implemented
                if (right_type == null) {
                    ERROR.WrongAssignmentRight(this.sourceContext);
                    return false;
                }

                // Two types should be "assignment compatible"...
                bool err = false;
                bool errArray = false;
                bool isMathAndNotMathCompatible = false;
                EXPRESSION res = TYPE.AssignmentCompatibilityInternal(ref err, ref errArray, left_type_to_compare, right_type, item.expr,
                    isMathAndNotMathCompatible);
                if (err) {
                    //try to find an overloaded operator
                    ASSIGNMENT_OPERATOR assign_op = new ASSIGNMENT_OPERATOR(":=");
                    if (assign_op.findBestOpDeclForBinaryOperator(left_type_to_compare, right_type) != null)
                        err = false;
                    else {
                        ERROR.AssignmentCompatibility(left_type_to_compare.ToString(), right_type.ToString(), sourceContext);
                        return false;
                    }
                }
            }
       

            if (l is CONSTANT_DECL) {
                ERROR.AssignToConstant(l.name.Name, receiver.sourceContext);
                return false;
            } else if (l is VARIABLE_DECL) {
                if (l.modifiers.Immutable) {
                    DECLARATION scope = (DECLARATION)((VARIABLE_DECL)l).enclosing;
                    if (scope != CONTEXT.current_unit) {
                        ERROR.ModifyImmutable(l.name.Name, receiver.sourceContext);
                        return false;
                    }
                }
            } else if (l is INDEXER) {
                if ((l as INDEXER).left_part.type is ARRAY_TYPE) {
                    ARRAY_TYPE left_arr_type = (l as INDEXER).left_part.type as ARRAY_TYPE;
                    if (!left_arr_type.isMath) {
                        ERROR.AssignmentCompatibility(receiver.name.Name, "Expression array", sourceContext);
                        return false;
                    }
                    if (((l as INDEXER).type as ARRAY_TYPE).dimensions.Length != dimensions.Count) {
                        ERROR.AssignmentCompatibility(receiver.name.Name, "Expression array", sourceContext);
                        return false;
                    }
                    return true;
                }
                ERROR.WrongAssignmentLeft(receiver.sourceContext);
                return false;
            } else if (l is EXTERNAL_DECL) {
                // It's OK; further checks will be performed...
            } else {
                ERROR.WrongAssignmentLeft(receiver.sourceContext);
                return false;
            }

            // Here we'll check if receiver is property defined and definition and if we're inside implementation
            // then in case of read only property we allow assign it.
            if ((receiver is INSTANCE) && (receiver.modifiers.Getter) && (!receiver.modifiers.Setter)) {
                NODE encl = this.enclosing;
                while (!(encl is IMPLEMENTATION_DECL) && (encl != null))
                    encl = encl.enclosing;
                IMPLEMENTATION_DECL impl = encl as IMPLEMENTATION_DECL;
                if (impl == null) {
                    ERROR.PropertyIsReadOnly(((INSTANCE)receiver).entity.name.Name, sourceContext);
                    return false;
                }
            }

            TYPE left_type = receiver.type;
            if ((receiver is INDEXER) && (((INDEXER)receiver).calls != null))
                left_type = ((INDEXER)receiver).calls.Set.parameters[((INDEXER)receiver).calls.Set.paramCount - 1].type;

            if (left_type == null) {
                ERROR.WrongAssignmentLeft(this.sourceContext);
                return false;
            }

            if (left_type is ARRAY_TYPE) {
                ARRAY_TYPE left_arr_type = left_type as ARRAY_TYPE;

                if (!left_arr_type.isMath) {
                    ERROR.AssignmentCompatibility(receiver.name.Name, "Expression array", sourceContext);
                    return false;
                }

                if (left_arr_type.dimensions.Length != dimensions.Count) {
                    ERROR.AssignmentCompatibility(receiver.name.Name, "Expression array", sourceContext);
                    return false;
                } else {
                    if (left_arr_type.const_dimensions[0] != 0) //array is static, we can change lengths now
                    {
                        int index = 0;
                        foreach (int count in dimensions) {
                            if (left_arr_type.const_dimensions[index] != count) {
                                ERROR.AssignmentCompatibility(receiver.name.Name, "Expression array", sourceContext);
                            }
                            index++;
                        }
                    }
                }
            } else if (receiver.type is OBJECT_TYPE) {
                OBJECT_DECL obj = (receiver.type as OBJECT_TYPE).ObjectUnit as OBJECT_DECL;

                int dim = obj.indexer.Set.paramCount - 1;

                if (dim != dimensions.Count) {
                    ERROR.AssignmentCompatibility(receiver.name.Name, right_part.GetType().Name, sourceContext);
                }

            }
            // Replace right_part for the new sub-tree!
            // right_part = result;
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates assignment's type
        {
            // By definition, type of assignment statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //--------------------------------------------------------------------------------------

        public override Node convert() // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            NODE resolved = resolve();

            if (!validate())
                return null;
            if (receiver == null)
                return null;
            if (right_part == null)
                return null;

            if (receiver.type is OBJECT_TYPE) {   // We should generate call
                OBJECT_DECL obj = (receiver.type as OBJECT_TYPE).ObjectUnit as OBJECT_DECL;
                if (obj.indexer == null) {
                    ERROR.ObjectDoesNotImplementIndexer(obj.name.Name, sourceContext);
                    return null;
                }
                if (obj.indexer.Set == null) {
                    ERROR.IndexerIsWriteOnly(obj.name.Name, sourceContext);
                    return null;
                }
                PROCEDURE_DECL calee = obj.indexer.Set; // What to call

                Block matAssig = new Block();
                matAssig.SourceContext = this.sourceContext;
                matAssig.Statements = new StatementList();
                foreach (EXPR_ARRAY_ITEM item in right_part) {
                    MethodCall invoke = new MethodCall();
                    Node target = receiver.convert();
                    Node member = calee.convert();

                    invoke.Callee = new MemberBinding(target as Expression, member as Member);
                    invoke.GiveErrorIfSpecialNameMethod = false; // ??

                    invoke.IsTailCall = false;

                    invoke.Operands = new ExpressionList(item.indexList.Count + 1);
                    for (int i = 0; i < item.indexList.Count; i++)
                        invoke.Operands.Add(new Literal(item.indexList[i], SystemTypes.Int32));
                    invoke.Operands.Add(item.expr.convert() as Expression);
                    invoke.SourceContext = this.sourceContext;
                    invoke.Type = SystemTypes.Void;
                    ExpressionStatement pcall = new ExpressionStatement(invoke, this.sourceContext);
                    matAssig.Statements.Add(pcall);

                }
                node = matAssig;
                return node;
            } else if (receiver.type is ARRAY_TYPE) {
                Block matAssig = new Block();
                matAssig.SourceContext = this.sourceContext;
                matAssig.Statements = new StatementList();
                
                //Indexer leftIndexer = new Indexer();
                //leftIndexer.Object = (Expression)(((INDEXER)receiver).left_part.convert());
                //leftIndexer.Operands = new ExpressionList();
                //int matrixItemNumber = 0;
                //matAssig.Statements.Add(recursiveRangeExpressionArray((receiver as INDEXER), 0, 0, leftIndexer, ref matrixItemNumber));

                string arr_name = "__math_temp";

                //constructing result array type
                ARRAY_TYPE arr_type = new ARRAY_TYPE();
                arr_type.dimensions = new EXPRESSION_LIST(dimensions.Count);
                arr_type.dimensions.Length = dimensions.Count;
                arr_type.const_dimensions = new int[dimensions.Count];
                for (int i = 0; i < dimensions.Count; i++) {
                    arr_type.dimensions[i] = INTEGER_LITERAL.create(dimensions[i], 32);
                    arr_type.const_dimensions[i] = dimensions[i];
                }
                arr_type.base_type = (receiver.type as ARRAY_TYPE).base_type;
                arr_type.isOpen = false;
                arr_type.isMath = true;
                //end

                //type[...] __math_type = new type[...];
                LocalDeclarationsStatement lds = new LocalDeclarationsStatement();
                lds.Constant = false;
                lds.Declarations = new LocalDeclarationList(1);
                lds.InitOnly = false;
                ArrayTypeExpression ate = arr_type.convert() as ArrayTypeExpression;
                lds.Type = new ArrayTypeExpression(ate.ElementType, ate.Rank);

                ConstructArray new_array = new ConstructArray();
                new_array.ElementType = (receiver.type as ARRAY_TYPE).base_type.convert() as TypeNode;
                new_array.Operands = new ExpressionList();
                new_array.Rank = dimensions.Count;
                for (int i =0; i < dimensions.Count; i++)
                    new_array.Operands.Add(new Literal(dimensions[i], SystemTypes.Int32));

                LocalDeclaration ld = new LocalDeclaration();
                ld.Name = Identifier.For(arr_name);
                ld.InitialValue = new_array;
                lds.Declarations.Add(ld);
                
                matAssig.Statements.Add(lds);
                //end

                TYPE receiver_type = (receiver.type as ARRAY_TYPE).base_type;
                bool isReceiverStandardType = false;
                if ((receiver_type is INTEGER_TYPE) || (receiver_type is CARDINAL_TYPE) || (receiver_type is REAL_TYPE) || (receiver_type is BOOLEAN_TYPE))
                    isReceiverStandardType = true;

                //initializate __math_temp
                foreach (EXPR_ARRAY_ITEM item in right_part) {
                    Indexer indexer = new Indexer();
                    //TYPE receiver_type = arr_type.base_type;
                    indexer.ElementType = arr_type.base_type.convert() as TypeNode;
                    indexer.Object = Identifier.For(arr_name);

                    indexer.Operands = new ExpressionList(item.indexList.Count);
                    for (int i = 0; i < item.indexList.Count; i++)
                        indexer.Operands.Add(new Literal(item.indexList[i], SystemTypes.Int32));
                    indexer.SourceContext = this.sourceContext;
                    
                    indexer.Type = arr_type.convert() as TypeNode;

                    if (isReceiverStandardType && 
                        ((item.expr.type is INTEGER_TYPE) || (item.expr.type is CARDINAL_TYPE) || (item.expr.type is REAL_TYPE) || (item.expr.type is BOOLEAN_TYPE))) {
                        //"normal" assignment
                        AssignmentStatement assignment = new AssignmentStatement();
                        assignment.NodeType = NodeType.AssignmentStatement;
                        assignment.Operator = NodeType.Nop;
                        assignment.Source = item.expr.convert() as Expression;
                        assignment.Target = indexer;
                        assignment.SourceContext = sourceContext;

                        matAssig.Statements.Add(assignment);
                    } else {
                        //we have to search for an overloaded function
                        ASSIGNMENT_OPERATOR assign_op = new ASSIGNMENT_OPERATOR(":=");
                        OPERATOR_DECL op = assign_op.findBestOpDeclForBinaryOperator(receiver_type, item.expr.type);
                        ExpressionStatement exps = new ExpressionStatement();
                        exps.Expression = new MethodCall(
                            (INSTANCE.create(op)).convert() as QualifiedIdentifier,
                            new ExpressionList(new Expression[] { new UnaryExpression(indexer, NodeType.RefAddress), item.expr.convert() as Expression }),
                            NodeType.Call);
                        exps.SourceContext = sourceContext;
                        matAssig.Statements.Add(exps);
                    }
                }
                //end

                bool isReceiverIndexer = false;
                if (receiver is INDEXER)
                    isReceiverIndexer = true;

                //call for a function if the receiver is indexer; otherwise usual assignment statement
                AssignmentStatement asgn = new AssignmentStatement();
                asgn.SourceContext = this.sourceContext;
                if (isReceiverIndexer)
                    asgn.Target = (receiver as INDEXER).left_part.convert() as Expression;
                else
                    asgn.Target = receiver.convert() as Expression;
                asgn.Operator = NodeType.Nop;

                MethodCall mathCall = new MethodCall();
                mathCall.Operands = new ExpressionList();

                if (isReceiverIndexer) {
                    mathCall.Operands.Add(((INDEXER)receiver).left_part.convert() as Expression);
                    mathCall.Operands.Add(Identifier.For(arr_name));
                }

                EXPRESSION_LIST indices = null;
                if (isReceiverIndexer) {
                    indices = ((INDEXER)receiver).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            mathCall.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                mathCall.Operands.Add(cur_range.from.convert() as Expression);
                                mathCall.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                mathCall.Operands.Add(cur_range.to.convert() as Expression);
                                mathCall.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                mathCall.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                mathCall.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                mathCall.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                mathCall.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            mathCall.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }

                if (isReceiverIndexer) {
                    if (isReceiverStandardType) {
                        mathCall.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetDeepCopy(
                            ((ARRAY_TYPE)((INDEXER)receiver).left_part.type).dimensions.Length,
                            dimensions.Count,
                            ((ARRAY_TYPE)((INDEXER)receiver).left_part.type).base_type.convert() as TypeNode,
                            arr_type.base_type.convert() as TypeNode,
                            ((INDEXER)receiver).indices,
                            null,
                            NodeType.Nop, null,
                            this.sourceContext));
                    } else {
                        ASSIGNMENT_OPERATOR assign_op = new ASSIGNMENT_OPERATOR(":=");
                        OPERATOR_DECL op = assign_op.findBestOpDeclForBinaryOperator(receiver_type, receiver_type);

                        mathCall.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetDeepCopy(
                            ((ARRAY_TYPE)((INDEXER)receiver).left_part.type).dimensions.Length,
                            dimensions.Count,
                            ((ARRAY_TYPE)((INDEXER)receiver).left_part.type).base_type.convert() as TypeNode,
                            arr_type.base_type.convert() as TypeNode,
                            ((INDEXER)receiver).indices,
                            null,
                            NodeType.MethodCall,
                            (INSTANCE.create(op)).convert() as QualifiedIdentifier,
                            this.sourceContext));
                    }
                    asgn.Source = mathCall;
                } else {
                    if (CONTEXT.useComputeMath) {
                        asgn.Target = receiver.name;
                        asgn.Source = new Construct {
                            Constructor = new MemberBinding {
                                BoundMember = STANDARD.Data.GetConstructor(SystemTypes.Array),
                            },
                            Operands = new ExpressionList(
                                Identifier.For(arr_name)
                            ),
                        };
                    } else {
                        asgn.Source = Identifier.For(arr_name);
                    }
                }

                

                matAssig.Statements.Add(asgn);
                //end

                node = matAssig;
                return node;
            }
            

            //else if (receiver.type is ARRAY_TYPE)
            //{
            //    Block matAssig = new Block();
            //    matAssig.SourceContext = this.sourceContext;
            //    matAssig.Statements = new StatementList();

            //    if (((ARRAY_TYPE)(receiver.type)).const_dimensions[0] == 0) //array is dynamic;
            //        //we have to allocate new memory
            //    {
            //        ASSIGNMENT asgn = new ASSIGNMENT();
            //        asgn.receiver = receiver;
            //        NEW n = new NEW();
            //        EXPRESSION_LIST expr_list = new EXPRESSION_LIST();
            //        for (int i = 0; i < dimensions.Count; i++)
            //        {
            //            EXPRESSION expr = INTEGER_LITERAL.create(dimensions[i], 32);
            //            expr_list.Add(expr);
            //        }
            //        n.arguments = expr_list;
            //        n.enclosing = this.enclosing;
            //        n.resolved_new_type = receiver.type;
            //        asgn.right_part = n;
            //        matAssig.Statements.Add(asgn.convert() as Statement);
            //    }

            //    TYPE receiver_type = ((ARRAY_TYPE)receiver.type).base_type;
            //    bool isReceiverStandardType = false;
            //    if ((receiver_type is INTEGER_TYPE) || (receiver_type is CARDINAL_TYPE) || (receiver_type is REAL_TYPE))
            //        isReceiverStandardType = true;

            //    foreach (EXPR_ARRAY_ITEM item in right_part)
            //    {
            //        Indexer indexer = new Indexer();
            //        indexer.ElementType = (TypeNode)receiver_type.convert();
            //        indexer.Object = (Expression)receiver.convert();
            //        indexer.Operands = new ExpressionList(item.indexList.Count);
            //        for (int i = 0; i < item.indexList.Count; i++)
            //            indexer.Operands.Add(new Literal(item.indexList[i], SystemTypes.Int32));
            //        indexer.SourceContext = this.sourceContext;

            //        if (receiver.type != null)
            //            indexer.Type = (TypeNode)receiver_type.convert();

            //        if (isReceiverStandardType && ((item.expr.type is INTEGER_TYPE) || (item.expr.type is CARDINAL_TYPE) || (item.expr.type is REAL_TYPE)))
            //        {
            //            //"normal" assignment
            //            AssignmentStatement assignment = new AssignmentStatement();
            //            assignment.NodeType = NodeType.AssignmentStatement;
            //            assignment.Operator = NodeType.Nop;  // this means "normal" assignment, but not += etc.
            //            assignment.Source = item.expr.convert() as Expression;
            //            assignment.Target = indexer;
            //            assignment.SourceContext = sourceContext;

            //            matAssig.Statements.Add(assignment);
            //        }
            //        else
            //        {
            //            //we have to search for an overloaded function
            //            ASSIGNMENT_OPERATOR assign_op = new ASSIGNMENT_OPERATOR(":=");
            //            OPERATOR_DECL op = assign_op.findBestOpDeclForBinaryOperator(receiver_type, item.expr.type);
            //            ExpressionStatement exps = new ExpressionStatement();
            //            exps.Expression = new MethodCall(
            //                new QualifiedIdentifier(Identifier.For(op.enclosing.Name), OPERATOR_DECL.toName(":=")),
            //                new ExpressionList(new Expression[] { new UnaryExpression(indexer, NodeType.RefAddress), item.expr.convert() as Expression }),
            //                NodeType.Call);
            //            exps.SourceContext = sourceContext;
            //            matAssig.Statements.Add(exps);
            //        }
            //    }

            //    node = matAssig;
            //    return node;

            //}

            ERROR.NotImplemented("MATRIX ASSIGNMENT");
            return null;
        }
        //----------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("MATRIX ASSIGNMENT line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift + NODE.reportShift);
            System.Console.WriteLine("RECEIVER");
            if (receiver == null) {
                NODE.doShift(shift + 2 * NODE.reportShift);
                Console.WriteLine("NULL");
            } else
                receiver.report(shift + 2 * NODE.reportShift);

            NODE.doShift(shift + NODE.reportShift);
            System.Console.WriteLine("RIGHT PART");
            //  right_part.report(shift + 2 * NODE.reportShift);
        }
#endif

        //----------------------------------------------------------------
        [Obsolete]
        public Statement recursiveRangeExpressionArray(INDEXER indexer, int index, int exprIndex, Indexer leftIndexer, ref int matrixItemNumber) {
            if (index == indexer.indices.Length) {
                AssignmentStatement assignmentStatement = new AssignmentStatement();
                assignmentStatement.Target = leftIndexer;
                assignmentStatement.Source = right_part[matrixItemNumber].expr.convert() as Expression;
                //matrixItemNumber++;
                return assignmentStatement;
            } else {
                if (indexer.indices[index] is ARRAY_RANGE) {
                    Block rangeBlock = new Block();
                    rangeBlock.Statements = new StatementList();

                    ARRAY_RANGE range = indexer.indices[index] as ARRAY_RANGE;

                    int border;
                    if (exprIndex == 0)
                        border = right_part.Count / right_part[0].indexList.Count;
                    else 
                        border = right_part[1].indexList.Count;
                    for (int i = 0; i < border; i++) {
                        //generating index
                        Expression multExpr;
                        
                        multExpr = new BinaryExpression(
                            (Expression)range.by.convert(),
                            new Literal(i, SystemTypes.Int32),
                            NodeType.Mul_Ovf);

                        BinaryExpression sumExpr =
                            new BinaryExpression((Expression)range.from.convert(), multExpr, NodeType.Add_Ovf);

                        Indexer newLeftIndexer = new Indexer();
                        newLeftIndexer.Object = leftIndexer.Object;
                        newLeftIndexer.Operands = new ExpressionList();
                        for (int j = 0; j < leftIndexer.Operands.Length; j++)
                            newLeftIndexer.Operands.Add(leftIndexer.Operands[j]);

                        newLeftIndexer.Operands.Add(sumExpr);
                        if (exprIndex == 0)
                            matrixItemNumber = i;
                        else
                            matrixItemNumber = matrixItemNumber + i * right_part.Count / right_part[0].indexList.Count;
                        rangeBlock.Statements.Add(recursiveRangeExpressionArray(
                            indexer, index + 1, exprIndex + 1, newLeftIndexer, ref matrixItemNumber));
                    }
                    return rangeBlock;
                } else {
                    leftIndexer.Operands.Add((Expression)indexer.indices[index].convert());
                    return recursiveRangeExpressionArray(indexer, index + 1, exprIndex, leftIndexer, ref matrixItemNumber);
                }
            }

        }
        //----------------------------------------------------------------

    }


    // Matrix Transpose
    // ====
    //

    public sealed class TRANSPOSE : UNARY {
        // Constructor
        public TRANSPOSE() : base(ASTNodeType.TRANSPOSE, "!") { }

        //---------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val, type, sourceContext);
                return node;
            }

            // Operands are converted by base.convert()
            Expression transp = (Expression)base.convert();
            if (node != null)
                return node;

            if (operand.type is ARRAY_TYPE) {
                MethodCall call = new MethodCall();
                call.Operands = new ExpressionList();

                if (!(operand is INDEXER)) {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMatrixTranspose(
                            ((ARRAY_TYPE)operand.type).base_type.convert() as TypeNode,
                            null,
                            this.sourceContext));

                        call.Operands.Add(operand.convert() as Expression);
                } else {
                        call.Operands.Add(((INDEXER)operand).left_part.convert() as Expression);

                        EXPRESSION_LIST indices = ((INDEXER)operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                                call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                    ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                    call.Operands.Add(cur_range.from.convert() as Expression);
                                    call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                    call.Operands.Add(cur_range.to.convert() as Expression);
                                    call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                                {
                                    call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                        STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                    call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                    call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                        STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                    call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                        STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                                }
                        } else if (indices[i].type is ARRAY_TYPE) {
                                call.Operands.Add(indices[i].convert() as Expression);
                            }
                        }

                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetMatrixTranspose(
                            ((ARRAY_TYPE)operand.type).base_type.convert() as TypeNode,
                            ((INDEXER)operand).indices,
                            this.sourceContext));
                    }

                call.Type = type.convert() as TypeNode;
                return call;
            } else if (operand.type is SPARSE_TYPE) {
                MethodCall call = new MethodCall();
                call.Operands = new ExpressionList();

                SPARSE_TYPE opType = operand.type as SPARSE_TYPE;

                call.Type = STANDARD.SparseMatrix.GetTemplateInstance(
                    CONTEXT.symbolTable, opType.base_type.convert() as TypeNode);

                call.Callee = new QualifiedIdentifier(operand.convert() as Expression,
                    new Identifier("Transpose"));

                call.Operands.Add(new Literal(sourceContext.StartLine, SystemTypes.Int64));
                call.Operands.Add(new Literal(sourceContext.StartColumn, SystemTypes.Int32));

                return call;
            }

            node = transp;
            return node;
        }

        //-----------------------------------------------------------------------

        public override object calculate() // Calculates constant expression: ~expr
        {
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            // Check type??!!!

            if (operand == null)
                return false;

            if (!operand.validate()) {
                return false;  // A message must be issued before 
            }

            if ((operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "!", operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if (operand.type is ARRAY_TYPE) {
                int rank = ((ARRAY_TYPE)operand.type).dimensions.Length;
                if (rank != 2) {
                    ERROR.IncorrectRankForTransp(this.sourceContext, operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
                return true;
            }

            if (operand.type is SPARSE_TYPE) {
                bool isVector = ((SPARSE_TYPE)operand.type).isVector;
                if (isVector) {
                    ERROR.IncorrectRankForTransp(this.sourceContext, operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
                return true;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates negation's type
        {
            get {
                if (internal_type != null)
                    return internal_type;

                TYPE type = base.evaluateOperandType();
                if (type != null && type is ARRAY_TYPE) {
                    // Legal type for operator "!" is a 2d ARRAY only. The result is a 2d ARRAY too
                    
                    int rank = ((ARRAY_TYPE)type).dimensions.Length;

                    if (rank != 2) { return null; } else {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[2];

                        if (((ARRAY_TYPE)type).const_dimensions[0] != 0) {
                            //array is static; lengths can be calculated now
                            res.const_dimensions[0] = ((ARRAY_TYPE)type).const_dimensions[1];
                            res.const_dimensions[1] = ((ARRAY_TYPE)type).const_dimensions[0];
                            res.isOpen = false;
                        }

                        res.dimensions = new EXPRESSION_LIST(2);
                        res.dimensions.Length = 2;
                        res.base_type = ((ARRAY_TYPE)type).base_type;

                        internal_type = res;
                        return internal_type;
                    }
                } else if (type != null && type is SPARSE_TYPE) {
                    // Legal type for operator "!" is a 2d SPARSE_TYPE only. The result is a 2d SPARSE_TYPE too

                    int rank = ((SPARSE_TYPE)type).dimensions.Length;

                    if (rank != 2) { return null; } else {
                        SPARSE_TYPE res = new SPARSE_TYPE();
                        res.isVector = false;

                        res.dimensions = new EXPRESSION_LIST(2);
                        res.dimensions.Length = 2;
                        res.base_type = ((SPARSE_TYPE)type).base_type;

                        internal_type = res;
                        return internal_type;
                }
                } else if (!CONTEXT.firstPass) {
                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                        return internal_type;
                    }
                }

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    if (type != null)
                        ERROR.IllegalTypeForUnOperator(this.sourceContext, "!", type.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("TRANSPOSE !; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    //Scalar Production
    // ===
    //

    public sealed class PSEUDO_SCALAR_PRODUCT : BINARY {
        // Constructor
        public PSEUDO_SCALAR_PRODUCT() : base(ASTNodeType.PSEUDO_SCALAR_PRODUCT, "+*") { ovlOpPlus = null; }

        private NodeType opPlus, opMult; //operations for IsMath operations with arrays
        private QualifiedIdentifier ovlOpPlus; //ovlOp - for opMult, ovlOpPlus - for opPlus
        private bool isRetTypeSystem; //Whether the return type is a system type (like int or double)

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val, type, sourceContext);
                return node;
            }

            // Operands are converted by base.convert()
            Expression mult = (Expression)base.convert();
            if (node != null)
                return node;

            if ((type is INTEGER_TYPE) || (type is CARDINAL_TYPE) ||
                (type is REAL_TYPE) || (type is SET_TYPE))
                isRetTypeSystem = true;
            else
                isRetTypeSystem = false;

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                MethodCall call = new MethodCall();
                call.Operands = new ExpressionList();

                bool leftIsIndexer = left_operand is INDEXER;
                bool rightIsIndexer = right_operand is INDEXER;

                if (!leftIsIndexer)
                    call.Operands.Add(left_operand.convert() as Expression);
                else
                    call.Operands.Add(((INDEXER)left_operand).left_part.convert() as Expression);
                if (!rightIsIndexer)
                    call.Operands.Add(right_operand.convert() as Expression);
                else
                    call.Operands.Add(((INDEXER)right_operand).left_part.convert() as Expression);

                if (leftIsIndexer) {
                    EXPRESSION_LIST indices = ((INDEXER)left_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }
                if (rightIsIndexer) {
                    EXPRESSION_LIST indices = ((INDEXER)right_operand).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                call.Operands.Add(cur_range.from.convert() as Expression);
                                call.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                call.Operands.Add(cur_range.to.convert() as Expression);
                                call.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                call.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                call.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            call.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }

                if (!leftIsIndexer) {
                    if (!rightIsIndexer) {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetPseudoScalarProduct(
                            ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                            null,
                            null,
                            type.convert() as TypeNode,
                            isRetTypeSystem,
                            opPlus,
                            ovlOpPlus,
                            opMult,
                            ovlOp,
                            this.sourceContext));
                    } else {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetPseudoScalarProduct(
                            ((ARRAY_TYPE)left_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)left_operand.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                            null,
                            ((INDEXER)right_operand).indices,
                            type.convert() as TypeNode,
                            isRetTypeSystem,
                            opPlus,
                            ovlOpPlus,
                            opMult,
                            ovlOp,
                            this.sourceContext));
                    }
                } else {
                    if (!rightIsIndexer) {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetPseudoScalarProduct(
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)right_operand.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)right_operand.type).base_type.convert() as TypeNode,
                            ((INDEXER)left_operand).indices,
                            null,
                            type.convert() as TypeNode,
                            isRetTypeSystem,
                            opPlus,
                            ovlOpPlus,
                            opMult,
                            ovlOp,
                            this.sourceContext));
                    } else {
                        call.Callee = new MemberBinding(null,
                            CONTEXT.globalMath.GetPseudoScalarProduct(
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).dimensions.Length,
                            ((ARRAY_TYPE)((INDEXER)left_operand).left_part.type).base_type.convert() as TypeNode,
                            ((ARRAY_TYPE)((INDEXER)right_operand).left_part.type).base_type.convert() as TypeNode,
                            ((INDEXER)left_operand).indices,
                            ((INDEXER)right_operand).indices,
                            type.convert() as TypeNode,
                            isRetTypeSystem,
                            opPlus,
                            ovlOpPlus,
                            opMult,
                            ovlOp,
                            this.sourceContext));
                    }
                }

                call.Type = type.convert() as TypeNode;
                return call;
            }

            node = mult;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                if (!((ARRAY_TYPE)left_operand.type).isMath) {
                    ERROR.ArrayNotMath(this.sourceContext, "+*", left_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }

                if (!((ARRAY_TYPE)right_operand.type).isMath) {
                    ERROR.ArrayNotMath(this.sourceContext, "+*", right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }

                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "+*", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, "+*", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }

                return true;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for binary +*
        {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ANY_TYPE || type2 is ANY_TYPE) {
                    internal_type = new ANY_TYPE();
                    return internal_type;
                }

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        TYPE type1_base = ((ARRAY_TYPE)type1).base_type;
                        TYPE type2_base = ((ARRAY_TYPE)type2).base_type;

                        long w1, w2;

                        if (type1_base is INTEGER_TYPE && type2_base is INTEGER_TYPE) {
                            w1 = ((INTEGER_TYPE)type1_base).width;
                            w2 = ((INTEGER_TYPE)type2_base).width;
                            opPlus = NodeType.Add_Ovf;
                            opMult = NodeType.Mul_Ovf;
                            return new INTEGER_TYPE(w1 > w2 ? w1 : w2);
                        } else if (type1_base is CARDINAL_TYPE && type2_base is CARDINAL_TYPE) {
                            w1 = ((CARDINAL_TYPE)type1_base).width;
                            w2 = ((CARDINAL_TYPE)type2_base).width;
                            opPlus = NodeType.Add_Ovf_Un;
                            opMult = NodeType.Mul_Ovf_Un; //error on Mono
#if ROTOR
                            opMult = NodeType.Mul;
#endif
                            return new CARDINAL_TYPE(w1 > w2 ? w1 : w2);
                        } else if (type1_base is INTEGER_TYPE && type2_base is CARDINAL_TYPE) {
                            w1 = ((INTEGER_TYPE)type1_base).width;
                            w2 = ((CARDINAL_TYPE)type2_base).width;
                            opPlus = NodeType.Add_Ovf;
                            opMult = NodeType.Mul_Ovf;
                            return new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
                        } else if (type1_base is CARDINAL_TYPE && type2_base is INTEGER_TYPE) {
                            w1 = ((CARDINAL_TYPE)type1_base).width;
                            w2 = ((INTEGER_TYPE)type2_base).width;
                            opPlus = NodeType.Add_Ovf;
                            opMult = NodeType.Mul_Ovf;
                            return new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
                        } else if (type1_base is REAL_TYPE && (type2_base is INTEGER_TYPE || type2_base is CARDINAL_TYPE) ||
                                    type2_base is REAL_TYPE && (type1_base is INTEGER_TYPE || type1_base is CARDINAL_TYPE)) {
                            opPlus = NodeType.Add;
                            opMult = NodeType.Mul;
                            return new REAL_TYPE(64); // 32 
                        } else if (type1_base is REAL_TYPE && type2_base is REAL_TYPE) {
                            w1 = ((REAL_TYPE)type1_base).width;
                            w2 = ((REAL_TYPE)type2_base).width;
                            opPlus = NodeType.Add;
                            opMult = NodeType.Mul;
                            return new REAL_TYPE(w1 > w2 ? w1 : w2);
                        } else if (type1_base is SET_TYPE && type2_base is SET_TYPE) {
                            w1 = ((SET_TYPE)type1_base).width;
                            w2 = ((SET_TYPE)type2_base).width;
                            opPlus = NodeType.Add;
                            opMult = NodeType.And;
                            return new SET_TYPE(w1 > w2 ? w1 : w2);
                        } else if (!CONTEXT.firstPass) {
                            MULTIPLY mul = new MULTIPLY();
                            mul.left_operand = left_operand;
                            mul.right_operand = right_operand;
                            OPERATOR_DECL op = mul.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            if (op == null)
                                return null; //this operation was not declared
                            opMult = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;

                            PLUS plus = new PLUS();
                            plus.left_operand = left_operand;
                            plus.right_operand = right_operand;
                            TYPE typePlus = plus.GetType(op.return_type, op.return_type, ref opPlus);
                            if (typePlus == null) {
                                OPERATOR_DECL op1 = plus.findBestOpDeclForBinaryOperator(op.return_type, op.return_type);
                                if (op1 == null)
                                    return null;
                                opPlus = NodeType.MethodCall;
                                ovlOpPlus = (INSTANCE.create(op1)).convert() as QualifiedIdentifier;
                                typePlus = op1.return_type;
                                if (op1.return_type != op.return_type) //in this case, when both operators are overloaded, types should be the same
                                {
                                    ERROR.IllegalTypeForBinOperator(this.sourceContext, "+*", type1.ToString(), type2.ToString());
                                    this.ErrorReported = true;
                                }
                            }
                            return typePlus;
                        } else
                            return null;
                        }
                } else if (!CONTEXT.firstPass) {
                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                    }
                }

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext, "+*", type1.ToString(), type2.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("PseudoScalarProduct \\; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    //Element-wise Multiplication
    // ===
    //

    public sealed class MULTIPLY_ELEMENTWISE : BINARY {
        // Constructor
        public MULTIPLY_ELEMENTWISE() : base(ASTNodeType.MULTIPLY_ELEMENTWISE, ".*") { }

        private NodeType opMult; //operations for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val, type, sourceContext);
                return node;
            }

            // Operands are converted by base.convert()
            Expression mult = (Expression)base.convert();
            if (node != null)
                return node;

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opMult, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opMult, type);
            }

            node = mult;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".*", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".*", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".*", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, ".*", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".*", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for binary .*
        {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ANY_TYPE || type2 is ANY_TYPE) {
                    internal_type = new ANY_TYPE();
                    return internal_type;
                }

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[rank_left];

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            for (int i = 0; i < rank_left; i++) {
                                if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                    return null;
                                else
                                    res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                                res.isOpen = false;
                            }
                        }

                        res.dimensions = new EXPRESSION_LIST(rank_left);
                        res.dimensions.Length = rank_left;

                        TYPE type1_base = ((ARRAY_TYPE)type1).base_type;
                        TYPE type2_base = ((ARRAY_TYPE)type2).base_type;

                        long w1, w2;

                        if (type1_base is INTEGER_TYPE && type2_base is INTEGER_TYPE) {
                            w1 = ((INTEGER_TYPE)type1_base).width;
                            w2 = ((INTEGER_TYPE)type2_base).width;
                            opMult = NodeType.Mul_Ovf;
                            res.base_type = new INTEGER_TYPE(w1 > w2 ? w1 : w2);
                        } else if (type1_base is CARDINAL_TYPE && type2_base is CARDINAL_TYPE) {
                            w1 = ((CARDINAL_TYPE)type1_base).width;
                            w2 = ((CARDINAL_TYPE)type2_base).width;
                            opMult = NodeType.Mul_Ovf_Un; //error on Mono
#if ROTOR
                            opMult = NodeType.Mul;
#endif
                            res.base_type = new CARDINAL_TYPE(w1 > w2 ? w1 : w2);
                        } else if (type1_base is INTEGER_TYPE && type2_base is CARDINAL_TYPE) {
                            w1 = ((INTEGER_TYPE)type1_base).width;
                            w2 = ((CARDINAL_TYPE)type2_base).width;
                            opMult = NodeType.Mul_Ovf;
                            res.base_type = new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
                        } else if (type1_base is CARDINAL_TYPE && type2_base is INTEGER_TYPE) {
                            w1 = ((CARDINAL_TYPE)type1_base).width;
                            w2 = ((INTEGER_TYPE)type2_base).width;
                            opMult = NodeType.Mul_Ovf;
                            res.base_type = new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
                        } else if (type1_base is REAL_TYPE && (type2_base is INTEGER_TYPE || type2_base is CARDINAL_TYPE) ||
                                    type2_base is REAL_TYPE && (type1_base is INTEGER_TYPE || type1_base is CARDINAL_TYPE)) {
                            opMult = NodeType.Mul;
                            res.base_type = new REAL_TYPE(64); // 32 
                        } else if (type1_base is REAL_TYPE && type2_base is REAL_TYPE) {
                            w1 = ((REAL_TYPE)type1_base).width;
                            w2 = ((REAL_TYPE)type2_base).width;
                            opMult = NodeType.Mul;
                            res.base_type = new REAL_TYPE(w1 > w2 ? w1 : w2);
                        } else if (type1_base is SET_TYPE && type2_base is SET_TYPE) {
                            w1 = ((SET_TYPE)type1_base).width;
                            w2 = ((SET_TYPE)type2_base).width;
                            opMult = NodeType.And;
                            res.base_type = new SET_TYPE(w1 > w2 ? w1 : w2);
                        } else if (!CONTEXT.firstPass) {
                            //OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            MULTIPLY mul = new MULTIPLY();
                            mul.left_operand = left_operand;
                            mul.right_operand = right_operand;
                            OPERATOR_DECL op = mul.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            if (op == null)
                                return null; //this operation was not declared
                            opMult = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            res.base_type = op.return_type;
                        } else
                            return null;

                        internal_type = res;
                        return internal_type;
                    }
                }

                if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                    int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                    int rank_right = ((SPARSE_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        SPARSE_TYPE res = new SPARSE_TYPE();
                        res.dimensions = new EXPRESSION_LIST(rank_left);
                        res.dimensions.Length = rank_left;
                        res.isVector = rank_left == 1;

                        /////////
                        TYPE type1_base = ((SPARSE_TYPE)type1).base_type;
                        TYPE type2_base = ((SPARSE_TYPE)type2).base_type;

                        long w1, w2;

                        if (type1_base is INTEGER_TYPE && type2_base is INTEGER_TYPE) {
                            w1 = ((INTEGER_TYPE)type1_base).width;
                            w2 = ((INTEGER_TYPE)type2_base).width;
                            opMult = NodeType.Mul_Ovf;
                            res.base_type = new INTEGER_TYPE(w1 > w2 ? w1 : w2);
                        } else if (type1_base is CARDINAL_TYPE && type2_base is CARDINAL_TYPE) {
                            w1 = ((CARDINAL_TYPE)type1_base).width;
                            w2 = ((CARDINAL_TYPE)type2_base).width;
                            opMult = NodeType.Mul_Ovf_Un; //error on Mono
#if ROTOR
                            opMult = NodeType.Mul;
#endif
                            res.base_type = new CARDINAL_TYPE(w1 > w2 ? w1 : w2);
                        } else if (type1_base is INTEGER_TYPE && type2_base is CARDINAL_TYPE) {
                            w1 = ((INTEGER_TYPE)type1_base).width;
                            w2 = ((CARDINAL_TYPE)type2_base).width;
                            opMult = NodeType.Mul_Ovf;
                            res.base_type = new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
                        } else if (type1_base is CARDINAL_TYPE && type2_base is INTEGER_TYPE) {
                            w1 = ((CARDINAL_TYPE)type1_base).width;
                            w2 = ((INTEGER_TYPE)type2_base).width;
                            opMult = NodeType.Mul_Ovf;
                            res.base_type = new INTEGER_TYPE(w1 > w2 ? w1 : (w1 == w2 ? (2 * w1) : w2));
                        } else if (type1_base is REAL_TYPE && (type2_base is INTEGER_TYPE || type2_base is CARDINAL_TYPE) ||
                                    type2_base is REAL_TYPE && (type1_base is INTEGER_TYPE || type1_base is CARDINAL_TYPE)) {
                            opMult = NodeType.Mul;
                            res.base_type = new REAL_TYPE(64); // 32 
                        } else if (type1_base is REAL_TYPE && type2_base is REAL_TYPE) {
                            w1 = ((REAL_TYPE)type1_base).width;
                            w2 = ((REAL_TYPE)type2_base).width;
                            opMult = NodeType.Mul;
                            res.base_type = new REAL_TYPE(w1 > w2 ? w1 : w2);
                        }
                        //////////////

                        if (res.base_type == null)
                            return null;
                        return res;
                    }
                } else if (!CONTEXT.firstPass) {
                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                    }
                }

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext, ".*", type1.ToString(), type2.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("MULTIPLY_ELEMENTWISE \\; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    //Element-wise Division
    // ===
    //

    public sealed class DIVIDE_ELEMENTWISE : BINARY {
        // Constructor
        public DIVIDE_ELEMENTWISE() : base(ASTNodeType.DIVIDE_ELEMENTWISE, "./") { }

        private NodeType opDiv; //operations for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val, type, sourceContext);
                return node;
            }

            // Operands are converted by base.convert()
            Expression div = (Expression)base.convert();
            if (node != null)
                return node;

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opDiv, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opDiv, type);
            }

            node = div;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "./", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "./", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "./", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, "./", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "./", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for binary ./
        {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ANY_TYPE || type2 is ANY_TYPE) {
                    internal_type = new ANY_TYPE();
                    opDiv = NodeType.Div;
                    return internal_type;
                }

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[rank_left];

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            for (int i = 0; i < rank_left; i++) {
                                if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                    return null;
                                else
                                    res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                                res.isOpen = false;
                            }
                        }

                        res.dimensions = new EXPRESSION_LIST(rank_left);
                        res.dimensions.Length = rank_left;

                        TYPE type1_base = ((ARRAY_TYPE)type1).base_type;
                        TYPE type2_base = ((ARRAY_TYPE)type2).base_type;

                        if ((((ARRAY_TYPE)type1).base_type is INTEGER_TYPE ||
                            ((ARRAY_TYPE)type1).base_type is CARDINAL_TYPE ||
                            ((ARRAY_TYPE)type1).base_type is REAL_TYPE)
                            &&
                            (((ARRAY_TYPE)type2).base_type is INTEGER_TYPE ||
                            ((ARRAY_TYPE)type2).base_type is CARDINAL_TYPE ||
                            ((ARRAY_TYPE)type2).base_type is REAL_TYPE)) {
                            opDiv = NodeType.Div;
                            res.base_type = new REAL_TYPE(64);
                        } else if (((ARRAY_TYPE)type1).base_type is SET_TYPE && ((ARRAY_TYPE)type2).base_type is SET_TYPE) {
                            long w1 = ((SET_TYPE)((ARRAY_TYPE)type1).base_type).width;
                            long w2 = ((SET_TYPE)((ARRAY_TYPE)type2).base_type).width;
                            opDiv = NodeType.Div;
                            res.base_type = new SET_TYPE(w1 > w2 ? w1 : w2);
                        } else if (!CONTEXT.firstPass) {
                            //OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            DIVIDE div = new DIVIDE();
                            div.left_operand = left_operand;
                            div.right_operand = right_operand;
                            OPERATOR_DECL op = div.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            if (op == null)
                                return null; //this operation was not declared
                            opDiv = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            res.base_type = op.return_type;
                        } else
                            return null;
                        
                        internal_type = res;
                        return internal_type;
                    }
                }

                if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                    int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                    int rank_right = ((SPARSE_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        SPARSE_TYPE res = new SPARSE_TYPE();
                        res.dimensions = new EXPRESSION_LIST(rank_left);
                        res.dimensions.Length = rank_left;
                        res.isVector = rank_left == 1;

                        //////////////
                        opDiv = NodeType.Div;
                        res.base_type = new REAL_TYPE(64);
                        //////////////////

                        if (res.base_type == null)
                            return null;
                        return res;
                    }
                } else if (!CONTEXT.firstPass) {
                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                    }
                }

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext, "./", type1.ToString(), type2.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("DIVIDE_ELEMENTWISE \\; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    // DIV
    // ===
    //
    public sealed class DIV : BINARY {
        // Constructor
        public DIV ( ) : base(ASTNodeType.DIV, "div") { }

        NodeType opDiv; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val, type, sourceContext);
                return node;
            }

            Expression div = (Expression)base.convert();
            if (node != null)
                return node;

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opDiv, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opDiv, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opDiv, type);
            }

            div.NodeType = NodeType.Div;  // Div opcode in CLI is the common one for all kinds of division
            node = div;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: long/ulong
            //if ( (val1 is long || val1 is ulong) && (val2 is long || val2 is ulong) )
            //{
            //    if ( val1 is long ) val1 = (ulong)(long)val1;
            //    if ( val2 is long ) val2 = (ulong)(long)val2;

            //    // Now both val1 and val2 are ulongs
            //    if ( (ulong)val2 == 0 )
            //    {
            //        ERROR.ZeroDivisor(right_operand.sourceContext);
            //        return null;
            //    }
            //    if ( (ulong)val2 < 0 )
            //    {
            //        ERROR.NegativeConst("as divisor of 'div' operator",right_operand.sourceContext);
            //        return null;
            //    }
            //    base.val = (ulong)val1 / (ulong)val2;
            //    return base.val;
            //}

            if ((val1 is long) && (val2 is long)) {
                if ((long)val2 == 0) {
                    ERROR.ZeroDivisor(right_operand.sourceContext);
                    return null;
                }
                base.val = (long)val1 / (long)val2;
                return base.val;
            } else if ((val1 is ulong) && (val2 is ulong)) {
                if ((ulong)val2 == 0) {
                    ERROR.ZeroDivisor(right_operand.sourceContext);
                    return null;
                }
                base.val = (ulong)val1 / (ulong)val2;
                return base.val;
            } else {
                ERROR.SystemErrorIn("div.calculate", "illegal operand type(s)");
                return null;
            }
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if ((opDiv == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            object val2 = base.calculateRight();
            if (val2 != null) {
                if (val2 is long) {
                    if ((long)val2 == 0) {
                        ERROR.ZeroDivisor(right_operand.sourceContext);
                        return false;
                    }
                } else if (val2 is ulong) {
                    if ((ulong)val2 == 0) {
                        ERROR.ZeroDivisor(right_operand.sourceContext);
                        return false;
                    }
                }
            }

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "div", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "div", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "div", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, "div", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "div", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        /// <summary>
        /// returns the result type of the mod of two variables of types
        /// type1 and type2
        /// </summary>
        /// <param name="type1"></param>
        /// <param name="type2"></param>
        /// <returns></returns>
        private TYPE GetType(TYPE type1, TYPE type2, bool wasArray) {
            if (type1 == null || type2 == null)
                return null;

            // Legal types for operands of binary 'DIV': INTEGER, CARDINAL.
            //
            // Result type for DIV: always INTEGER.
            //
            // All other combinations are illegal 
            // (excluding IsMath operations with IsMath arrays of course)

            long w1, w2;

            if (type1 is INTEGER_TYPE && type2 is INTEGER_TYPE) {
                w1 = ((INTEGER_TYPE)type1).width;
                w2 = ((INTEGER_TYPE)type2).width;
                opDiv = NodeType.Div;
                return new INTEGER_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is CARDINAL_TYPE && type2 is CARDINAL_TYPE) {
                w1 = ((CARDINAL_TYPE)type1).width;
                w2 = ((CARDINAL_TYPE)type2).width;
                opDiv = NodeType.Div;
                return new CARDINAL_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is INTEGER_TYPE && type2 is CARDINAL_TYPE) {
                w1 = ((INTEGER_TYPE)type1).width;
                w2 = ((CARDINAL_TYPE)type2).width;
                opDiv = NodeType.Div;
                return new INTEGER_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is CARDINAL_TYPE && type2 is INTEGER_TYPE) {
                w1 = ((CARDINAL_TYPE)type1).width;
                w2 = ((INTEGER_TYPE)type2).width;
                opDiv = NodeType.Div;
                return new INTEGER_TYPE(w1 > w2 ? w1 : w2);
            }

            if (!CONTEXT.firstPass) {
                NODE call = null;
                if (!wasArray) {
                    call = base.resolveOperator();
                } else {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1, type2);
                    if (op == null)
                        return null; //this operation was not declared

                    opDiv = NodeType.MethodCall;
                    ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                    return op.return_type;
                }
                if (call is CALL) {
                    this.call = (CALL)call;
                    opDiv = NodeType.MethodCall;
                    return call.type;
                }
            }

            if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                if (rank_left != rank_right) { return null; } else {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    res.const_dimensions = new int[rank_left];

                    if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be calculated now
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                return null;
                            else
                                res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                            res.isOpen = false;
                        }
                    }

                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;

                    res.base_type = GetType(((ARRAY_TYPE)type1).base_type, ((ARRAY_TYPE)type2).base_type, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }
            }

            if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)type2).dimensions.Length;

                if (rank_left != rank_right) { return null; } else {
                    SPARSE_TYPE res = new SPARSE_TYPE();
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;
                    res.isVector = rank_left == 1;

                    res.base_type = GetType(((SPARSE_TYPE)type1).base_type, ((SPARSE_TYPE)type2).base_type, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }
            }

            if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                //2 cases are possible: 
                //array-scalar div => array
                //scalar-array div => array

                int arrayRank = 0;
                TYPE returnArrayBaseType;

                ARRAY_TYPE res = new ARRAY_TYPE();
                res.isMath = true;
                res.isOpen = true;

                if (type1 is ARRAY_TYPE) {
                    arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                    returnArrayBaseType = GetType(((ARRAY_TYPE)type1).base_type, type2, true);
                    if (returnArrayBaseType == null)
                        return null;

                    res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                } else {
                    arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                    returnArrayBaseType = GetType(type1, ((ARRAY_TYPE)type2).base_type, true);
                    if (returnArrayBaseType == null)
                        return null;

                    res.const_dimensions = new int[arrayRank];

                    if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                        for (int i = 0; i < arrayRank; i++) {
                            res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                        }
                        res.isOpen = false;
                    }
                }

                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;

                return res;
            }

            return null;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for MOD
        {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                // Legal types for operands of binary 'DIV': INTEGER, CARDINAL.
                //
                // Result type for DIV: always INTEGER.
                //
                // All other combinations are illegal (excluding IsMath operations with IsMath arrays)

                internal_type = GetType(type1, type2, false);

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext, "div", type1.ToString(), type2.ToString());
                    this.ErrorReported = true;
                }

                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("DIV, line={0} ", this.sourceContext.StartLine.ToString());
            if ( type != null )
                System.Console.Write("; TYPE={0}",type.ToString());
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // MOD
    // ===
    //
    public sealed class MOD : BINARY {
        // Constructor
        public MOD ( ) : base(ASTNodeType.MOD, "mod") { }

        NodeType opMod; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val, type, sourceContext);
                return node;
            }

            Expression mod = (Expression)base.convert();
            if (node != null)
                return node;

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opMod, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opMod, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opMod, type);
            }

            mod.NodeType = NodeType.Rem;  // Rem opcode is for all kinds of division
            node = mod;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: long/ulong
            //if ((val1 is long || val1 is ulong) && (val2 is long || val2 is ulong))
            //{
            //    if (val1 is long) val1 = (ulong)(long)val1;
            //    if (val2 is long) val2 = (ulong)(long)val2;

            //    // Now both val1 and val2 are ulongs
            //    if ((ulong)val2 == 0)
            //    {
            //        ERROR.ZeroDivisor(right_operand.sourceContext);
            //        return null;
            //    }
            //    if ((ulong)val2 < 0)
            //    {
            //        ERROR.NegativeConst("as divisor of 'mod' operator", right_operand.sourceContext);
            //        return null;
            //    }
            //    base.val = (ulong)val1 % (ulong)val2;
            //    return base.val;
            //}

            if ((val1 is long) && (val2 is long)) {
                if ((long)val2 == 0) {
                    ERROR.ZeroDivisor(right_operand.sourceContext);
                    return null;
                }
                base.val = (long)val1 % (long)val2;
                return base.val;
            } else if ((val1 is ulong) && (val2 is ulong)) {
                if ((ulong)val2 == 0) {
                    ERROR.ZeroDivisor(right_operand.sourceContext);
                    return null;
                }
                base.val = (ulong)val1 % (ulong)val2;
                return base.val;
            } else {
                ERROR.SystemErrorIn("mod.calculate", "illegal operand type(s)");
                return null;
            }
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check type??!!!
            if ((opMod == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            object val2 = base.calculateRight();
            if (val2 != null) {
                if (val2 is long) {
                    if ((long)val2 == 0) {
                        ERROR.ZeroDivisor(right_operand.sourceContext);
                        return false;
                    }
                } else if (val2 is ulong) {
                    if ((ulong)val2 == 0) {
                        ERROR.ZeroDivisor(right_operand.sourceContext);
                        return false;
                    }
                }
            }

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "mod", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "mod", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "mod", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, "mod", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "mod", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        /// <summary>
        /// returns the result type of the mod of two variables of types
        /// type1 and type2
        /// </summary>
        /// <param name="type1"></param>
        /// <param name="type2"></param>
        /// <returns></returns>
        private TYPE GetType(TYPE type1, TYPE type2, bool wasArray) {
            if (type1 == null || type2 == null)
                return null;

            // Legal types for operands of binary 'MOD': INTEGER, CARDINAL.
            //
            // Result type for MOD: always INTEGER.
            //
            // All other combinations are illegal 
            //(excluding IsMath operations with IsMath arrays of course)

            long w1, w2;

            if (type1 is INTEGER_TYPE && type2 is INTEGER_TYPE) {
                w1 = ((INTEGER_TYPE)type1).width;
                w2 = ((INTEGER_TYPE)type2).width;
                opMod = NodeType.Rem;
                return new INTEGER_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is CARDINAL_TYPE && type2 is CARDINAL_TYPE) {
                w1 = ((CARDINAL_TYPE)type1).width;
                w2 = ((CARDINAL_TYPE)type2).width;
                opMod = NodeType.Rem;
                return new CARDINAL_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is INTEGER_TYPE && type2 is CARDINAL_TYPE) {
                w1 = ((INTEGER_TYPE)type1).width;
                w2 = ((CARDINAL_TYPE)type2).width;
                opMod = NodeType.Rem;
                return new INTEGER_TYPE(w1 > w2 ? w1 : w2);
            }
            if (type1 is CARDINAL_TYPE && type2 is INTEGER_TYPE) {
                w1 = ((CARDINAL_TYPE)type1).width;
                w2 = ((INTEGER_TYPE)type2).width;
                opMod = NodeType.Rem;
                return new INTEGER_TYPE(w1 > w2 ? w1 : w2);
            }

            if (!CONTEXT.firstPass) {
                NODE call = null;
                if (!wasArray) {
                    call = base.resolveOperator();
                } else {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1, type2);
                    if (op == null)
                        return null; //this operation was not declared

                    opMod = NodeType.MethodCall;
                    ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                    return op.return_type;
                }
                if (call is CALL) {
                    this.call = (CALL)call;
                    opMod = NodeType.MethodCall;
                    return call.type;
                }
            }

            if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                if (rank_left != rank_right) { return null; } else {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    res.const_dimensions = new int[rank_left];

                    if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be calculated now
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                return null;
                            else
                                res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                            res.isOpen = false;
                        }
                    }

                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;

                    res.base_type = GetType(((ARRAY_TYPE)type1).base_type, ((ARRAY_TYPE)type2).base_type, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }
            }

            if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)type2).dimensions.Length;

                if (rank_left != rank_right) { return null; } else {
                    SPARSE_TYPE res = new SPARSE_TYPE();
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;
                    res.isVector = rank_left == 1;

                    res.base_type = GetType(((SPARSE_TYPE)type1).base_type, ((SPARSE_TYPE)type2).base_type, true);
                    if (res.base_type == null)
                        return null;
                    return res;
                }
            }

            if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                //2 cases are possible: 
                //array-scalar mod => array
                //scalar-array mod => array

                int arrayRank = 0;
                TYPE returnArrayBaseType;

                if (type1 is ARRAY_TYPE) {
                    arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                    returnArrayBaseType = GetType(((ARRAY_TYPE)type1).base_type, type2, true);
                    if (returnArrayBaseType == null)
                        return null;
                } else {
                    arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                    returnArrayBaseType = GetType(type1, ((ARRAY_TYPE)type2).base_type, true);
                    if (returnArrayBaseType == null)
                        return null;
                }

                ARRAY_TYPE res = new ARRAY_TYPE();
                res.isMath = true;
                res.isOpen = true;
                res.const_dimensions = new int[arrayRank];
                res.dimensions = new EXPRESSION_LIST(arrayRank);
                res.dimensions.Length = arrayRank;
                res.base_type = returnArrayBaseType;

                return res;
            }

            return null;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for MOD
        {
            get {
                if ( internal_type != null && !(internal_type is ANY_TYPE) )
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                // Legal types for operands of binary 'MOD': INTEGER, CARDINAL.
                //
                // Result type for MOD: always INTEGER.
                //
                // All other combinations are illegal (excluding IsMath operations with IsMath arrays)

                internal_type = GetType(type1, type2, false);

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext,"mod",type1.ToString(),type2.ToString());
                    this.ErrorReported = true;
                }
                
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("MOD ");
            if ( type != null )
                System.Console.Write("; TYPE={0}",type.ToString());
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // EXPONENT
    // ========
    //
    public sealed class EXPONENT : BINARY {
        // Constructor
        public EXPONENT ( ) : base(ASTNodeType.EXPONENT, "**") { }

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = LITERAL.create(val,type, sourceContext);
                return node;
            }

            Expression mult = (Expression)base.convert();
            if (node != null)
                return node;  // a user-defined ** operator found

            int shift;
            if (this.left_operand.type is REAL_TYPE)
                shift = 2;
            else {
                TYPE t = left_operand.type;
                long w;
                if (t is INTEGER_TYPE)
                    w = ((INTEGER_TYPE)t).width;
                else if (t is CARDINAL_TYPE)
                    w = ((CARDINAL_TYPE)t).width;
                else
                    return null;
                if (w <= 32)
                    shift = 0;
                else
                    shift = 1;
            }

            MethodCall exp = new MethodCall();
            exp.Callee = new MemberBinding(null,STANDARD.common.GetMembersNamed(Identifier.For("exponent"))[shift]);
            exp.Callee.SourceContext = this.sourceContext;
            exp.Operands = new ExpressionList();
            exp.Operands.Add(((BinaryExpression)mult).Operand1);
            exp.Operands.Add(((BinaryExpression)mult).Operand2);
            node = exp;

            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

                // Possible types: long/ulong, ulong
            else if ((val1 is ulong || val1 is long) && val2 is ulong) {
                long bas = val1 is long ? (long)val1 : (long)(ulong)val1;

                long res = 1;
                ulong rep = (ulong)val2;
                for (ulong i = 1; i <= rep; i++)
                    res *= bas;
                base.val = res;
            } else if ((val1 is float || val1 is double) && (val2 is ulong || val2 is long)) {
                double bas = val1 is float ? (double)(float)val1 : (double)val1;
                long   exp = val2 is long ? (long)val2 : (long)(ulong)val2;

                double res = 1.0;
                long  exp1 = exp>0 ? exp : -exp;

                for (int i = 1; i <= exp1; i++)
                    res *= bas;
                base.val = exp>0 ? res : 1/res;
            } else {
                ERROR.SystemErrorIn("EXPONENT.calculate","illegal operand type(s)");
                return null;
            }
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check types ???!!!
            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for **
        {
            get {
                if ( internal_type != null && !(internal_type is ANY_TYPE) )
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                // Legal types for operands of '**': INTEGER/CARDINAL/REAL, INTEGER.
                //
                // Result types for **: INTEGER  ** CARDINAL => INTEGER;
                //                      CARDINAL ** CARDINAL => CARDINAL;
                //                      REAL     ** INTEGER  => REAL.
                // All other combinations are illegal.

                long w;

                if (type1 is INTEGER_TYPE && type2 is CARDINAL_TYPE) {
                    w = ((INTEGER_TYPE)type1).width;
                    internal_type = new INTEGER_TYPE(w);
                } else if (type1 is CARDINAL_TYPE && type2 is CARDINAL_TYPE) {
                    w = ((CARDINAL_TYPE)type1).width;
                    internal_type = new CARDINAL_TYPE(w);
                } else if (type1 is REAL_TYPE && (type2 is INTEGER_TYPE || type2 is CARDINAL_TYPE)) {
                    w = ((REAL_TYPE)type1).width;
                    internal_type = new REAL_TYPE(w);
                } else if (!CONTEXT.firstPass) {
                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                    }
                } 
                if (type1 is ARRAY_TYPE && type2 is CARDINAL_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    if (rank_left == 2) {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[2];
                        res.dimensions = new EXPRESSION_LIST(2);
                        res.dimensions.Length = 2;

                        if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                            //array is static; lengths can be calculated now
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[0] !=
                                    ((ARRAY_TYPE)left_operand.type).const_dimensions[1])
                                return null;
                            res.const_dimensions[0] = ((ARRAY_TYPE)type1).const_dimensions[0];
                            res.const_dimensions[1] = ((ARRAY_TYPE)type1).const_dimensions[1];
                            res.isOpen = false;
                        }
                        // (jb) needs more options
                        res.base_type = (((ARRAY_TYPE)type1).base_type);
                        if (res.base_type == null)
                            return null;
                        return res;
                    }
                }
                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext,"**",type1.ToString(),type2.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("EXPONENT **; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // AND
    // ===
    //
    public sealed class AND : BINARY {
        // Constructor
        public AND ( ) : base(ASTNodeType.AND, "&") { }

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression and = (Expression)base.convert();
            if (node != null)
                return node;

            and.NodeType = NodeType.LogicalAnd;
            node = and;
            return node;

        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: bool.
            // Only boolean values are OK.
            if (!(val1 is bool) || !(val2 is bool)) {
                ERROR.SystemErrorIn("AND.calculate","illegal operand type(s)");
                return null;
            }
            base.val = (bool)val1 && (bool)val2;
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check types ???!!!
            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for &
        {
            get {
                if ( internal_type != null && !(internal_type is ANY_TYPE) )
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                // Legal types for operands of binary '&': BOOLEAN.
                // Result types for binary plus: BOOLEAN.
                // All other combinations are illegal.
                if (type1 is BOOLEAN_TYPE && type2 is BOOLEAN_TYPE) {
                    internal_type = type1;
                } else if (!CONTEXT.firstPass) {
                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                    }
                }

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext,"&",type1.ToString(),type2.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("AND &, line={0}", this.sourceContext.StartLine.ToString());
            if ( type != null )
                System.Console.Write("; TYPE={0}",type.ToString());
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // OR
    // ==
    //
    public sealed class OR : BINARY {
        // Constructor
        public OR ( ) : base(ASTNodeType.OR, "or") { }

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression or = (Expression)base.convert();
            if (node != null)
                return node;

            or.NodeType = NodeType.LogicalOr;
            node = or;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: bool.
            // Only boolean values are OK.
            if (!(val1 is bool) || !(val2 is bool)) {
                ERROR.SystemErrorIn("or.calculate","illegal operand type(s)");
                return null;
            }
            base.val = (bool)val1 || (bool)val2;
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Check types !!!???
            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates result type for OR
        {
            get {
                if ( internal_type != null && !(internal_type is ANY_TYPE) )
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                // Legal types for operands of binary OR: BOOLEAN.
                // Result types for binary OR: BOOLEAN.
                // All other combinations are illegal.
                if (type1 is BOOLEAN_TYPE && type2 is BOOLEAN_TYPE) {
                    internal_type = type1;
                } else if (!CONTEXT.firstPass) {
                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                    }
                }

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext,"or",type1.ToString(),type2.ToString());
                    this.ErrorReported = true;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }


        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("OR ");
            if ( type != null )
                System.Console.Write("; TYPE={0}",type.ToString());
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // RELATION
    // ========
    //
    public abstract class RELATION : BINARY {
        // Constructor
        public RELATION ( ASTNodeType astNodeType, string c ) : base(astNodeType, c) { }

        //----------------------------------------------------------------------------

        public override Node convert ( ) // Generates corresponding CCI node.
        {
            if (call != null) {
                // Operator overloading was found
                node = call.convert();
                return node;
            }
            TYPE type1 = this.left_operand.type;
            TYPE type2 = this.right_operand.type;

            bool type1_is_string = type1 is STRING_TYPE || ((type1 is EXTERNAL_TYPE) && (((EXTERNAL_TYPE)type1).entity.NodeType == NodeType.String));
            bool type2_is_string = type2 is STRING_TYPE || ((type2 is EXTERNAL_TYPE) && (((EXTERNAL_TYPE)type2).entity.NodeType == NodeType.String));

            // Rough check; thorough check is already done.
            int  index = 0;
            if      ( type1_is_string     && type2_is_string     ) index = 0;
            else if ( type1_is_string     && type2 is ARRAY_TYPE ) index = 1;
            else if ( type1 is ARRAY_TYPE && type2_is_string     ) index = 2;
            else if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE
                && !(((ARRAY_TYPE)type1).base_type is STRING_TYPE)
                && !(((ARRAY_TYPE)type2).base_type is STRING_TYPE)) { node = null; return node; }
            else if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) index = 3;
            else // simple comparison
                return base.convert();

            // comparison of strings via Zonnon RTL

            string name = null;
            bool   inverse = false;
            if      ( this is EQUAL )         { name = "equal";   inverse = false; }
            else if ( this is NON_EQUAL )     { name = "equal";   inverse = true;  }
            else if ( this is LESS )          { name = "less";    inverse = false; }
            else if ( this is LESS_EQUAL )    { name = "greater"; inverse = true;  }
            else if ( this is GREATER )       { name = "greater"; inverse = false; }
            else if ( this is GREATER_EQUAL ) { name = "less";    inverse = true;  }

            AssemblyNode rtlAssembly = AssemblyNode.GetAssembly(typeof(ZonnonHalt).Assembly);
            TypeNode     comparator  = rtlAssembly.GetType(Identifier.For("Zonnon.RTL"),
                                                           Identifier.For("Comparator"));
            MethodCall compare = new MethodCall();
            compare.Callee = new MemberBinding(null,comparator.GetMembersNamed(Identifier.For(name))[index]);
            compare.Callee.SourceContext = this.sourceContext;
            compare.Operands = new ExpressionList();

            Expression left  = (Expression)left_operand.convert();
            left.SourceContext = left_operand.sourceContext;
            Expression right = (Expression)right_operand.convert();
            right.SourceContext = right_operand.sourceContext;

            compare.Operands.Add(left);
            compare.Operands.Add(right);

            if (!inverse)
                return compare;

            UnaryExpression negation = new UnaryExpression();
            negation.Operand = compare;
            negation.SourceContext = compare.SourceContext;
            negation.NodeType = NodeType.LogicalNot;
            return negation;
        }

        //--------------------------------------------------------------------

        public abstract override object calculate ( );   // Calculates constant expressions

        //-------------------------------------------------------------------------------------

        public override bool validate ( ) { return base.validate(); }  // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public bool IsExternalSimple(TYPE type)
        {
            if(type == null) return false;
            EXTERNAL_TYPE ext = type as EXTERNAL_TYPE;
            if (ext == null) return false;
            if (ext.entity == null) return false;
            Node ent = ext.entity;
            if (ent == SystemTypes.Int8 ||
                ent == SystemTypes.Int16 ||
                ent == SystemTypes.Int32 ||
                ent == SystemTypes.Int64 ||
                ent == SystemTypes.UInt8 ||
                ent == SystemTypes.UInt16 ||
                ent == SystemTypes.UInt32 ||
                ent == SystemTypes.UInt64 ||
                ent == SystemTypes.Char ||
                ent == SystemTypes.Boolean ||
                ent == SystemTypes.Double ||
                ent == SystemTypes.Single
                ) return true;
            return false;
        }

        public override TYPE type  // evaluates result type for relation
        {
            get {
                if ( internal_type != null && !(internal_type is ANY_TYPE) )
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                bool err = false;
                bool WeKnowTheType = true;

                if ( type1 == null || type2 == null ) return null;
                if ( ( type1 is UNKNOWN_TYPE || type2 is UNKNOWN_TYPE ) /* && TREE.firstPass */ )
                    return null;

                // Legal types for operands of any relation:
                //               INTEGER, CARDINAL, REAL, CHAR, SET, ENUM,
                //               ARRAY, STRING, EXTERNAL-STRING,
                // and some combinations of them.
                //
                // Legal types for operands of =/#: types from above plus BOOLEAN.
                //
                // Result types for any relation: BOOLEAN.
                // All other types are illegal.
                //

                // First, consider simple cases which do not require any operand conversions...

                bool leftIsSimple  = type1 is INTEGER_TYPE || type1 is CARDINAL_TYPE || type1 is REAL_TYPE ||
                                     type1 is CHAR_TYPE    || type1 is ENUM_TYPE || IsExternalSimple (type1),

                     rightIsSimple = type2 is INTEGER_TYPE || type2 is CARDINAL_TYPE || type2 is REAL_TYPE ||
                                     type2 is CHAR_TYPE || type2 is ENUM_TYPE || IsExternalSimple(type2);

                if (leftIsSimple && rightIsSimple) {
                    // It's quite OK
                }

                // BOOLEAN_TYPEs can be compared using only = and #
                else if (type1 is BOOLEAN_TYPE && type2 is BOOLEAN_TYPE) {
                    err = !(this is EQUAL) && !(this is NON_EQUAL);
                }

                // SET_TYPEs can be compared using only = and #
                else if (type1 is SET_TYPE && type2 is SET_TYPE) {
                    err = !(this is EQUAL) && !(this is NON_EQUAL);
                }

                // CHAR_TYPE can be compared to STRING_LITERAL with length of 1
                else if (type1 is CHAR_TYPE && type2 is STRING_TYPE) {
                    // Here we have to check for STRING_LITERAL of length 1:
                    // the same algorithm is in TYPE.AssignmentCompatible()
                    // and in the next elsif branch.

                    // The only possible case: string literal of length 1.
                    if (this.right_operand is STRING_LITERAL) {
                        string str = ((STRING_LITERAL)this.right_operand).str;
                        if (str.Length == 1) {
                            // String literal of length 1 is treated here as character literal.
                            // One additional check: the left type should be assignment compatible
                            // with type of the element of standard string, i.e., it should be CHAR{16}.
                            if (((CHAR_TYPE)type1).width != 16) {
                                // Replace STRING_TYPE for CHAR_TYPE for more adequate diagnostics
                                type1 = new CHAR_TYPE(16);
                                err = true;
                            } else // left width == 16
                            {
                                // Creating CHAR_LITERAL node and replace
                                // original STRING_LITERAL node in the tree.
                                this.right_operand = CHAR_LITERAL.create(str[0],right_operand.sourceContext);
                            }
                        }
                    } else
                        err = true;
                } else if (type1 is STRING_TYPE && type2 is CHAR_TYPE) {
                    if (this.left_operand is STRING_LITERAL) {
                        string str = ((STRING_LITERAL)this.left_operand).str;
                        if (str.Length == 1) {
                            if (((CHAR_TYPE)type2).width != 16) {
                                type1 = new CHAR_TYPE(16);
                                err = true;
                            } else // left width == 16
                            {
                                this.left_operand = CHAR_LITERAL.create(str[0],left_operand.sourceContext);
                            }
                        }
                    }
                }

                // Comparing two strings...
                else if (type1 is STRING_TYPE && type2 is STRING_TYPE) {
                    if (left_operand is STRING_LITERAL && right_operand is STRING_LITERAL) {
                        string str1 = ((STRING_LITERAL)this.left_operand).str;
                        string str2 = ((STRING_LITERAL)this.right_operand).str;
                        if (str1.Length == 1 && str2.Length == 1) {
                            // Compare two characters
                            left_operand  = CHAR_LITERAL.create(str1[0],left_operand.sourceContext);
                            right_operand = CHAR_LITERAL.create(str2[0],right_operand.sourceContext);
                        }
                    }
                    // Otherwise we will generate the call
                    // to a run-time comparing function (see convert()).
                }

                // STRING (Zonnon) and System.String (.NET) types
                  else if (type1 is STRING_TYPE && type2 is EXTERNAL_TYPE) {
                    Node external = ((EXTERNAL_TYPE)type2).entity;
                    err =  !(external is System.Compiler.Class) ||
                        ((System.Compiler.Class)external).Name.Name != "String";
                } else if (type1 is EXTERNAL_TYPE && type2 is STRING_TYPE) {
                    Node external = ((EXTERNAL_TYPE)type1).entity;
                    err =  !(external is System.Compiler.Class) ||
                        ((System.Compiler.Class)external).Name.Name != "String";
                }

                // Two ARRAYs of CHARs can be compared

                //else if ( type1 is ARRAY_TYPE && type2 is ARRAY_TYPE )
                //{
                //    err = !( ((ARRAY_TYPE)type1).base_type is CHAR_TYPE) ||
                //          !( ((ARRAY_TYPE)type1).base_type is CHAR_TYPE);
                //}

                  //It can be a IsMath array-array or array-scalar or scalar-array variable
                  else if (type1 is ARRAY_TYPE && !(type2 is STRING_TYPE)) {
                    err = false;
                    WeKnowTheType = false;
                } else if (!(type1 is STRING_TYPE) && (type2 is ARRAY_TYPE)) {
                    err = false;
                    WeKnowTheType = false;
                }

                // STRINGs can be compared with ARRAYs of CHARs
                  else if (type1 is STRING_TYPE && type2 is ARRAY_TYPE) {
                    err = !(((ARRAY_TYPE)type2).base_type is CHAR_TYPE);
                } else if (type1 is ARRAY_TYPE && type2 is STRING_TYPE) {
                    err = !(((ARRAY_TYPE)type1).base_type is CHAR_TYPE);
                }

                // ARRAYs of CHARs can be compared with System.String
                  else if (type1 is ARRAY_TYPE && type2 is EXTERNAL_TYPE) {
                    TYPE base_type = ((ARRAY_TYPE)type1).base_type;
                    Node external = ((EXTERNAL_TYPE)type2).entity;

                    err = !(external is System.Compiler.Class) ||
                        ((System.Compiler.Class)external).Name.Name != "String" ||
                        !(base_type is CHAR_TYPE);
                } else if (type1 is EXTERNAL_TYPE && type2 is ARRAY_TYPE) {
                    TYPE base_type = ((ARRAY_TYPE)type2).base_type;
                    Node external = ((EXTERNAL_TYPE)type1).entity;

                    err = !(external is System.Compiler.Class) ||
                        ((System.Compiler.Class)external).Name.Name != "String" ||
                        !(base_type is CHAR_TYPE);
                }

                // ADDITION:
                // Values of the same OBJECT_TYPE/INTERFACE_TYPE can be compared
                // for equality or non-equality
                else if ((type1 is OBJECT_TYPE || type1 is INTERFACE_TYPE) &&
                    type1 == type2 &&
                      (this is EQUAL || this is NON_EQUAL)) {
                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                        return internal_type;
                    }
                    err = false;
                }

                // OBJECT_TYPE, INTERFACE_TYPE, STRING_TYPE, System.String types
                // can be compared with NIL
                  else if (left_operand is NULL) {
                    if (!(this is EQUAL) && !(this is NON_EQUAL)) {
                        err = true;
                    } else if ((type2 is OBJECT_TYPE) || (type2 is INTERFACE_TYPE) || (type2 is STRING_TYPE)) {
                        // It's OK
                    } else if (type2 is EXTERNAL_TYPE) {
                        err = ((EXTERNAL_TYPE)type1).entity as Class == null;
                        // err = ((EXTERNAL_TYPE)type2).entity as Class != SystemTypes.String;
                    }
                } else if (right_operand is NULL) {
                    if (!(this is EQUAL) && !(this is NON_EQUAL)) {
                        err = true;
                    } else if ((type1 is OBJECT_TYPE) || (type1 is INTERFACE_TYPE) || (type1 is STRING_TYPE)) {
                        // It's OK
                    } else if (type1 is EXTERNAL_TYPE) {
                        err = ((EXTERNAL_TYPE)type1).entity as Class == null;
                        // err = ((EXTERNAL_TYPE)type1).entity as Class != SystemTypes.String;
                    }
                }

                // o  OBJECT_TYPE can be compared to NIL;
                // o  otherwise, OBJECT_TYPE can be compared to INTERFACE_TYPE
                //    provided the latter doesn't really have definitions;
                // o  otherwise, OBJECT_TYPE can be compared to INTERFACE_TYPE
                //    provided the OBJECT_TYPE is implemented by INTERFCAE_TYPE;
                // o  Possible comparisons are = and # only.
                  else if (type1 is OBJECT_TYPE && type2 is INTERFACE_TYPE) {
                    UNIT_DECL_LIST D = ((INTERFACE_TYPE)type2).interfaces;
                    DECLARATION    O = ((OBJECT_TYPE)type1).ObjectUnit;

                    if (!(this is EQUAL) && !(this is NON_EQUAL))
                        err = true;
                    else if (right_operand is NULL || D.Length == 0 || IMPLEMENTS.implements(D, (UNIT_DECL)O))
                        err = false;
                    else
                        err = true;
                } else if (type1 is INTERFACE_TYPE && type2 is OBJECT_TYPE) {
                    UNIT_DECL_LIST D = ((INTERFACE_TYPE)type1).interfaces;
                    DECLARATION    O = ((OBJECT_TYPE)type2).ObjectUnit;

                    if (!(this is EQUAL) && !(this is NON_EQUAL))
                        err = true;
                    else if (left_operand is NULL || D.Length == 0 || IMPLEMENTS.implements(D, (UNIT_DECL)O))
                        err = false;
                    else
                        err = true;
                } else if (type1 is EXTERNAL_TYPE && type2 is EXTERNAL_TYPE && ((EXTERNAL_TYPE)type1).entity.NodeType == NodeType.EnumNode && ((EXTERNAL_TYPE)type2).entity.NodeType == NodeType.EnumNode) {
                    internal_type = STANDARD.Boolean.type;
                    err = false;
                }
                // We checked all possible types and found that no one combination
                // of them is not applicable. Hence there might be a user-defined
                // relational operator for object types...
                  else if (!CONTEXT.firstPass) {
                    // PROBLEM: 
                    // Some previously considered cases COVER possible overloading!
                    // For example:
                    //
                    // It's allowed to compare obj=null. For this case, the ambiguity
                    // occurs: either this is predefined semantics (considered above),
                    // OR this is a call to an overloading "=" operator.
                    // 
                    // The same is for obj1 = obj2. We cannot distinguish between
                    // predefined comparation and possible overloading "=" operator...
                    //   -- We can!- there are no OBJECT_TYPE-OBJECT_TYPE checks above!

                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                        return internal_type;
                    } else
                        if ((type1 is OBJECT_TYPE || (type1 is EXTERNAL_TYPE && ((EXTERNAL_TYPE)type1).entity is Class) || type1 is INTERFACE_TYPE) &&
                            (type2 is OBJECT_TYPE || (type2 is EXTERNAL_TYPE && ((EXTERNAL_TYPE)type2).entity is Class) || type2 is INTERFACE_TYPE) &&
                            (this is EQUAL || this is NON_EQUAL)) {
                            internal_type = STANDARD.Boolean.type;
                        } else {
                            err = true;
                            WeKnowTheType = false;
                        }
                }
                // Otherwise: ERROR
                  else {
                    err = true;
                    WeKnowTheType = false;
                }

                if (err && !CONTEXT.firstPass && !this.ErrorReported) {
                    this.ErrorReported = true;
                    ERROR.IllegalTypeForBinOperator(this.sourceContext, this.code, type1.ToString(), type2.ToString());
                } else if (WeKnowTheType)
                    internal_type = STANDARD.Boolean.type;
                else if (!err)
                    internal_type = null; //it's a IsMath operation; the type will be defined later

                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            base.report(shift);
        }
#endif
    }

    // EQUAL
    // =====
    //
    public sealed class EQUAL : RELATION {
        // Constructor
        public EQUAL ( ) : base(ASTNodeType.EQUAL, "=") { }

        NodeType opType; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression equal = (Expression)base.convert();
            if (node != null)
                return node;

            if (equal is BinaryExpression) // simple comparison
                equal.NodeType = NodeType.Eq;

            if ((left_operand.type is ARRAY_TYPE) && (right_operand is NULL))
                return equal;
            else if ((left_operand is NULL) && (right_operand.type is ARRAY_TYPE))
                return equal;

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayAndArrayCall(opType, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayOrArrayCall(opType, type);
            }

            node = equal;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: long/ulong, double, bool, string, char.
            if ( val1 is bool ) { if ( (bool)val1 ) val1 = 1L; else val1 = 0L; }
            if ( val2 is bool ) { if ( (bool)val2 ) val2 = 1L; else val2 = 0L; }

            if (val1 is long || val1 is ulong) {
                long v1 = (val1 is long) ? (long)val1 : (long)(ulong)val1;
                if (val2 is long)
                    base.val = v1 == (long)val2;
                else if (val2 is ulong)
                    base.val = v1 == (long)(ulong)val2;
                else if (val2 is double)
                    base.val = (double)(float)v1 == (double)val2;
                else if (val2 is char)
                    base.val = v1 == (char)val2;
            } else if (val1 is double) {
                double v1 = (double)val1;
                if (val2 is long)
                    base.val = v1 == (double)(float)(long)val2;
                else if (val2 is ulong)
                    base.val = v1 == (double)(ulong)val2;
                else if (val2 is double)
                    base.val = v1 == (double)val2;
                else if (val2 is char)
                    base.val = v1 == (double)(float)(char)val2;
            } else if (val1 is char) {
                char v1 = (char)val1;
                if (val2 is long)
                    base.val = v1 == (long)val2;
                else if (val2 is ulong)
                    base.val = v1 == (ulong)val2;
                else if (val2 is double)
                    base.val = (double)(float)v1 == (double)val2;
                else if (val2 is char)
                    base.val = v1 == (char)val2;
            } else if (val1 is string && val2 is string) {
                base.val = (string)val1 == (string)val2;
            } else {
                ERROR.SystemErrorIn("EQUAL.calculate","illegal operand type(s)");
                return null;
            }
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((opType == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            if ((left_operand is NULL) || (right_operand is NULL))
                return base.validate();

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "=", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "=", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "=", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, "=", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
            }

            if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                TYPE type1_base = left_operand.type;
                if (type1_base is ARRAY_TYPE)
                    type1_base = ((ARRAY_TYPE)type1_base).base_type;
                TYPE type2_base = right_operand.type;
                if (type2_base is ARRAY_TYPE)
                    type2_base = ((ARRAY_TYPE)type2_base).base_type;

                if (!(((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE)))
                    &&
                    (!CONTEXT.firstPass)) {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                    if (op == null) {
                        ERROR.IllegalTypeForBinOperator(this.sourceContext, "=",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false; //this operation was not declared
                    }
                    if (!(op.return_type is BOOLEAN_TYPE)) {
                        ERROR.IncorrectRetTypeForGenComparison(this.sourceContext, "=",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false;
                    }
                }

                return true;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (!CONTEXT.firstPass) {
                    NODE call = null;
                    call = base.resolveOperator();

                    if (call is CALL) {
                        this.call = (CALL)call;
                        opType = NodeType.MethodCall;
                        return call.type;
                    }
                }

                if ((left_operand is NULL) || (right_operand is NULL)) {
                    opType = NodeType.Eq;
                    return new BOOLEAN_TYPE();
                }

                if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                    TYPE type1_base = type1;
                    if (type1 is ARRAY_TYPE)
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    TYPE type2_base = right_operand.type;
                    if (type2 is ARRAY_TYPE)
                        type2_base = ((ARRAY_TYPE)type2).base_type;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opType = NodeType.Eq;
                        return new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        if (op.return_type is BOOLEAN_TYPE) {
                            opType = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            return op.return_type;
                        } else //we can implement this generalized operation only if the result type is BOOLEAN
                        {
                            return null;
                        }
                    }

                    return null;
                }

                opType = NodeType.Eq;
                return base.type;
            }
            set { internal_type = value; }
        }

        //-------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("EQUAL =; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }


    // NON_EQUAL
    // =========
    //
    public sealed class NON_EQUAL : RELATION {
        // Constructor
        public NON_EQUAL ( ) : base(ASTNodeType.NON_EQUAL, "#") { }

        NodeType opType; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression non_equal = (Expression)base.convert();
            if (node != null)
                return node;

            if (non_equal is BinaryExpression) // simple comparison
                non_equal.NodeType = NodeType.Ne;

            if ((left_operand.type is ARRAY_TYPE) && (right_operand is NULL))
                return non_equal;
            else if ((left_operand is NULL) && (right_operand.type is ARRAY_TYPE))
                return non_equal;

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayAndArrayCall(opType, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayOrArrayCall(opType, type);
            }

            node = non_equal;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: long/ulong, double, bool, string, char.
            if ( val1 is bool ) { if ( (bool)val1 ) val1 = 1L; else val1 = 0L; }
            if ( val2 is bool ) { if ( (bool)val2 ) val2 = 1L; else val2 = 0L; }

            if (val1 is long || val1 is ulong) {
                long v1 = (val1 is long) ? (long)val1 : (long)(ulong)val1;
                if (val2 is long)
                    base.val = v1 != (long)val2;
                else if (val2 is ulong)
                    base.val = v1 != (long)(ulong)val2;
                else if (val2 is double)
                    base.val = (double)(float)v1 != (double)val2;
                else if (val2 is char)
                    base.val = v1 != (char)val2;
            } else if (val1 is double) {
                double v1 = (double)val1;
                if (val2 is long)
                    base.val = v1 != (double)(float)(long)val2;
                else if (val2 is ulong)
                    base.val = v1 != (double)(ulong)val2;
                else if (val2 is double)
                    base.val = v1 != (double)val2;
                else if (val2 is char)
                    base.val = v1 != (double)(float)(char)val2;
            } else if (val1 is char) {
                char v1 = (char)val1;
                if (val2 is long)
                    base.val = v1 != (long)val2;
                else if (val2 is ulong)
                    base.val = v1 != (ulong)val2;
                else if (val2 is double)
                    base.val = (double)(float)v1 != (double)val2;
                else if (val2 is char)
                    base.val = v1 != (char)val2;
            } else if (val1 is string && val2 is string) {
                base.val = (string)val1 != (string)val2;
            } else {
                ERROR.SystemErrorIn("NON_EQUAL.calculate","illegal operand type(s)");
                return null;
            }
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((opType == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            if ((left_operand is NULL) || (right_operand is NULL))
                return base.validate();

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "#", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "#", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "#", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, "#", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
            }

            if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                TYPE type1_base = left_operand.type;
                if (type1_base is ARRAY_TYPE)
                    type1_base = ((ARRAY_TYPE)type1_base).base_type;
                TYPE type2_base = right_operand.type;
                if (type2_base is ARRAY_TYPE)
                    type2_base = ((ARRAY_TYPE)type2_base).base_type;

                if (!(((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE)))
                    &&
                    (!CONTEXT.firstPass)) {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                    if (op == null) {
                        ERROR.IllegalTypeForBinOperator(this.sourceContext, "#",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false; //this operation was not declared
                    }
                    if (!(op.return_type is BOOLEAN_TYPE)) {
                        ERROR.IncorrectRetTypeForGenComparison(this.sourceContext, "#",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false;
                    }
                }

                return true;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (!CONTEXT.firstPass) {
                    NODE call = null;
                    call = base.resolveOperator();

                    if (call is CALL) {
                        this.call = (CALL)call;
                        opType = NodeType.MethodCall;
                        return call.type;
                    }
                }

                if ((left_operand is NULL) || (right_operand is NULL)) {
                    opType = NodeType.Ne;
                    return new BOOLEAN_TYPE();
                }
                
                if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                    TYPE type1_base = type1;
                    if (type1 is ARRAY_TYPE)
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    TYPE type2_base = right_operand.type;
                    if (type2 is ARRAY_TYPE)
                        type2_base = ((ARRAY_TYPE)type2).base_type;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opType = NodeType.Ne;
                        return new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        if (op.return_type is BOOLEAN_TYPE) {
                            opType = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            return op.return_type;
                        } else //we can implement this generalized operation only if the result type is BOOLEAN
                        {
                            return null;
                        }
                    }

                    return null;
                }

                opType = NodeType.Ne;
                return base.type;
            }
            set { internal_type = value; }
        }


        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("NON EQUAL #; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }


    // LESS
    // ====
    //
    public sealed class LESS : RELATION {
        // Constructor
        public LESS ( ) : base(ASTNodeType.LESS, "<") { }

        NodeType opType; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression less = (Expression)base.convert();
            if (node != null)
                return node;

            if ( less is BinaryExpression ) // simple comparison
                less.NodeType = NodeType.Lt;

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayAndArrayCall(opType, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayOrArrayCall(opType, type);
            }

            node = less;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: long/ulong, double, string, char.
            if (val1 is long || val1 is ulong) {
                long v1 = (val1 is long) ? (long)val1 : (long)(ulong)val1;
                if (val2 is long)
                    base.val = v1 < (long)val2;
                else if (val2 is ulong)
                    base.val = v1 < (long)(ulong)val2;
                else if (val2 is double)
                    base.val = (double)v1 < (double)val2;
                else if (val2 is char)
                    base.val = v1 < (char)val2;
            } else if (val1 is double) {
                double v1 = (double)val1;
                if (val2 is long)
                    base.val = v1 < (double)(long)val2;
                else if (val2 is ulong)
                    base.val = v1 < (double)(ulong)val2;
                else if (val2 is double)
                    base.val = v1 < (double)val2;
                else if (val2 is char)
                    base.val = v1 < (double)(char)val2;
            } else if (val1 is char) {
                char v1 = (char)val1;
                if (val2 is long)
                    base.val = v1 < (long)val2;
                else if (val2 is ulong)
                    base.val = v1 < (ulong)val2;
                else if (val2 is double)
                    base.val = (double)v1 < (double)val2;
                else if (val2 is char)
                    base.val = v1 < (char)val2;
            } else if (val1 is string && val2 is string) {
                base.val = String.Compare((string)val1,(string)val2)<0;
            } else {
                ERROR.SystemErrorIn("LESS.calculate","illegal operand type(s)");
                return null;
            }
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((opType == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "<", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "<", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "<", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, "<", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
            }

            if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                TYPE type1_base = left_operand.type;
                if (type1_base is ARRAY_TYPE)
                    type1_base = ((ARRAY_TYPE)type1_base).base_type;
                TYPE type2_base = right_operand.type;
                if (type2_base is ARRAY_TYPE)
                    type2_base = ((ARRAY_TYPE)type2_base).base_type;

                if (!(((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) 
                    && 
                    (!CONTEXT.firstPass)) {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                    if (op == null) {
                        ERROR.IllegalTypeForBinOperator(this.sourceContext, "<",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false; //this operation was not declared
                    }
                    if (!(op.return_type is BOOLEAN_TYPE)) {
                        ERROR.IncorrectRetTypeForGenComparison(this.sourceContext, "<",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false;
                    }
                }

                return true;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (!CONTEXT.firstPass) {
                    NODE call = null;
                    call = base.resolveOperator();

                    if (call is CALL) {
                        this.call = (CALL)call;
                        opType = NodeType.MethodCall;
                        return call.type;
                    }
                }

                if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                    TYPE type1_base = type1;
                    if (type1 is ARRAY_TYPE)
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    TYPE type2_base = right_operand.type;
                    if (type2 is ARRAY_TYPE)
                        type2_base = ((ARRAY_TYPE)type2).base_type;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opType = NodeType.Lt;
                        return new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        if (op.return_type is BOOLEAN_TYPE) {
                            opType = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            return op.return_type;
                        } else //we can implement this generalized operation only if the result type is BOOLEAN
                        {
                            return null;
                        }
                    }
                    
                    return null;
                }

                opType = NodeType.Lt;
                return base.type;
            }
            set { internal_type = value; }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("LESS <; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // LESS_EQUAL
    // ==========
    //
    public sealed class LESS_EQUAL : RELATION {
        // Constructor
        public LESS_EQUAL ( ) : base(ASTNodeType.LESS_EQUAL, "<=") { }

        NodeType opType; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression less_equal = (Expression)base.convert();
            if (node != null)
                return node;

            if ( less_equal is BinaryExpression ) // simple comparison
                less_equal.NodeType = NodeType.Le;

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayAndArrayCall(opType, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayOrArrayCall(opType, type);
            }

            node = less_equal;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: long/ulong, double, string, char.
            if (val1 is long || val1 is ulong) {
                long v1 = (val1 is long) ? (long)val1 : (long)(ulong)val1;
                if (val2 is long)
                    base.val = v1 <= (long)val2;
                else if (val2 is ulong)
                    base.val = v1 <= (long)(ulong)val2;
                else if (val2 is double)
                    base.val = (double)v1 <= (double)val2;
                else if (val2 is char)
                    base.val = v1 <= (char)val2;
            } else if (val1 is double) {
                double v1 = (double)val1;
                if (val2 is long)
                    base.val = v1 <= (double)(long)val2;
                else if (val2 is ulong)
                    base.val = v1 <= (double)(ulong)val2;
                else if (val2 is double)
                    base.val = v1 <= (double)val2;
                else if (val2 is char)
                    base.val = v1 <= (double)(char)val2;
            } else if (val1 is char) {
                char v1 = (char)val1;
                if (val2 is long)
                    base.val = v1 <= (long)val2;
                else if (val2 is ulong)
                    base.val = v1 <= (ulong)val2;
                else if (val2 is double)
                    base.val = (double)v1 <= (double)val2;
                else if (val2 is char)
                    base.val = v1 <= (char)val2;
            } else if (val1 is string && val2 is string) {
                base.val = String.Compare((string)val1,(string)val2)<=0;
            } else {
                ERROR.SystemErrorIn("LESS_EQUAL.calculate","illegal operand type(s)");
                return null;
            }
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((opType == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "<=", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, "<=", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, "<=", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, "<=", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
            }

            if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                TYPE type1_base = left_operand.type;
                if (type1_base is ARRAY_TYPE)
                    type1_base = ((ARRAY_TYPE)type1_base).base_type;
                TYPE type2_base = right_operand.type;
                if (type2_base is ARRAY_TYPE)
                    type2_base = ((ARRAY_TYPE)type2_base).base_type;

                if (!(((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE)))
                    &&
                    (!CONTEXT.firstPass)) {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                    if (op == null) {
                        ERROR.IllegalTypeForBinOperator(this.sourceContext, "<=",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false; //this operation was not declared
                    }
                    if (!(op.return_type is BOOLEAN_TYPE)) {
                        ERROR.IncorrectRetTypeForGenComparison(this.sourceContext, "<=",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false;
                    }
                }

                return true;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (!CONTEXT.firstPass) {
                    NODE call = null;
                    call = base.resolveOperator();

                    if (call is CALL) {
                        this.call = (CALL)call;
                        opType = NodeType.MethodCall;
                        return call.type;
                    }
                }

                if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                    TYPE type1_base = type1;
                    if (type1 is ARRAY_TYPE)
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    TYPE type2_base = right_operand.type;
                    if (type2 is ARRAY_TYPE)
                        type2_base = ((ARRAY_TYPE)type2).base_type;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opType = NodeType.Le;
                        return new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        if (op.return_type is BOOLEAN_TYPE) {
                            opType = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            return op.return_type;
                        } else //we can implement this generalized operation only if the result type is BOOLEAN
                        {
                            return null;
                        }
                    }

                    return null;
                }

                opType = NodeType.Le;
                return base.type;
            }
            set { internal_type = value; }
        }


        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("LESS EQUAL <=; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // GREATER
    // =======
    //
    public sealed class GREATER : RELATION {
        // Constructor
        public GREATER ( ) : base(ASTNodeType.GREATER, ">") { }

        NodeType opType; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression greater = (Expression)base.convert();
            if (node != null)
                return node;

            if ( greater is BinaryExpression ) // simple comparison
                greater.NodeType = NodeType.Gt;

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayAndArrayCall(opType, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayOrArrayCall(opType, type);
            }

            node = greater;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: long/ulong, double, string, char.
         // if ( val1 is bool && val2 is bool )     base.val = ( (bool)val1 && !(bool)val2 );

            if (val1 is long || val1 is ulong) {
                long v1 = (val1 is long) ? (long)val1 : (long)(ulong)val1;
                if (val2 is long)
                    base.val = v1 > (long)val2;
                else if (val2 is ulong)
                    base.val = v1 > (long)(ulong)val2;
                else if (val2 is double)
                    base.val = (double)v1 > (double)val2;
                else if (val2 is char)
                    base.val = v1 > (char)val2;
            } else if (val1 is double) {
                double v1 = (double)val1;
                if (val2 is long)
                    base.val = v1 > (double)(long)val2;
                else if (val2 is ulong)
                    base.val = v1 > (double)(ulong)val2;
                else if (val2 is double)
                    base.val = v1 > (double)val2;
                else if (val2 is char)
                    base.val = v1 > (double)(char)val2;
            } else if (val1 is char) {
                char v1 = (char)val1;
                if (val2 is long)
                    base.val = v1 > (long)val2;
                else if (val2 is ulong)
                    base.val = v1 > (ulong)val2;
                else if (val2 is double)
                    base.val = (double)v1 > (double)val2;
                else if (val2 is char)
                    base.val = v1 > (char)val2;
            } else if (val1 is string && val2 is string) {
                base.val = String.Compare((string)val1,(string)val2)>0;
            } else {
                ERROR.SystemErrorIn("GREATER.calculate","illegal operand type(s)");
                return null;
            }
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((opType == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ">", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ">", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ">", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, ">", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
            }

            if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                TYPE type1_base = left_operand.type;
                if (type1_base is ARRAY_TYPE)
                    type1_base = ((ARRAY_TYPE)type1_base).base_type;
                TYPE type2_base = right_operand.type;
                if (type2_base is ARRAY_TYPE)
                    type2_base = ((ARRAY_TYPE)type2_base).base_type;

                if (!(((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE)))
                    &&
                    (!CONTEXT.firstPass)) {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                    if (op == null) {
                        ERROR.IllegalTypeForBinOperator(this.sourceContext, ">",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false; //this operation was not declared
                    }
                    if (!(op.return_type is BOOLEAN_TYPE)) {
                        ERROR.IncorrectRetTypeForGenComparison(this.sourceContext, ">",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false;
                    }
                }

                return true;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (!CONTEXT.firstPass) {
                    NODE call = null;
                    call = base.resolveOperator();

                    if (call is CALL) {
                        this.call = (CALL)call;
                        opType = NodeType.MethodCall;
                        return call.type;
                    }
                }

                if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                    TYPE type1_base = type1;
                    if (type1 is ARRAY_TYPE)
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    TYPE type2_base = right_operand.type;
                    if (type2 is ARRAY_TYPE)
                        type2_base = ((ARRAY_TYPE)type2).base_type;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opType = NodeType.Gt;
                        return new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        if (op.return_type is BOOLEAN_TYPE) {
                            opType = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            return op.return_type;
                        } else //we can implement this generalized operation only if the result type is BOOLEAN
                        {
                            return null;
                        }
                    }

                    return null;
                }

                opType = NodeType.Gt;
                return base.type;
            }
            set { internal_type = value; }
        }


        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("GREATER >; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // GREATER_EQUAL
    // =============
    //
    public sealed class GREATER_EQUAL : RELATION {
        // Constructor
        public GREATER_EQUAL ( ) : base(ASTNodeType.GREATER_EQUAL, ">=") { }

        NodeType opType; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression greater_equal = (Expression)base.convert();
            if (node != null)
                return node;

            if ( greater_equal is BinaryExpression ) // simple comparison
                greater_equal.NodeType = NodeType.Ge;

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayAndArrayCall(opType, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetGeneralizedArrayOrArrayCall(opType, type);
            }

            node = greater_equal;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: long, double, string, char.
            if (val1 is long || val1 is ulong) {
                long v1 = (val1 is long) ? (long)val1 : (long)(ulong)val1;
                if (val2 is long)
                    base.val = v1 >= (long)val2;
                else if (val2 is ulong)
                    base.val = v1 >= (long)(ulong)val2;
                else if (val2 is double)
                    base.val = (double)v1 >= (double)val2;
                else if (val2 is char)
                    base.val = v1 >= (char)val2;
            } else if (val1 is double) {
                double v1 = (double)val1;
                if (val2 is long)
                    base.val = v1 >= (double)(long)val2;
                else if (val2 is ulong)
                    base.val = v1 >= (double)(ulong)val2;
                else if (val2 is double)
                    base.val = v1 >= (double)val2;
                else if (val2 is char)
                    base.val = v1 >= (double)(char)val2;
            } else if (val1 is char) {
                char v1 = (char)val1;
                if (val2 is long)
                    base.val = v1 >= (long)val2;
                else if (val2 is ulong)
                    base.val = v1 >= (ulong)val2;
                else if (val2 is double)
                    base.val = (double)v1 >= (double)val2;
                else if (val2 is char)
                    base.val = v1 >= (char)val2;
            } else if (val1 is string && val2 is string) {
                base.val = String.Compare((string)val1,(string)val2)>=0;
            } else {
                ERROR.SystemErrorIn("GREATER.calculate","illegal operand type(s)");
                return null;
            }
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((opType == NodeType.MethodCall) && (ovlOp == null))
                return base.validate();

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ">=", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ">=", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ">=", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, ">=", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
            }

            if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                TYPE type1_base = left_operand.type;
                if (type1_base is ARRAY_TYPE)
                    type1_base = ((ARRAY_TYPE)type1_base).base_type;
                TYPE type2_base = right_operand.type;
                if (type2_base is ARRAY_TYPE)
                    type2_base = ((ARRAY_TYPE)type2_base).base_type;

                if (!(((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE)))
                    &&
                    (!CONTEXT.firstPass)) {
                    OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                    if (op == null) {
                        ERROR.IllegalTypeForBinOperator(this.sourceContext, ">=",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false; //this operation was not declared
                    }
                    if (!(op.return_type is BOOLEAN_TYPE)) {
                        ERROR.IncorrectRetTypeForGenComparison(this.sourceContext, ">=",
                            left_operand.type.ToString(), right_operand.type.ToString());
                        ErrorReported = true;
                        return false;
                    }
                }

                return true;
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (!CONTEXT.firstPass) {
                    NODE call = null;
                    call = base.resolveOperator();

                    if (call is CALL) {
                        this.call = (CALL)call;
                        opType = NodeType.MethodCall;
                        return call.type;
                    }
                }

                if ((left_operand.type is ARRAY_TYPE) || (right_operand.type is ARRAY_TYPE)) {
                    TYPE type1_base = type1;
                    if (type1 is ARRAY_TYPE)
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    TYPE type2_base = right_operand.type;
                    if (type2 is ARRAY_TYPE)
                        type2_base = ((ARRAY_TYPE)type2).base_type;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opType = NodeType.Ge;
                        return new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        OPERATOR_DECL op = base.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        if (op.return_type is BOOLEAN_TYPE) {
                            opType = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            return op.return_type;
                        } else //we can implement this generalized operation only if the result type is BOOLEAN
                        {
                            return null;
                        }
                    }

                    return null;
                }

                opType = NodeType.Ge;
                return base.type;
            }
            set { internal_type = value; }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("GREATER EQUAL >=; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // EQUAL_ELEMENTWISE
    // =====
    //
    public sealed class EQUAL_ELEMENTWISE : RELATION {
        // Constructor
        public EQUAL_ELEMENTWISE() : base(ASTNodeType.EQUAL_ELEMENTWISE, ".=") { }

        NodeType opEqEW; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression equal = (Expression)base.convert();
            if (node != null)
                return node;

            if (equal is BinaryExpression) // simple comparison
                equal.NodeType = NodeType.Eq;

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opEqEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opEqEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opEqEW, type);
            }

            node = equal;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".=", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".=", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".=", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, ".=", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".=", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE)) 
                    return internal_type;
                
                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[rank_left];

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            for (int i = 0; i < rank_left; i++) {
                                if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                    return null;
                                else
                                    res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                                res.isOpen = false;
                            }
                        }

                        res.dimensions = new EXPRESSION_LIST(rank_left);
                        res.dimensions.Length = rank_left;

                        TYPE type1_base = ((ARRAY_TYPE)type1).base_type;
                        TYPE type2_base = ((ARRAY_TYPE)type2).base_type;

                        if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                            ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                            opEqEW = NodeType.Eq;
                            res.base_type = new BOOLEAN_TYPE();
                        } else if (!CONTEXT.firstPass) {
                            EQUAL eq = new EQUAL();
                            eq.left_operand = left_operand;
                            eq.right_operand = right_operand;
                            OPERATOR_DECL op = eq.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            if (op == null)
                                return null; //this operation was not declared
                            opEqEW = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            res.base_type = op.return_type;
                        } else
                            return null;

                        return res;
                    }
                }

                if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                    res.const_dimensions = new int[rank_left];
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;
                    opEqEW = NodeType.Eq;
                    res.base_type = new BOOLEAN_TYPE();

                    return res;
                }

                if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                    int arrayRank = 0;

                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;

                    TYPE type1_base = type1;
                    TYPE type2_base = type2;

                    if (type1 is ARRAY_TYPE) {
                        arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    } else {
                        arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type2_base = ((ARRAY_TYPE)type2).base_type;
                    }

                    res.dimensions = new EXPRESSION_LIST(arrayRank);
                    res.dimensions.Length = arrayRank;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                            ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opEqEW = NodeType.Eq;
                        res.base_type = new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        EQUAL eq = new EQUAL();
                        eq.left_operand = left_operand;
                        eq.right_operand = right_operand;
                        OPERATOR_DECL op = eq.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        opEqEW = NodeType.MethodCall;
                        ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                        res.base_type = op.return_type;
                    } else
                        return null;

                    return res;
                }

                return base.type;
            }
            set { internal_type = value; } 
        }

        //-------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("EQUAL_ELEMENTWISE .=; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    // NON_EQUAL_ELEMENTWISE
    // =========
    //
    public sealed class NON_EQUAL_ELEMENTWISE : RELATION {
        // Constructor
        public NON_EQUAL_ELEMENTWISE() : base(ASTNodeType.NON_EQUAL_ELEMENTWISE, ".#") { }

        NodeType opNonEqEW; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression nonequal = (Expression)base.convert();
            if (node != null)
                return node;

            if (nonequal is BinaryExpression) // simple comparison
                nonequal.NodeType = NodeType.Ne;

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opNonEqEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opNonEqEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opNonEqEW, type);
            }

            node = nonequal;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".#", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".#", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".#", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, ".#", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".#", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[rank_left];

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            for (int i = 0; i < rank_left; i++) {
                                if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                    return null;
                                else
                                    res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                                res.isOpen = false;
                            }
                        }

                        res.dimensions = new EXPRESSION_LIST(rank_left);
                        res.dimensions.Length = rank_left;

                        TYPE type1_base = ((ARRAY_TYPE)type1).base_type;
                        TYPE type2_base = ((ARRAY_TYPE)type2).base_type;

                        if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                            ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                            opNonEqEW = NodeType.Ne;
                            res.base_type = new BOOLEAN_TYPE();
                        } else if (!CONTEXT.firstPass) {
                            NON_EQUAL non_eq = new NON_EQUAL();
                            non_eq.left_operand = left_operand;
                            non_eq.right_operand = right_operand;
                            OPERATOR_DECL op = non_eq.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            if (op == null)
                                return null; //this operation was not declared
                            opNonEqEW = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            res.base_type = op.return_type;
                        } else
                            return null;

                        return res;
                    }
                }

                if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                    res.const_dimensions = new int[rank_left];
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;
                    opNonEqEW = NodeType.Ne;
                    res.base_type = new BOOLEAN_TYPE();

                    return res;
                }

                if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                    int arrayRank = 0;

                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;

                    TYPE type1_base = type1;
                    TYPE type2_base = type2;

                    if (type1 is ARRAY_TYPE) {
                        arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    } else {
                        arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type2_base = ((ARRAY_TYPE)type2).base_type;
                    }

                    res.dimensions = new EXPRESSION_LIST(arrayRank);
                    res.dimensions.Length = arrayRank;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                            ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opNonEqEW = NodeType.Ne;
                        res.base_type = new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        NON_EQUAL non_eq = new NON_EQUAL();
                        non_eq.left_operand = left_operand;
                        non_eq.right_operand = right_operand;
                        OPERATOR_DECL op = non_eq.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        opNonEqEW = NodeType.MethodCall;
                        ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                        res.base_type = op.return_type;
                    } else
                        return null;

                    return res;
                }

                return base.type;
            }
            set { internal_type = value; }
        }


        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("NON EQUAL_ELEMENTWISE .#; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    // LESS_ELEMENTWISE
    // ====
    //
    public sealed class LESS_ELEMENTWISE : RELATION {
        // Constructor
        public LESS_ELEMENTWISE() : base(ASTNodeType.LESS_ELEMENTWISE, ".<") { }

        NodeType opLessEW; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression less = (Expression)base.convert();
            if (node != null)
                return node;

            if (less is BinaryExpression) // simple comparison
                less.NodeType = NodeType.Lt;

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opLessEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opLessEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opLessEW, type);
            }

            node = less;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".<", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".<", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".<", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, ".<", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".<", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[rank_left];

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            for (int i = 0; i < rank_left; i++) {
                                if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                    return null;
                                else
                                    res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                                res.isOpen = false;
                            }
                        }

                        res.dimensions = new EXPRESSION_LIST(rank_left);
                        res.dimensions.Length = rank_left;

                        TYPE type1_base = ((ARRAY_TYPE)type1).base_type;
                        TYPE type2_base = ((ARRAY_TYPE)type2).base_type;

                        if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                            ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                            opLessEW = NodeType.Lt;
                            res.base_type = new BOOLEAN_TYPE();
                        } else if (!CONTEXT.firstPass) {
                            LESS less = new LESS();
                            less.left_operand = left_operand;
                            less.right_operand = right_operand;
                            OPERATOR_DECL op = less.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            if (op == null)
                                return null; //this operation was not declared
                            opLessEW = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            res.base_type = op.return_type;
                        } else
                            return null;

                        return res;
                    }
                }

                if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                    res.const_dimensions = new int[rank_left];
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;
                    opLessEW = NodeType.Lt;
                    res.base_type = new BOOLEAN_TYPE();

                    return res;
                }

                if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                    int arrayRank = 0;

                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;

                    TYPE type1_base = type1;
                    TYPE type2_base = type2;

                    if (type1 is ARRAY_TYPE) {
                        arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    } else {
                        arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type2_base = ((ARRAY_TYPE)type2).base_type;
                    }

                    res.dimensions = new EXPRESSION_LIST(arrayRank);
                    res.dimensions.Length = arrayRank;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opLessEW = NodeType.Lt;
                        res.base_type = new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        LESS less = new LESS();
                        less.left_operand = left_operand;
                        less.right_operand = right_operand;
                        OPERATOR_DECL op = less.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        opLessEW = NodeType.MethodCall;
                        ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                        res.base_type = op.return_type;
                    } else
                        return null;

                    return res;
                }

                return base.type;
            }
            set { internal_type = value; }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("LESS_ELEMENTWISE .<; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    // LESS_EQUAL_ELEMENTWISE
    // ==========
    //
    public sealed class LESS_EQUAL_ELEMENTWISE : RELATION {
        // Constructor
        public LESS_EQUAL_ELEMENTWISE() : base(ASTNodeType.LESS_EQUAL_ELEMENTWISE, ".<=") { }

        NodeType opLessEqEW; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression less_equal = (Expression)base.convert();
            if (node != null)
                return node;

            if (less_equal is BinaryExpression) // simple comparison
                less_equal.NodeType = NodeType.Le;

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opLessEqEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opLessEqEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opLessEqEW, type);
            }

            node = less_equal;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".<=", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".<=", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".<=", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, ".<=", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".<=", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[rank_left];

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            for (int i = 0; i < rank_left; i++) {
                                if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                    return null;
                                else
                                    res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                                res.isOpen = false;
                            }
                        }

                        res.dimensions = new EXPRESSION_LIST(rank_left);
                        res.dimensions.Length = rank_left;

                        TYPE type1_base = ((ARRAY_TYPE)type1).base_type;
                        TYPE type2_base = ((ARRAY_TYPE)type2).base_type;

                        if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                            ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                            opLessEqEW = NodeType.Le;
                            res.base_type = new BOOLEAN_TYPE();
                        } else if (!CONTEXT.firstPass) {
                            LESS_EQUAL less_eq = new LESS_EQUAL();
                            less_eq.left_operand = left_operand;
                            less_eq.right_operand = right_operand;
                            OPERATOR_DECL op = less_eq.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            if (op == null)
                                return null; //this operation was not declared
                            opLessEqEW = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            res.base_type = op.return_type;
                        } else
                            return null;

                        return res;
                    }
                }

                if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                    res.const_dimensions = new int[rank_left];
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;
                    opLessEqEW = NodeType.Le;
                    res.base_type = new BOOLEAN_TYPE();

                    return res;
                }

                if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                    int arrayRank = 0;

                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;

                    TYPE type1_base = type1;
                    TYPE type2_base = type2;

                    if (type1 is ARRAY_TYPE) {
                        arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    } else {
                        arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type2_base = ((ARRAY_TYPE)type2).base_type;
                    }

                    res.dimensions = new EXPRESSION_LIST(arrayRank);
                    res.dimensions.Length = arrayRank;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                        ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opLessEqEW = NodeType.Le;
                        res.base_type = new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        LESS_EQUAL less_eq = new LESS_EQUAL();
                        less_eq.left_operand = left_operand;
                        less_eq.right_operand = right_operand;
                        OPERATOR_DECL op = less_eq.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        opLessEqEW = NodeType.MethodCall;
                        ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                        res.base_type = op.return_type;
                    } else
                        return null;

                    return res;
                }

                return base.type;
            }
            set { internal_type = value; }
        }


        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("LESS EQUAL_ELEMENTWISE .<=; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    // GREATER_ELEMENTWISE
    // =======
    //
    public sealed class GREATER_ELEMENTWISE : RELATION {
        // Constructor
        public GREATER_ELEMENTWISE() : base(ASTNodeType.GREATER_ELEMENTWISE, ".>") { }

        NodeType opGreaterEW; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression greater = (Expression)base.convert();
            if (node != null)
                return node;

            if (greater is BinaryExpression) // simple comparison
                greater.NodeType = NodeType.Gt;

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opGreaterEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opGreaterEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opGreaterEW, type);
            }

            node = greater;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".>", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".>", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".>", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, ".>", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".>", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[rank_left];

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            for (int i = 0; i < rank_left; i++) {
                                if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                    return null;
                                else
                                    res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                                res.isOpen = false;
                            }
                        }

                        res.dimensions = new EXPRESSION_LIST(rank_left);
                        res.dimensions.Length = rank_left;

                        TYPE type1_base = ((ARRAY_TYPE)type1).base_type;
                        TYPE type2_base = ((ARRAY_TYPE)type2).base_type;

                        if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                            ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                            opGreaterEW = NodeType.Gt;
                            res.base_type = new BOOLEAN_TYPE();
                        } else if (!CONTEXT.firstPass) {
                            GREATER greater = new GREATER();
                            greater.left_operand = left_operand;
                            greater.right_operand = right_operand;
                            OPERATOR_DECL op = greater.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            if (op == null)
                                return null; //this operation was not declared
                            opGreaterEW = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            res.base_type = op.return_type;
                        } else
                            return null;

                        return res;
                    }
                }

                if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                    res.const_dimensions = new int[rank_left];
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;
                    opGreaterEW = NodeType.Gt;
                    res.base_type = new BOOLEAN_TYPE();

                    return res;
                }

                if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                    int arrayRank = 0;

                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;

                    TYPE type1_base = type1;
                    TYPE type2_base = type2;

                    if (type1 is ARRAY_TYPE) {
                        arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    } else {
                        arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type2_base = ((ARRAY_TYPE)type2).base_type;
                    }

                    res.dimensions = new EXPRESSION_LIST(arrayRank);
                    res.dimensions.Length = arrayRank;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                            ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opGreaterEW = NodeType.Gt;
                        res.base_type = new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        GREATER greater = new GREATER();
                        greater.left_operand = left_operand;
                        greater.right_operand = right_operand;
                        OPERATOR_DECL op = greater.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        opGreaterEW = NodeType.MethodCall;
                        ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                        res.base_type = op.return_type;
                    } else
                        return null;

                    return res;
                }

                return base.type;
            }
            set { internal_type = value; }
        }


        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("GREATER_ELEMENTWISE .>; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    // GREATER_EQUAL_ELEMENTWISE
    // =============
    //
    public sealed class GREATER_EQUAL_ELEMENTWISE : RELATION {
        // Constructor
        public GREATER_EQUAL_ELEMENTWISE() : base(ASTNodeType.GREATER_EQUAL_ELEMENTWISE, ".>=") { }

        NodeType opGreaterEqEW; //operation for IsMath operations with arrays

        //----------------------------------------------------------------------------

        public override Node convert()  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            Expression greater_equal = (Expression)base.convert();
            if (node != null)
                return node;

            if (greater_equal is BinaryExpression) // simple comparison
                greater_equal.NodeType = NodeType.Ge;

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                return GetElemWiseSparseAndSparseCall(opGreaterEqEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayAndArrayCall(opGreaterEqEW, type);
            }

            if ((left_operand.type is ARRAY_TYPE) ^ (right_operand.type is ARRAY_TYPE)) {
                return GetElemWiseArrayOrArrayCall(opGreaterEqEW, type);
            }

            node = greater_equal;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate()   // Calculates constant expressions
        {
            return base.val;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            // Check type??!!!

            if (left_operand == null)
                return false;
            if (left_operand.type == null)
                return false;

            if (!left_operand.validate() || !right_operand.validate()) {
                return false;  // A message must be issued before
            }

            if ((left_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)left_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".>=", left_operand.type.ToString());
                ErrorReported = true;
                return false;
            }
            if ((right_operand.type is ARRAY_TYPE) && !(((ARRAY_TYPE)right_operand.type).isMath)) {
                ERROR.ArrayNotMath(this.sourceContext, ".>=", right_operand.type.ToString());
                ErrorReported = true;
                return false;
            }

            if ((left_operand.type is ARRAY_TYPE) && (right_operand.type is ARRAY_TYPE)) {
                int rank_left = ((ARRAY_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((ARRAY_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".>=", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                } else {
                    if ((((ARRAY_TYPE)left_operand.type).const_dimensions[0] != 0)
                        &&
                        (((ARRAY_TYPE)right_operand.type).const_dimensions[0] != 0)) {
                        //arrays are both static; lengths can be checked now (they have to be equal)
                        for (int i = 0; i < rank_left; i++) {
                            if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                ((ARRAY_TYPE)right_operand.type).const_dimensions[i]) {
                                ERROR.IncompatibleSizes(this.sourceContext, ".>=", left_operand.type.ToString(), right_operand.type.ToString());
                                ErrorReported = true;
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            if ((left_operand.type is SPARSE_TYPE) && (right_operand.type is SPARSE_TYPE)) {
                int rank_left = ((SPARSE_TYPE)left_operand.type).dimensions.Length;
                int rank_right = ((SPARSE_TYPE)right_operand.type).dimensions.Length;
                if ((rank_left != rank_right) || (rank_left <= 0) || (rank_right <= 0)) {
                    ERROR.RanksNotEqual(this.sourceContext, ".>=", left_operand.type.ToString(), right_operand.type.ToString());
                    ErrorReported = true;
                    return false;
                }
            }

            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null && !(internal_type is ANY_TYPE))
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                if (type1 is ARRAY_TYPE && type2 is ARRAY_TYPE) {
                    int rank_left = ((ARRAY_TYPE)type1).dimensions.Length;
                    int rank_right = ((ARRAY_TYPE)type2).dimensions.Length;

                    if (rank_left != rank_right) { return null; } else {
                        ARRAY_TYPE res = new ARRAY_TYPE();
                        res.isMath = true;
                        res.isOpen = true;
                        res.const_dimensions = new int[rank_left];

                        if ((((ARRAY_TYPE)type1).const_dimensions[0] != 0)
                            &&
                            (((ARRAY_TYPE)type2).const_dimensions[0] != 0)) {
                            //arrays are both static; lengths can be calculated now
                            for (int i = 0; i < rank_left; i++) {
                                if (((ARRAY_TYPE)left_operand.type).const_dimensions[i] !=
                                    ((ARRAY_TYPE)right_operand.type).const_dimensions[i])
                                    return null;
                                else
                                    res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                                res.isOpen = false;
                            }
                        }

                        res.dimensions = new EXPRESSION_LIST(rank_left);
                        res.dimensions.Length = rank_left;

                        TYPE type1_base = ((ARRAY_TYPE)type1).base_type;
                        TYPE type2_base = ((ARRAY_TYPE)type2).base_type;

                        if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                            ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                            opGreaterEqEW = NodeType.Ge;
                            res.base_type = new BOOLEAN_TYPE();
                        } else if (!CONTEXT.firstPass) {
                            GREATER_EQUAL greater_eq = new GREATER_EQUAL();
                            greater_eq.left_operand = left_operand;
                            greater_eq.right_operand = right_operand;
                            OPERATOR_DECL op = greater_eq.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                            if (op == null)
                                return null; //this operation was not declared
                            opGreaterEqEW = NodeType.MethodCall;
                            ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                            res.base_type = op.return_type;
                        } else
                            return null;

                        return res;
                    }
                }

                if (type1 is SPARSE_TYPE && type2 is SPARSE_TYPE) {
                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;
                    int rank_left = ((SPARSE_TYPE)type1).dimensions.Length;
                    res.const_dimensions = new int[rank_left];
                    res.dimensions = new EXPRESSION_LIST(rank_left);
                    res.dimensions.Length = rank_left;
                    opGreaterEqEW = NodeType.Ge;
                    res.base_type = new BOOLEAN_TYPE();

                    return res;
                }

                if (type1 is ARRAY_TYPE ^ type2 is ARRAY_TYPE) {
                    int arrayRank = 0;

                    ARRAY_TYPE res = new ARRAY_TYPE();
                    res.isMath = true;
                    res.isOpen = true;

                    TYPE type1_base = type1;
                    TYPE type2_base = type2;

                    if (type1 is ARRAY_TYPE) {
                        arrayRank = ((ARRAY_TYPE)type1).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type1).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type1).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type1_base = ((ARRAY_TYPE)type1).base_type;
                    } else {
                        arrayRank = ((ARRAY_TYPE)type2).dimensions.Length;
                        res.const_dimensions = new int[arrayRank];

                        if (((ARRAY_TYPE)type2).const_dimensions[0] != 0) {
                            for (int i = 0; i < arrayRank; i++) {
                                res.const_dimensions[i] = ((ARRAY_TYPE)type2).const_dimensions[i];
                            }
                            res.isOpen = false;
                        }
                        type2_base = ((ARRAY_TYPE)type2).base_type;
                    }

                    res.dimensions = new EXPRESSION_LIST(arrayRank);
                    res.dimensions.Length = arrayRank;

                    if (((type1_base is INTEGER_TYPE) || (type1_base is CARDINAL_TYPE) || (type1_base is REAL_TYPE)) &&
                            ((type2_base is INTEGER_TYPE) || (type2_base is CARDINAL_TYPE) || (type2_base is REAL_TYPE))) {
                        opGreaterEqEW = NodeType.Ge;
                        res.base_type = new BOOLEAN_TYPE();
                    } else if (!CONTEXT.firstPass) {
                        GREATER_EQUAL greater_eq = new GREATER_EQUAL();
                        greater_eq.left_operand = left_operand;
                        greater_eq.right_operand = right_operand;
                        OPERATOR_DECL op = greater_eq.findBestOpDeclForBinaryOperator(type1_base, type2_base);
                        if (op == null)
                            return null; //this operation was not declared
                        opGreaterEqEW = NodeType.MethodCall;
                        ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                        res.base_type = op.return_type;
                    } else
                        return null;

                    return res;
                }

                return base.type;
            }
            set { internal_type = value; }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("GREATER EQUAL_ELEMENTWISE .>=; TYPE={0}", type != null ? type.ToString() : "NULL");
            report_extra();
            base.report(shift + NODE.reportShift);
        }
#endif
    }

    // IN
    // ==
    //
    public sealed class IN : RELATION {
        // Constructor
        public IN ( ) : base(ASTNodeType.IN, "in") { }

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            if (call != null) {
                node = call.convert();
                return node;
            }

         // int index = ((SET_TYPE)right_operand.type).width <= 32 ? 0 : 1;

            MethodCall in_set = new MethodCall();
            in_set.Callee = new MemberBinding(null,STANDARD.Sets.GetMembersNamed(Identifier.For("in_set"))[0]);
            in_set.Callee.SourceContext = this.sourceContext;
            in_set.Operands = new ExpressionList();
            in_set.Operands.Add(new Literal((long)this.sourceContext.StartLine,SystemTypes.Int64));
            in_set.Operands.Add(new Literal(this.sourceContext.StartColumn,SystemTypes.Int32));

            Expression left  = (Expression)left_operand.convert();
            left.SourceContext = left_operand.sourceContext;
            Expression right = (Expression)right_operand.convert();
            right.SourceContext = right_operand.sourceContext;

            in_set.Operands.Add(left);
            in_set.Operands.Add(right);

            node = in_set;
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            if (base.val != null)
                return base.val;

            object val1 = base.calculateLeft();
            object val2 = base.calculateRight();

            if (val1 == null || val2 == null)
                return null;

            // Possible types: type1 is long/ulong, type2 is ulong.
            if ((val1 is long || val1 is ulong) && val2 is ulong) {
                if (val1 is long)
                    val1 = (int)(long)val1;
                else if (val1 is ulong)
                    val1 = (int)(ulong)val1;

                base.val = ((ulong)val2 & 1U<<(int)val1) != 0;
                return base.val;
            } else {
                ERROR.SystemErrorIn("in.calculate","illegal operand type(s)");
                return null;
            }
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            if (!base.validate())
                return false; // checks non-nulls and validates operands

         // What for??? - the same check is done by 'type' property!
         //
         // if ( !(left_operand.type is INTEGER_TYPE) && !(left_operand.type is CARDINAL_TYPE) )
         // {
         //     if ( !this.errorReported )
         //     {
         //         this.errorReported = true;
         //         ERROR.IllegalTypeForUnOperator(this.sourceContext,"IN",left_operand.type.ToString());
         //     }                       ==???
         //     return false;
         // }
         //
         // if ( !(right_operand.type is SET_TYPE) )
         // {
         //     if ( !this.errorReported )
         //     {
         //         this.errorReported = true;
         //         ERROR.IllegalTypeForUnOperator(this.sourceContext,"IN",right_operand.type.ToString());
         //     }                       ==??
         //     return false;
         // }
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get {
                if (internal_type != null)
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if (type1 == null || type2 == null)
                    return null;

                // Legal types for IN operands: INTEGER/CARDINAL & SET.
                // Result type for IN: BOOLEAN.
                // All other types are illegal.
                if ((type1 is INTEGER_TYPE || type1 is CARDINAL_TYPE) && type2 is SET_TYPE) {
                    internal_type = STANDARD.Boolean.type;
                } else if (!CONTEXT.firstPass) {
                    NODE call = base.resolveOperator();
                    if (call is CALL) {
                        this.call = (CALL)call;
                        internal_type = call.type;
                    }
                }

                if (internal_type == null && !CONTEXT.firstPass && !this.ErrorReported) {
                    ERROR.IllegalTypeForBinOperator(this.sourceContext,"in",type1.ToString(),type2.ToString());
                    this.ErrorReported = true;
                }
                return base.type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("IN; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // IMPLEMENTS
    // ==========
    //
    public sealed class IMPLEMENTS : RELATION {
        private bool err;

        // Constructor
        public IMPLEMENTS ( ) : base(ASTNodeType.IMPLEMENTS, null) { }

        //----------------------------------------------------------------------------

        private static bool implements(Interface bas, Interface current) {
            if (bas == current)
                return true;
            for (int i = 0; i < bas.Interfaces.Length; i++)
                if (implements(bas.Interfaces[i], current))
                    return true;
            return false;
        }

        private static bool implements(Class bas, Interface current) {
            if (bas == current)
                return true;
            if ((bas.BaseClass != null) && implements(bas.BaseClass, current))
                return true;
            for (int i = 0; i < bas.Interfaces.Length; i++)
                if (implements(bas.Interfaces[i], current))
                    return true;
            return false;
        }

        private static bool implements(Class bas, Class current) {
            if (bas == current)
                return true;
            if ((bas.BaseClass != null) && implements(bas.BaseClass, current))
                return true;
            return false;
        }

        private static bool implements(UNIT_DECL left_definition, UNIT_DECL right_definition) {
            if ( left_definition is UNKNOWN_DECL )
                left_definition = (UNIT_DECL)left_definition.resolve();
            if ( right_definition is UNKNOWN_DECL )
                right_definition = (UNIT_DECL)right_definition.resolve();

            if ( left_definition == right_definition )
                return true;

            DEFINITION_DECL left = left_definition as DEFINITION_DECL;
            if ( left != null && left.base_definition != null )
                return implements(left.base_definition,right_definition);
            else if ((left_definition is EXTERNAL_DECL) && (right_definition is EXTERNAL_DECL)) {
                Node ld = ((EXTERNAL_DECL)left_definition).entity;
                Node rd = ((EXTERNAL_DECL)right_definition).entity;

                if (ld is Interface && rd is Interface)
                    return implements((Interface)ld, (Interface)rd);
                if (ld is Class && rd is Interface)
                    return implements((Class)ld, (Interface)rd);
                if (ld is Class && rd is Class)
                    return implements((Class)ld, (Class)rd);
                return false;
            }else
                return false;
        }

        public static bool implements(UNIT_DECL_LIST defs, UNIT_DECL def) {
            for (int i = 0, n = defs.Length; i < n; i++) {
                if (implements(defs[i], def))
                    return true;
            }
            return false;
        }

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            object result = calculate();

            if ( result == null ) // generate actual code
            {
                if (err)
                    return null;

                BinaryExpression impl = new BinaryExpression();
                impl.SourceContext = this.sourceContext;
                impl.NodeType = NodeType.Is;
                impl.Operand1 = (Expression)left_operand.convert();
                impl.Operand2 = new Identifier((right_operand.resolve()).name.Name,right_operand.sourceContext);
                node = impl;
            } else  // either true or false; generate trivial code
            {
                // Warning: result of 'IMPLEMENTS' is always 'true/false'
                ERROR.CompilerCalculatedResult("IMPLEMENTS",(bool)result?"TRUE":"FALSE",this.sourceContext);
                node = new Literal(result,SystemTypes.Boolean);
            }
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            NODE left = left_operand.resolve();
            if (left is IMPORT_DECL)
                left = ((IMPORT_DECL)left).imported_unit;
            NODE right = right_operand.resolve();
            if (right is IMPORT_DECL)
                right = ((IMPORT_DECL)right).imported_unit;

            if (!(right is DEFINITION_DECL)) {
                if ( !this.ErrorReported ) 
                    ERROR.NonDefinitionInImplements(right.name.Name,this.sourceContext);
                goto ErrorCase;
            }

            UNIT_DECL_LIST defs = null;
            bool result = false;

            if (left is MODULE_DECL) {
                // For this case, the relation is resolved statically.
                defs = ((MODULE_DECL)left).definitions;
                goto DetectStatically;
            } else if (left is OBJECT_DECL) {
                defs = ((OBJECT_DECL)left).definitions;
                goto DetectStatically;
            } else if (left is IMPLEMENTATION_DECL)                                    // ???
            {                                                                          // ???
                UNIT_DECL impl = ((IMPLEMENTATION_DECL)left).implemented_definition;   // ???
                result = implements(impl,(UNIT_DECL)right);                            // ???
                return result;                                                         // ???
            }                                                                          // ???
              else if (left is VARIABLE_DECL) {
                TYPE t = ((VARIABLE_DECL)left).type;
                if (t is INTERFACE_TYPE) {
                    defs = ((INTERFACE_TYPE)t).interfaces;
                    if (defs.Length > 0) {
                        // This case is also resolved statically.
                        goto DetectStatically;
                    } else {
                        // Type of the left part of the relation is OBJECT.
                        // This is the only "dynamic" case where we cannot
                        // detect statically if the entity from the left part really
                        // implements the definition.
                        return null;
                    }
                } else if (t is OBJECT_TYPE) {
                    // Again, this is "static" case.
                    DECLARATION unit = ((OBJECT_TYPE)t).ObjectUnit;
                    defs = ((OBJECT_DECL)unit).definitions;
                    goto DetectStatically;
                } else  // Illegal type of left expression
                {
                    if (!this.ErrorReported)
                        ERROR.NonObjectTypeInImplements(this.sourceContext);
                    goto ErrorCase;
                }
            } else  // Illegal kind of left expression
            {
                if (!this.ErrorReported)
                    ERROR.IllegalEntityInImplements(this.sourceContext);
                goto ErrorCase;
            }

        DetectStatically:
            result = implements(defs,(UNIT_DECL)right);
            return result;
        ErrorCase:
            this.ErrorReported = true;
            err = true;
            return null;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            return base.validate();
            // All node-specific checks will be done in convert().
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get { if ( internal_type == null ) internal_type = STANDARD.Boolean.type; return internal_type; }
            set { }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("IMPLEMENTS; TYPE={0}; line={1}",type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

    // IS
    // ==
    //
    public sealed class IS : RELATION {
        private bool err;

        // Constructor
        public IS ( ) : base(ASTNodeType.IS, null) { }

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            if (node != null)
                return node;

            base.resolve();
            if (!validate())
                return null;

            object result = calculate();

            if ( result == null ) // generate actual code
            {
                if (err)
                    return null;

                BinaryExpression op_is = new BinaryExpression();
                op_is.NodeType = NodeType.Is; //inst;
                op_is.SourceContext = this.sourceContext;
                op_is.Operand1 = (Expression)left_operand.convert();
             // op_is.Operand2 = (TypeNode)right_operand.convert();
             // op_is.Operand2 = new Identifier((right_operand.resolve()).name.Name,right_operand.sourceContext);

                Node arg;
                NODE right = right_operand.resolve();
                if (right is PROTOCOL_DECL)
                    arg = ((PROTOCOL_DECL)right).keywords.convert();
                else
                    arg = right_operand.convert();

                op_is.Operand2 = new Literal(arg,SystemTypes.Type,right_operand.sourceContext);
                op_is.Type = SystemTypes.Boolean;
                node = op_is;
            } else  // either true or false; generate trivial code
            {
                // Warning: result of 'IS' is always 'true/false'
                ERROR.CompilerCalculatedResult("IS",(bool)result?"true":"false",this.sourceContext);
                node = new Literal(result,SystemTypes.Boolean);
            }
            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            NODE left = left_operand.resolve();
            if (left is IMPORT_DECL)
                left = ((IMPORT_DECL)left).imported_unit;
            NODE right = right_operand.resolve();
            if (right is IMPORT_DECL)
                right = ((IMPORT_DECL)right).imported_unit;

            if (right is PROTOCOL_DECL) {
                PROTOCOL_DECL proto = right as PROTOCOL_DECL;
             // right_operand = INSTANCE.create(TYPE_DECL.create(right,new MODIFIERS(),Identifier.For("Keywords"),
             //                                 (proto.keywords));
                if (proto.keywords == null) {
                    ERROR.NoProtocolKeywords(proto.name.Name,this.sourceContext);
                    this.ErrorReported = true;
                }
                return null;
            }
            if (right is DEFINITION_DECL) {
                if ( !this.ErrorReported ) 
                    ERROR.DefinitionInIs(right_operand.sourceContext,right.name.Name);
                goto ErrorCase;
            }
            if (!(right is TYPE_DECL) && !(right is OBJECT_DECL)) {
                if ( !this.ErrorReported )
                    ERROR.WrongTypeName(right_operand.sourceContext,right.name.Name);
                goto ErrorCase;
            }
         // Here 'right' is a TYPE_DECL
            TYPE right_type = (TYPE)right.type;

            if (left is VARIABLE_DECL || left is INDEXER) {
                TYPE t = left.type;

                if (t is INTERFACE_TYPE) {
                    if ( (t as INTERFACE_TYPE).interfaces.Length == 0 )
                        // This is just OBJECT';
                        // cannot resolve 'v IS T' where v is declared as OBJECT
                        return null;

                    if (!(right_type is OBJECT_TYPE))
                        return false;  // statically resolved
                 // right_type is OBJECT_TYPE

                    UNIT_DECL_LIST defs = ((INTERFACE_TYPE)t).interfaces;
                    if (defs.Length > 0) {
           /////////    if ( IMPLEMENTS.implements((defs,(UNIT_DECL)right) ) return null;
           /////////    // We will generate code for this case
           /////////
           /////////    // Otherwise the operator always returns false.
           /////////    return false;

                        return null;
                    } else {
                        // Type of the left part of the relation is 'object'.
                        // This is the only "dynamic" case where we cannot
                        // detect statically if the entity from the left part 
                        // is really of the type from the right part.
                        return null;
                    }
                } else if (t is OBJECT_TYPE) {
                    // Again, this is "static" and simple case.
                    return (OBJECT_TYPE)t == right_type;
                } else  // Illegal type of left expression
                {
                    // Left operand is not of an object type.
                    // Now we do not treat this as an error
                    // but statically check this.

                    return t==right_type;

                 // if ( !this.errorReported ) ERROR.NonObjectTypeInIs(this.sourceContext);
                 // goto ErrorCase;
                }
            }
         // else if ( left is IMPLEMENTATION_DECL )                                    // ???
         // {                                                                          // ???
         //     UNIT_DECL impl = ((IMPLEMENTATION_DECL)left).implemented_definition;   // ???
         //     result = implements(impl,(UNIT_DECL)right);                            // ???
         //     return result;                                                         // ???
         // }                                                                          // ???
            else  // Illegal kind of left expression
            {
                if (!this.ErrorReported)
                    ERROR.IllegalEntityInIs(this.sourceContext);
                goto ErrorCase;
            }

     // DetectStatically:
     //     return implements(defs,(UNIT_DECL)right);
        ErrorCase:
            this.ErrorReported = true;
            err = true;
            return null;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate() {
            if (!base.validate())
                return false;
            err = false;

            calculate();

            return !err;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type {
            get { if ( internal_type == null ) internal_type = STANDARD.Boolean.type; return internal_type; }
            set { internal_type = value; }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("IS; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            base.report(shift+NODE.reportShift);
        }
#endif
    }

/**********************************
    // USER_BINARY
    // ===========
    //
    public sealed class USER_BINARY : BINARY
    {
        // Constructor
        public USER_BINARY ( OPERATOR_DECL op ) : base() { this.op = op; }

        public OPERATOR_DECL op;

        //----------------------------------------------------------------------------

        public override Node convert ( )  // Generates corresponding CCI node.
        {
            //!!!! Should be a special algorithm!!!!!!!
            if ( node != null ) return node;

            base.resolve();
            if ( !validate() ) return null;

            return node;
        }

        //--------------------------------------------------------------------

        public override object calculate ( )   // Calculates constant expressions
        {
            //!!!!! Should be a special algorithm!!!
            return null;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )
        {
            // Make node-specific checks!!!
            return base.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type
        {
            get
            {
                if ( internal_type != null && !(internal_type is ANY_TYPE) )
                    return internal_type;

                base.extendProcTypes();
                TYPE type1 = base.evaluateLeftType();
                TYPE type2 = base.evaluateRightType();

                if ( type1 == null || type2 == null ) return null;

                internal_type = STANDARD.Boolean.type;
                return internal_type;
            }
            set
            {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report ( int shift )
        {
            report_unique(shift);
            System.Console.Write("USER_DEFINED BINARY {0}; TYPE={1}",this.name.Name,type!=null?type.ToString():"NULL");
            report_extra();
            NODE.doShift(shift+NODE.reportShift);
            op.report_short();
            System.Console.WriteLine();
            base.report(shift+NODE.reportShift);
        }
#endif
    }
******************/

    // ===========================================================================
    // 3.3 OPERANDS
    // ===========================================================================

    // DESIGNATOR
    // ==========
    //
    public abstract class DESIGNATOR : EXPRESSION {
        public DESIGNATOR ( ASTNodeType astNodeType ) : base(astNodeType, null) { properlyImported = true; }

        public bool properlyImported;

        public abstract override NODE resolve ( );
        public abstract override bool validate ( );
        public abstract override TYPE type { get; set; }
        public abstract override Node convert ( );

        public abstract string verbalize ( );

#if DEBUG
        public abstract override void report ( int shift );
#endif
    }

    // DEREFERENCE
    // ===========
    // This is a kind of "syntactic" sugar: it's a relict from
    // the Oberon language to represent operation returning
    // the value itself taking the _pointer_ to that value.
    // It is unnecessary now (because there are no pointers in the language
    // anymore) but we keep the corresponding construct in Zonnon...
    //
    // The rule is that if an object is marked as "reference" object
    // then it's possible to "dereference" instances of that object
    // by means of "^" operator.
    //
    // OBJECT {REF } o;
    //    VAR m : INTEGER;
    // END o.
    //  ...
    // VAR x : o;
    //  ...
    // x^.m := 1;   // Equivalent to x.m := 1;
    //
    public sealed class DEREFERENCE : DESIGNATOR {
        // Constructor
        public DEREFERENCE ( ) : base(ASTNodeType.DEREFERENCE) { }

        //-------------------------------------------------------------------------------------

        public DESIGNATOR pointer;

        protected override bool containsErrorReport() {
            //NG: this function was following:
            //return pointer.ErrorReported;
            //because this line could throw an exception if pointer == null, a new line ("if (pointer == null) return false;") was added.
            if (pointer == null)
                return false;
            return pointer.ErrorReported;
        }

        //-------------------------------------------------------------------------------------

        public override string verbalize ( ) { return pointer.verbalize(); }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            if (pointer == null)
                return this;
            return pointer.resolve();
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Semantical correctness for dereference operator
            // means the following:
            //
            // o  'left_part' should have an object type;
            //
            // o  this object type should be marked as {REF}.

            if (pointer == null)
                return false;
            if (!pointer.validate())
                return false;

            DECLARATION declaration = (DECLARATION)pointer.resolve();
            if (!(declaration.type is OBJECT_TYPE)) {
                ERROR.IllegalTypeOf(declaration.type.ToString(),"dereference's operand",pointer.sourceContext);
                return false;
            }
            DECLARATION decl = ((OBJECT_TYPE)declaration.type).ObjectUnit;
            OBJECT_DECL obj = (OBJECT_DECL)decl;

            if (!obj.reference) {
                ERROR.ValueObjectInDeref(declaration.type.ToString(),this.sourceContext);
                return false;
            }
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates type of dereference
        {
            // The type of the dereference is always the type of its operand.
            get {
                if (internal_type == null || internal_type is UNKNOWN_TYPE) {
                    if ( pointer != null )
                        internal_type = pointer.type;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates the constant value of dereference
        {
            // It's impossible to calculate the value for this case
            return null;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            // Here we just ignore dereferencing.
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            node = pointer.convert();

            return node;
        }


        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("DEREFERENCE; TYPE={0}; line={1}",type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("POINTER:");
            if (pointer == null)
                System.Console.WriteLine("MISSED");
            else {
                System.Console.WriteLine();
                pointer.report(shift+NODE.reportShift);
            }
        }
#endif
    }

    // INDEXER
    // =======
    // Represents all kinds of "array element" construct:
    //
    // a[10]
    // a[x+y,x-y]
    //
    public sealed class INDEXER : DESIGNATOR {
        public INDEXER ( ) : base(ASTNodeType.INDEXER) { indices = new EXPRESSION_LIST(); }

        public bool write = false; // Set to true before validation by ASSIGNMENT if is used
                            // as a left part of the assignment statement;
        public OBJECT_DECL.INDEXER_DECL calls = null; // It is overloaded
        public DESIGNATOR      left_part;
        public EXPRESSION_LIST indices;

        protected override bool containsErrorReport() {
            bool oneof = false;
            for (int i = 0; i < indices.Length; i++)
                if (indices[i] != null)
                    oneof |= indices[i].ErrorReported;
            return left_part.ErrorReported || oneof;
        }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            if(left_part != null) scope = left_part.findScopeAtContext(line, col, documentName);
            if (scope == null)
            {
                for (int i = 0; i < indices.Length; i++)
                {
                    if (indices[i] == null) continue;
                    scope = indices[i].findScopeAtContext(line, col, documentName);
                    if (scope != null) break;
                }
            }
            return scope;
        }

        //-------------------------------------------------------------------------------------

        public override string verbalize ( ) { return left_part.verbalize() + "[]"; }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            if (left_part == null)
                return this;

            NODE res = left_part.resolve();
            for ( int i=0, n=indices.Length; i<n; i++ )
                if (indices[i] != null)
                    indices[i].resolve();

            // Transform [][] into [,] if the array is multidimensional
            // Transform [,] into [][] if the array is jagged
            if (left_part is INDEXER) {
                ((INDEXER)left_part).attemptMerge(this);
            }
            attemptSplit();
            return this;
        }

        /// <summary>
        /// Checks if this index needs to be merged with the parent index. If yed then performes the merge.
        /// </summary>
        private void attemptMerge(INDEXER parent){
            // Check recursively
            if (left_part is INDEXER)
            {
                ((INDEXER)left_part).attemptMerge(this);
            }
            if (left_part.type is ARRAY_TYPE)
            {
                ARRAY_TYPE arrType = (ARRAY_TYPE)(left_part.type);
                int rank = arrType.dimensions.Length;
                if (rank > indices.Length)
                {  // Merge
                    parent.left_part = this.left_part;
                    for (int i = 0; i < parent.indices.Length; i++)
                        this.indices.Add(parent.indices[i]);
                    parent.indices = this.indices;
                    this.indices = null;                    
                }                
            }
        }

        /// <summary>
        /// Checks if the current index should be splitted into signle indexes
        /// </summary>
        private void attemptSplit() {
            // Check recursively
            if (left_part is INDEXER)
            {
                ((INDEXER)left_part).attemptSplit();
            }
            if (left_part.type is ARRAY_TYPE)
            {
                ARRAY_TYPE arrType = (ARRAY_TYPE)(left_part.type);
                int rank = arrType.dimensions.Length;
                if (rank < indices.Length)
                {  // Split
                    INDEXER newIndex = new INDEXER();
                    newIndex.indices = new EXPRESSION_LIST(this.indices.Length - rank);
                    for (int i = 0; i < rank; i++){
                        newIndex.indices.Add(this.indices[i]);
                    }
                    EXPRESSION_LIST newIndexesForThis = new EXPRESSION_LIST(rank);                    
                    for (int i = rank; i < this.indices.Length; i++)                        
                    {
                        newIndexesForThis.Add(this.indices[i]);
                    }
                    this.indices = newIndexesForThis;
                    newIndex.left_part = this.left_part;
                    this.left_part = newIndex;
                    this.attemptSplit(); // Check again
                }
            }
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Semantical correctness for indexers means the following:
            //
            // o  'left_part' is of an array or string type;
            //
            // o  the number of dimensions of that array type equals
            //    to the amount of 'indices'.
            //
            if (left_part == null)
                return false;
            if (left_part.type == null)
                return false;

            if (!left_part.validate()) {
                return false;  // A message must be issued before
            }

            if (left_part.type is ARRAY_TYPE) {
                ARRAY_TYPE arrType = (ARRAY_TYPE)(left_part.type);
                int rank = arrType.dimensions.Length;
                if (rank != indices.Length) {
                    ERROR.WrongIndicesNumber(left_part.sourceContext);
                    return false;
                }
                for (int i = 0, n = rank; i < n; i++) {
                    if (indices[i] == null)
                        return false;
                    if (!indices[i].validate())
                        return false;
                }
                if (!arrType.isMath) {
                    for (int i = 0; i < rank; i++) {
                        if (indices[i].type is RANGE_TYPE) {
                            ERROR.WrongIndexTypeMathMaybe(sourceContext, indices[i].type.ToString(), left_part.type.ToString());
                            ErrorReported = true;
                            return false;
                        }
                        if (indices[i].type is ARRAY_TYPE) {
                            ERROR.WrongIndexTypeMathMaybe(sourceContext, indices[i].type.ToString(), left_part.type.ToString());
                            ErrorReported = true;
                            return false;
                        }
                    }
                } else {
                    for (int i = 0; i < rank; i++) {
                        if ((indices[i].type is ARRAY_TYPE) &&
                            !(((ARRAY_TYPE)(indices[i].type)).base_type is INTEGER_TYPE) &&
                            !(((ARRAY_TYPE)(indices[i].type)).base_type is CARDINAL_TYPE) &&
                            !(((ARRAY_TYPE)(indices[i].type)).base_type is BOOLEAN_TYPE)) {
                            ERROR.WrongIndexType(sourceContext, indices[i].type.ToString(), left_part.type.ToString());
                            ErrorReported = true;
                            return false;
                        }
                    }
                }
                return true;
            } else if (left_part.type is SPARSE_TYPE) {
                SPARSE_TYPE sparseType = (SPARSE_TYPE)(left_part.type);
                int rank = sparseType.dimensions.Length;
                if (rank != indices.Length) {
                    ERROR.WrongIndicesNumber(left_part.sourceContext);
                    return false;
            }
                for (int i = 0, n = rank; i < n; i++) {
                    if (indices[i] == null)
                        return false;
                    if (!indices[i].validate())
                        return false;

                    if (!(indices[i].type is INTEGER_TYPE) && !(indices[i].type is CARDINAL_TYPE)) {
                        ERROR.WrongIndexType(sourceContext, indices[i].type.ToString(), left_part.type.ToString());
                        ErrorReported = true;
                        return false;
            }
                }
                return true;
            } else if (left_part.type is STRING_TYPE) {
                return true;
            } else if (left_part.type is OBJECT_TYPE) {
                // Let's check if the object implements an indexer definition
                OBJECT_DECL obj = (left_part.type as OBJECT_TYPE).ObjectUnit as OBJECT_DECL;
                if (obj.indexer == null) {
                    ERROR.ObjectDoesNotImplementIndexer(obj.name.Name, sourceContext);
                    return false;
                }
                if (write == false && obj.indexer.Get == null) {
                    ERROR.IndexerIsWriteOnly(obj.name.Name, sourceContext);
                    return false;
                }
                if (write == true && obj.indexer.Set == null) {
                    ERROR.IndexerIsReadOnly(obj.name.Name, sourceContext);
                    return false;
                }
                calls = obj.indexer;
                return true;
            } else if (left_part.type is EXTERNAL_TYPE) {
                // Here we assume that external type really has an indexer operator.
                // Perhaps we could check it explicitly?..
                return true;
            } else {
                ERROR.WrongIndexerType(left_part.type.ToString(),left_part.sourceContext);
                return false;
            }
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates type of indexer
        {
            // For usual arrays the type of the indexer is always the same as the type
            // of array elements.
            // For IsMath arrays indices can be also ranges and vectors, 
            // and opposite to usual indices, they never change the dimension of the array
            get {
                if (left_part.type is OBJECT_TYPE) {
                    OBJECT_DECL obj = (left_part.type as OBJECT_TYPE).ObjectUnit as OBJECT_DECL;
                    calls = obj.indexer;
                    //RM: By some reason for indexer calls from objects
                    //assigned in validation.
                    // Calling validation here is not allowed as type can be request even by pareser
                }

                if (internal_type == null || internal_type is UNKNOWN_TYPE) {
                    if (left_part != null && left_part.type != null) {
                        if (left_part.type is EXTERNAL_TYPE) {
                            TypeNode ent = ((EXTERNAL_TYPE)left_part.type).entity as TypeNode;
                            if (ent == null)
                                goto other;
                            MemberList list = ent.GetMembersNamed(new Identifier("Item"));
                            if (list.Length == 0)
                                goto other;
                            Property prop = list[0] as Property;
                            if (prop == null)
                                goto other;
                            internal_type = new EXTERNAL_TYPE(prop.Type);
                            internal_type.sourceContext = sourceContext;
                         other:
                                // Try plan B
                            return internal_type;
                        } else
                            if (left_part.type is OBJECT_TYPE && calls != null && calls.Get != null) {

                            internal_type = calls.Get.return_type;
                            } else
                                if (left_part.type is OBJECT_TYPE && calls != null && calls.Set != null) {  
                                  internal_type = calls.Set.parameters[calls.Set.parameters.Length-1].type;
                                } else {
                                    left_part.type = (TYPE)left_part.type.resolve();
                                    if (left_part.type is ARRAY_TYPE) {
                                      internal_type = ((ARRAY_TYPE)(left_part.type)).base_type;
                                      if (((ARRAY_TYPE)left_part.type).isMath) {
                                        int res_rank = 0;
                                        for (int i = 0; i < indices.Length; i++) {
                                           if ((indices[i].type is RANGE_TYPE) || (indices[i].type is ARRAY_TYPE)) 
                                           res_rank++;
                                        }
                                        if (res_rank == 0)
                                          return internal_type; //there are no ranges; all the indices are usual indices
                                        ARRAY_TYPE res = new ARRAY_TYPE(); //otherwise the result type will be an array
                                        res.isMath = true;
                                        res.isOpen = true; //!!! Lengths can be calculated sometimes
                                        res.dimensions = new EXPRESSION_LIST(res_rank);
                                        res.dimensions.Length = res_rank;
                                        res.const_dimensions = new int[res_rank];
                                        res.base_type = ((ARRAY_TYPE)(left_part.type)).base_type;
                                        internal_type = res;
                                      }
                                    } else if (left_part.type is SPARSE_TYPE) //currently there are no complex indexing available for sparse_type
                                      internal_type = (left_part.type as SPARSE_TYPE).base_type;
                                    else if (left_part.type is STRING_TYPE)
                                      internal_type = STANDARD.Char.type;
                                    else if (left_part.type is UNKNOWN_TYPE)
                                   {
                                    internal_type = new UNKNOWN_TYPE(this); // Unknown type for index element
                                    internal_type.sourceContext = this.sourceContext;
                                   }
                               }
                     }
                }
                if (internal_type is UNKNOWN_TYPE)
                {
                    internal_type = internal_type.resolve() as TYPE;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates the constant value for array element
        {
            // It's impossible to calculate the value for this case
            return null;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            if (left_part.type is OBJECT_TYPE && calls != null && calls.Get != null) {
                // This is [].Get                                

                MethodCall invoke = new MethodCall();
                Node target = left_part.convert();
                Node member = calls.Get.convert();

                if (target == null || member == null)
                    return null;

                invoke.Callee = new MemberBinding(target as Expression, member as Member);
                invoke.GiveErrorIfSpecialNameMethod = false; // ??

                invoke.IsTailCall = false;

                invoke.Operands = new ExpressionList(indices.Length);
                for (int i = 0; i < indices.Length; i++)
                    invoke.Operands.Add(indices[i].convert() as Expression);
                invoke.SourceContext = this.sourceContext;
                invoke.Type = SystemTypes.Void;
              
                return invoke;
            }

            if (left_part.type is SPARSE_TYPE) //This is Get
            {
                TypeNode curType;
                SPARSE_TYPE curSparseType = left_part.type as SPARSE_TYPE;
                if (curSparseType.isVector)
                    curType = STANDARD.SparseVector.GetTemplateInstance(CONTEXT.symbolTable,
                        curSparseType.base_type.convert() as TypeNode);
                else
                    curType = STANDARD.SparseMatrix.GetTemplateInstance(CONTEXT.symbolTable,
                        curSparseType.base_type.convert() as TypeNode);
                MethodCall invoke = new MethodCall();
                if (curSparseType.isVector)
                    invoke.Callee = new MemberBinding(left_part.convert() as Expression,
                        curType.GetMembersNamed(Identifier.For("GetElem"))[0]);
                else
                    invoke.Callee = new MemberBinding(left_part.convert() as Expression,
                        curType.GetMembersNamed(Identifier.For("GetElem"))[0]);

                invoke.IsTailCall = false;

                invoke.Operands = new ExpressionList(indices.Length);
                invoke.Operands.Add(new Literal(sourceContext.StartLine, SystemTypes.Int64));
                invoke.Operands.Add(new Literal(sourceContext.StartColumn, SystemTypes.Int32));

                for (int i = 0; i < indices.Length; i++)
                    invoke.Operands.Add(indices[i].convert() as Expression);
                invoke.SourceContext = this.sourceContext;
                invoke.Type = SystemTypes.Void;

                return invoke;
            }

            Indexer indexer = new Indexer();

            if (left_part == null)
                return null;

            if (left_part.type is ARRAY_TYPE) {
                TYPE left_type = ((ARRAY_TYPE)left_part.type).base_type;
                indexer.ElementType = (TypeNode)left_type.convert();
            }
         // indexer.NodeType;
            indexer.Object = (Expression)left_part.convert();
            indexer.Operands = new ExpressionList();
            for ( int i=0, n=indices.Length; i<n; i++ )
                indexer.Operands.Add((Expression)indices[i].convert());
            indexer.SourceContext = base.sourceContext;
            if ( left_part.type != null )
                indexer.Type = (TypeNode)left_part.type.convert();

            node = indexer;
            return node;
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("INDEXER; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("LEFT PART");
            if ( left_part == null ) // An error occured before
            {
                NODE.doShift(shift+2*NODE.reportShift);
                System.Console.WriteLine("NULL");
            } else
                left_part.report(shift+NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("INDICES");

            for ( int i=0, n=indices.Length; i<n; i++ )
                if ( indices[i] != null ) 
                    indices[i].report(shift+NODE.reportShift);
        }
#endif
    }

    // SELECTOR
    // ========
    // For all kinds of "dotted" constructs which are _not_ namespaces.
    //
    // The simplest case of using SELECTOR is for the following construct:
    //
    // OBJECT o; VAR m : INTEGER; END o;
    // VAR x : o;
    //  ...
    // x.m := 1;
    //
    // But SELECTORs are also used for representing unresolved references.
    // In that case 'left_part' refers to an INSTANCE node denoting an unknown
    // unit, type etc., and 'member' refers to an INSTANCE with null reference.
    //
    // Notice also that _namespaces_ occur only in import declarations and
    // in unit names and they are represented either as a series of UNKNOWN_DECL
    // nodes (if they are not know yet) or just as NAMESPACE_DECL nodes.
    // For explanation and examples see NAMESPACE_DECL class declaration above.
    //
    public sealed class SELECTOR : DESIGNATOR {
        // Constructors
        public SELECTOR ( ) : base(ASTNodeType.SELECTOR) { }

        public SELECTOR(DESIGNATOR left_part, DECLARATION member)
            : base(ASTNodeType.SELECTOR) {
            this.properlyImported = left_part.properlyImported;            
            if (member is UNIT_DECL) {
                IMPORT_DECL imported_by = ((UNIT_DECL)member).imported_by;
                if ( imported_by != null && imported_by.enclosing == CONTEXT.current_unit )
                    this.properlyImported = true;
            }
            this.enclosing = left_part.enclosing;
            this.left_part = left_part;
            this.member = member;
        }

        // We treat selector as a pair of a 'member' (which is the rightmost
        // identifier of the dotted name) and the rest of the dotted name
        // (which in turn can be a selector).
        //
        // Notice that after node's creation both field should be always non-null.
        public DESIGNATOR  left_part;
        public DECLARATION member;

        protected override bool containsErrorReport() {
            return left_part.ErrorReported || member.ErrorReported;
        }
        //-------------------------------------------------------------------------------------

        public static SELECTOR create(DESIGNATOR qual, DECLARATION member) {
            return new SELECTOR(qual,member);
        }

        //-------------------------------------------------------------------------------------

        public override string verbalize ( ) { return left_part.verbalize() + "." + member.name.Name; }

        //-------------------------------------------------------------------------------------

        // process
        // -------
        // The function processes all kinds of language constructs including
        // ONE "dot" character. Notice that the function is only for contexts
        // where such a construct IS USED, but NOT declared. The latter case
        // is processed by UNIT_DECL.processName() function.
        //
        // Also the function accepts "marginal" case where the construct is
        // a SINGLE IDENTIFIER (here 'scope' parameter is null). In that case,
        // the function looks for the name in the current compilation context.
        //
        // The function is used in more general processQualName() which deals
        // with qualified names, and in processSimpleName() for simple identifiers.
        //
        public static DESIGNATOR process(NODE scope, Identifier member) {
            if (scope == null) {
                // If condition is true it means that we should find 'member'
                // in the _current_compilation_context_.
                DECLARATION result = null;

                scope = CONTEXT.current;
                while (scope != null) {
                    result = (DECLARATION)scope.find(member);
                    if (result != null) { 
                        INSTANCE res = INSTANCE.create(result); 
                        res.enclosing = scope;
                        return res;
                    }
                    scope = scope.enclosing;

                    // We should restrict the search by the outermost _unit_.
                    // The entities declared outside the outermost unit should
                    // be accessed only via IMPORT declaration.
                    if (scope is NAMESPACE_DECL)
                        break;
                }
                // If didn't find, try to find 'member' in STANDARD module.
                result = (DECLARATION)STANDARD.Standard.find(member);
                if ( result != null )
                    return INSTANCE.create(result);

                // Last attempt: perhaps, 'member' is the starting name
                // of an _unnamed_import_: e.g., 'a' from IMPORT a.b.c;
                // We should look through all unnamed import declarations
                // in the current unit.
                if ( CONTEXT.current_unit == null )
                    result = null;
                else
                    result = CONTEXT.current_unit.findUnnamedImport(member);
                if ( result != null )
                    return INSTANCE.create(result);

                // We didn't find 'member' in the current context,
                // so we make the following COMMON ASSUMPTION:
                //
                // - This name is to be declared somewhere in the current scope
                //   (perhaps, later).
                //
                // So, we create UNKNOWN_DECL node in the _current_scope_.

                // Determining the context for unknown entity.
                // Normally this is the current context; but in case when
                // we are parsing routine's _body_ then we should put the unknown
                // entity not to the routine's context, but to the context
                // which owns this routine.
                
                DECLARATION context = (DECLARATION)CONTEXT.current;
                if (context is ROUTINE_DECL) {
                    ROUTINE_DECL routine = context as ROUTINE_DECL;
                    if ( routine.inBody || routine.inParams )
                        context = (DECLARATION)context.enclosing;
                }
                UNKNOWN_DECL udcl = UNKNOWN_DECL.create(member, context);
                udcl.sourceContext = context.sourceContext;
                return INSTANCE.create(udcl);
            }

            // Here scope /= null
            NODE scope_decl = scope.resolve();
            if (scope is CALL && scope_decl is UNKNOWN_DECL) {
                // It can happen the resolved will give Unknown. We must know if it was a call or not
                return SELECTOR.create((CALL)scope, UNKNOWN_DECL.create(member, (UNKNOWN_DECL)scope_decl)); 
            }

            // After resolving, we can consider 'scope_decl' as an instance of a DECLARATION class,
            // ('member' is still just an identifier).

         ProcessName:

            // Analyzing all non-null cases for 'scope':
            if (scope_decl is INDEXER) {
                return SELECTOR.create((INDEXER)scope_decl, UNKNOWN_DECL.create(member, (INDEXER)scope_decl));
            }
            if ( scope_decl is UNKNOWN_DECL ) // Call case will be processed later
            {
                // We cannot find 'member' in UNKNOWN_DECL; just create another UNKNOWN_DECL
                // within this one.
                UNKNOWN_DECL external;
                NODE node = scope_decl.find(member);
                if ( (node != null) && (node != scope_decl) ) // We can find itself - find works so, but it can be bad here
                    external = (UNKNOWN_DECL)node;
                else
                    external = UNKNOWN_DECL.create(member,(UNKNOWN_DECL)scope_decl);
                return SELECTOR.create((DESIGNATOR)scope,external);
            }
            if (scope_decl is IMPORT_DECL) {
                scope_decl = ((IMPORT_DECL)scope_decl).imported_unit;
                goto ProcessName;
            }
            if ( scope_decl is UNIT_DECL     ||   // UNIT_DECL other than UNKNOWN_DECL
                 scope_decl is ACTIVITY_DECL ||
                 scope_decl is ENUM_TYPE) {
                // If there is a 'member' in a unit or enum type, then just create
                // the corresponding selector; otherwise, this is an error.
                NODE result = scope_decl.findLocal(member);
                if (result is IMPORT_DECL) result = ((IMPORT_DECL)result).imported_unit;
                if ( result == null || result is UNKNOWN_DECL)
                {
                 // result = UNKNOWN_DECL.create(member,(DECLARATION)scope_decl);
                    if (scope_decl is ENUM_TYPE)
                        result = UNKNOWN_DECL.create(member, scope_decl.enclosing as DECLARATION);
                    else
                        result = UNKNOWN_DECL.create(member,scope_decl as DECLARATION);
                }
                else
                {                    
                    // result != null;
                    // Now check if result denotes PRIVATE entity
                    if (!result.modifiers.Private)
                        goto CreateResult;
                    { // Check if visible
                        NODE current = CONTEXT.current_unit;
                        bool withinTheScope = false;
                        while (current != null) {
                            if (result.enclosing == current)
                                withinTheScope = true;
                            current = current.enclosing;
                        }
                        if (withinTheScope)
                            goto CreateResult;
                    }
                    if (result.enclosing == CONTEXT.current_namespace)
                        goto CreateResult;

                    UNIT_DECL context = CONTEXT.current_unit;
                    NODE source = result.enclosing;

                    if (source is DEFINITION_DECL) {
                        if (context is DEFINITION_DECL && ((DEFINITION_DECL)context).refines((DEFINITION_DECL)source))
                            goto CreateResult;

                        if (context is IMPLEMENTATION_DECL && ((IMPLEMENTATION_DECL)context).implemented_definition == source)
                            goto CreateResult;

                        if (context is MODULE_DECL &&
                            IMPLEMENTS.implements(((MODULE_DECL)context).definitions, (UNIT_DECL)source))
                            goto CreateResult;

                        if (context is OBJECT_DECL &&
                            IMPLEMENTS.implements(((OBJECT_DECL)context).definitions, (UNIT_DECL)source))
                            goto CreateResult;
                    }
                    ERROR.PrivateEntity(member.Name, member.SourceContext);
                    result.modifiers.Private = false;  // to suppress similar CCI message
                    result.modifiers.Public = true;
                    // return null; -- if return null then some influenced messages are issued
                }

            CreateResult:
                return SELECTOR.create((DESIGNATOR)scope,(DECLARATION)result);

                // Notice that this case also covers following two ones:
                //
                // 1) D(o).m
                //
                //    where o is an object of an interface type, and D - definition.
                //    In this case, resolve() for D(o) (see above) returned DEFINITION_DECL.
                //
                // 2) ACTIVITY a;
                //      TYPE k = ( k1, k2, k3 );
                //    END a;
                //    ...
                //    TYPE kwd = a.k;
                //               ===
                //    This is the reference to an activity member.
            }
            if ( scope_decl is TYPE_DECL )  // only ENUM_TYPE/OBJECT_TYPE/INTERFACE_TYPE are legal
            {
                scope_decl = ((TYPE_DECL)scope_decl).type;
                goto ProcessName;
            }
            if (scope_decl is PROTOCOL_DECL) {
                NODE result = scope_decl.find(member);
                if ( result != null ) // access to a "keyword"
                    return SELECTOR.create((DESIGNATOR)scope,(DECLARATION)result);
                else {
                    ERROR.SyntaxErrorIn("protocol member access","");
                    return null;
                }
            }
            if (scope_decl is PROCEDURE_DECL || scope_decl is VARIABLE_DECL || scope_decl is INDEXER) {
                // 1. Something like p(args).m.
                //                   =========
                //    That is, we call a procedure which returns a value of a "compound"
                //    type: either an object type or an enumeration type.
                //
                // 2. Something like v.m.
                //                   ===
                //    The same case as for procedures.

                TYPE type;
                if (scope_decl is PROCEDURE_DECL)
                    type = ((PROCEDURE_DECL)scope_decl).return_type;
                else if (scope_decl is INDEXER)
                    type = ((INDEXER)scope_decl).type;
                else /* VARIABLE_DECL */
                    type = ((VARIABLE_DECL)scope_decl).type;

            ProcessType:

                if (type is OBJECT_TYPE) {
                    scope_decl = ((OBJECT_TYPE)type).ObjectUnit;
                    goto ProcessName;
                }
                if (type is ARRAY_TYPE) {
                    type = ((ARRAY_TYPE)type).base_type;
                    goto ProcessType;
                }
                if (type is ENUM_TYPE) {
                    scope_decl = type;
                    goto ProcessName;
                }
                if (type is STRING_TYPE) {
                    // Something like s.method where s is of type STRING,
                    // and 'method' is something declared for System.String type.
                    AssemblyNode ass = AssemblyNode.GetAssembly(typeof(System.String).Assembly);
                    TypeNode tp = ass.GetType(Identifier.For("System"),Identifier.For("String"));
                    MemberList membs = tp.GetMembersNamed(member);
                    if (membs == null || membs.Length == 0)
                        return null;

                    EXTERNAL_DECL external = EXTERNAL_DECL.create(membs[0],member,null);
                    return SELECTOR.create((DESIGNATOR)scope,external);
                }
                if (type is INTERFACE_TYPE) {
                    // This is the following case: obj.m where obj is an
                    // instance of an interface type like OBJECT { A, B },
                    // and m is a member in one of definition A or B.
                    UNIT_DECL_LIST unresolved_list = new UNIT_DECL_LIST();

                    INTERFACE_TYPE int_type = type as INTERFACE_TYPE;
                    for (int i = 0, n = int_type.interfaces.Length; i < n; i++) {
                        DECLARATION interfac = int_type.interfaces[i];
                        if (interfac is DEFINITION_DECL && interfac.find(member) != null) {
                            CALL call = new CALL();
                            call.arguments = new EXPRESSION_LIST();
                            call.arguments.Add((EXPRESSION)scope);
                            call.callee = INSTANCE.create(interfac);
                            scope = call;

                            scope_decl = (DEFINITION_DECL)interfac;
                            goto ProcessName;
                        } else  // UNKNOWN_DECL
                            unresolved_list.Add(int_type.interfaces[i]);
                    }
                    // No 'member' in already resolved definitions...
                    if (unresolved_list.Length >= 0) {
                        // ...but perhaps it is in one of unresolved definitions!
                        // We cannot find a name in the UNKNOWN_DECL right now;
                        // so, we just create a special kind of DESIGNATOR to resolve
                        // it during the second pass.
                        return new SAFEGUARD(unresolved_list,(DESIGNATOR)scope,member);
                    } else  // cannot find or assume 'member'
                        return null;
                }
                if (type is UNKNOWN_TYPE) {
                    // The situation is like as follows:
                    //
                    //    IMPORT object;  (* not declared yet *)
                    //    PROCEDURE p : object;
                    //     ...
                    //    v := p.x;
                    //
                    // This means that 'object' type should have 'x' member.
                    // At the moment we cannot check this, so we create
                    // UNKNOWN_DECL for 'x' and return the selector.

                    UNKNOWN_TYPE ut = type as UNKNOWN_TYPE;
                    if ( ut.unknown != null )  // unresolved type
                    {
                        scope_decl = ut.unknown;
                        goto ProcessName;
                    }
                    if (ut.indexer != null)  // unresolved type
                    {
                        scope_decl = ut.indexer;
                        goto ProcessName;
                    }

                    if ( ut.real_type != null ) // the type is already resolved
                    {
                        type = ut.real_type;
                        goto ProcessType;
                    }
                }
                // All other cases are illegal
                return null;
            }
            if (scope_decl is SAFEGUARD) {
                return SELECTOR.create((DESIGNATOR)scope, UNKNOWN_DECL.create(member, (SAFEGUARD)scope_decl));
            }
            // Other cases of DECLARATIONs are illegal
            return null;
        }

        //----------------------------------------------------------------------------
        public static DESIGNATOR processSimpleName(Identifier name) {
            return SELECTOR.process(null,name);
        }

        //----------------------------------------------------------------------------

        public static DESIGNATOR processQualName(NODE scope, IDENT_LIST qualName) {
            if (qualName == null)
                return null;

            NODE result = scope;

            for (int i = 0, n = qualName.Length; i < n; i++) {
                result = SELECTOR.process(result,qualName[i]);

                if (result == null) {
                    ERROR.WrongQualification(qualName.ToString());
                    return null;
                }
            }
        //  if ( !((DESIGNATOR)result).properlyImported )
        //  {
        //      ERROR.ImportMissed(qualName.ToString());
        //      result = null;
        //  }
            DESIGNATOR designator = (DESIGNATOR)result;
            designator.full_name = qualName; // Used by parser

            return designator;
        }

        //------------------------------------------------------------------------------------

        public static DESIGNATOR processImportName(IDENT_LIST qualName) {
            INSTANCE context = INSTANCE.create(CONTEXT.globalTree);
            return processSpecialName(context,qualName);
        }

        public static DESIGNATOR processDefinitionName(IDENT_LIST qualName) {
            UNIT_DECL scope;
            Identifier firstName = qualName[0];

            if (CONTEXT.current_unit == null) scope = CONTEXT.globalTree;  // A kind of bad stuff
            else scope = (UNIT_DECL)CONTEXT.current_unit;//.enclosing;
            if (scope is IMPLEMENTATION_DECL)
            {
                if (scope.IsTopLevelUnit())
                {
                    return processSpecialName(INSTANCE.create(CONTEXT.globalTree), qualName);
                }
                else
                {
                    return processSpecialName(INSTANCE.create(scope.getEnclosingUnit() as DECLARATION), qualName);
                }                                
            }
            return processSpecialName(INSTANCE.create(scope),qualName);
        }

        public static DESIGNATOR processSpecialName(INSTANCE context, IDENT_LIST qualName) {
            NODE result1 = context;
            NODE result2 = null;

            for (int i = 0, n = qualName.Length; i < n; i++) {
                result2 = SELECTOR.process(result1,qualName[i]);
                if (result2 == null) {
                    if ( result1 is DESIGNATOR )
                        result1 = ((DESIGNATOR)result1).resolve();

                    UNKNOWN_DECL external = UNKNOWN_DECL.create(qualName[i],(DECLARATION)result1);
                    result2 = INSTANCE.create(external);
                }
                result1 = result2;
            }
            return (DESIGNATOR)result1;
        }

        //-------------------------------------------------------------------------------------

        // resolve
        // -------
        // For SELECTOR this function checks if 'member' is UNKNOWN_DECL
        // and, if so, tries to resolve it.
        //
        // For normal cases the function returns DECLARATION for 'member'.
        // For errorneous cases it returns its own instance.
        //
        public override NODE resolve() {
            string left_name = null;

            // Attemp to find the whole name.
            // Important for import with qualified names
            
            NODE l = left_part.resolve();

            if (l is PROCEDURE_DECL && !(left_part is CALL) && ((PROCEDURE_DECL)l).paramCount == 0) {
                // Replace left_part for CALL
                CALL call = new CALL();
                call.callee = left_part;
                call.arguments = new EXPRESSION_LIST();
                call.sourceContext = left_part.sourceContext;

                left_part = call;
            }

            // First resolve selector's both parts...
            NODE left_decl;
            
         Again:
            left_decl = left_part.resolve();

            if (left_decl == null)
                return member;
            if (left_decl.name != null)
                left_name = left_decl.name.Name;

            if (left_part is CALL && member is UNKNOWN_DECL) {
                // Member should be resloved using 
                ((UNKNOWN_DECL)member).enclosing = left_part.type;
            }

            member = (DECLARATION)member.resolve();

            //((System.Compiler.Member)(((ETH.Zonnon.EXTERNAL_DECL)(member)).entity)).DeclaringType.Members.elements[14]
            //DEBUG
            //if (member is EXTERNAL_DECL)
            //{
            //    if (((ETH.Zonnon.EXTERNAL_DECL)(member)).entity != null)
            //    {
            //        Member m = ((ETH.Zonnon.EXTERNAL_DECL)(member)).entity as Member;
            //        if (m != null)
            //        {
            //            System.Console.WriteLine("++++++++++++++++++++++++++");
            //            foreach (Member mb in m.DeclaringType.Members)
            //            {
            //                string s = mb.FullName;
            //                if(mb is Method) {
            //                    s += "(" + ((Method)mb).Parameters.ToString() + ")";
            //                    s += " returns "+((Method)mb).ReturnType.ToString();
            //                }
            //                System.Console.WriteLine(s);
            //            }
            //        }
            //    }
            //}
            //EOF DEBUG
  
            if (left_decl.type is INTERFACE_TYPE) {
                // Convert left part of the selector to D(left_part),
                // where D is the (single) definition from the left_decl.

             // TODO: how to check the validity of the construct,
             // if we do not know which definition member is to be used?..
             //
                INTERFACE_TYPE int_type = (INTERFACE_TYPE)left_decl.type;
                DECLARATION interfac = null;
             

                for ( int i=0, n=int_type.interfaces.Length; i<n; i++ )
                {
                    interfac = ((INTERFACE_TYPE)left_decl.type).interfaces[i];
                    if (interfac.find(Identifier.For(member.Name))!=null) break;
                    else interfac = null;
                }
                if (interfac != null)
                {

                    CALL call = new CALL();
                    call.callee = INSTANCE.create(interfac);
                    call.callee.sourceContext = sourceContext;
                    call.arguments = new EXPRESSION_LIST();
                    call.arguments.Add(left_part);
                    call.sourceContext = sourceContext;
                    left_part = call;

                    goto Again;
                }
                else
                {
                    ERROR.UndeclaredEntity(sourceContext, member.Name, int_type.Name);
                }
            }

            // If 'member' is resolved then nothing to do
            if (!(member is UNKNOWN_DECL)) {
             // // Check the member's accessibility
             // if ( !(left_part is SELF) && member.modifiers.Private && !this.errorReported )
             // {
             //     this.errorReported = true;
             //     ERROR.PrivateEntity(member.name.Name,this.sourceContext);
             //  // member.modifiers.Private = false;
             //  // member.modifiers.Public = true;
             // }
                return member;
            }

            // Otherwise member is UNKNOWN_DECL.
            // Try to resolve 'member' in the context of 'left_part'

        Resolve:

            if (left_decl is EXTERNAL_DECL && member is UNKNOWN_DECL) {
                Identifier m = ((UNKNOWN_DECL)member).name;
                NODE n = left_decl.find(m);
                if (name == null)
                    name = member.name;
                return member;
            }
            if (left_decl is UNIT_DECL || left_decl is ENUM_TYPE) {
                NODE result = left_decl.find(member.name);
                if (result != null) {
                    // Just replacing UNKNOWN_DECL for a real member
                    member = (DECLARATION)result;
                    // And go on below.
                } else {
                    if (!member.ErrorReported && !CONTEXT.firstPass) {
                        if (left_name == null)
                            left_name = "entity of type " + left_decl.name.Name;
                        ERROR.UndeclaredEntity(member.sourceContext,member.name.Name,left_name);
                        member.ErrorReported = true;
                    }
                    return member; //RM: return UNKNOWN_DECL
                }
            } else if (left_decl is PROCEDURE_DECL || left_decl is VARIABLE_DECL) {
                TYPE type;
                if (left_decl is PROCEDURE_DECL)
                    type = ((PROCEDURE_DECL)left_decl).return_type;
                else /* VARIABLE_DECL */
                    type = ((VARIABLE_DECL)left_decl).type;

                if ( type is OBJECT_TYPE ) { left_decl = ((OBJECT_TYPE)type).ObjectUnit; goto Resolve; }
                if ( type is ENUM_TYPE )   { left_decl = type; goto Resolve; }
                if (type is INTERFACE_TYPE) {
                    INTERFACE_TYPE int_type = type as INTERFACE_TYPE;
                    for (int i = 0, n = int_type.interfaces.Length; i < n; i++) {
                        DECLARATION interfac = int_type.interfaces[i];
                        if (interfac is DEFINITION_DECL && interfac.find(member.name) != null) {
                            left_decl = (DEFINITION_DECL)interfac;
                            goto Resolve;
                        }
                    }
                    // No 'member' in definitions; go below
                }
            } else if (left_decl is IMPORT_DECL) {
                left_decl = ((IMPORT_DECL)left_decl).imported_unit;
                goto Resolve;
            } else if (left_decl is TYPE_DECL) {
                left_decl = ((TYPE_DECL)left_decl).type;
                goto Resolve;
            }
            return member;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (!left_part.validate())
                return false;
         // if ( !member.validate() ) return false;

            // Check semantical correctness of the composition
            // left_part.member
            NODE l = left_part.resolve();
            DECLARATION m = (DECLARATION)member.resolve();

            if (m is UNKNOWN_DECL) {
                // We couldn't find m member in left_part.resolve()
                if (!m.ErrorReported) {
                    ERROR.UndeclaredEntity(m.sourceContext,m.Name,l.Name);
                    m.ErrorReported = true;
                }
                return false;
            }

            if (left_part is SELF)
                return true;

            if (l is OBJECT_DECL && (m is FIELD_DECL || m is PROCEDURE_DECL)) {
                if (!this.ErrorReported) {
                    ERROR.NotAnInstance(l.name.Name,left_part.sourceContext);
                    this.ErrorReported = true;
                }
                return false;
            }

            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates selector type
        {
            // By definition, selector type is the type of its 'member'.
            get {
                if (internal_type == null || internal_type is UNKNOWN_TYPE) {
                    if (member is ROUTINE_DECL) {
                        ROUTINE_DECL proc = member as ROUTINE_DECL;
                        if (proc.prototype != null && proc.prototype is FIELD_DECL) {
                            internal_type = proc.prototype.type;
                            return internal_type;
                        }
                    }
                    internal_type = member.type;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates constant expressions
        {
            //     ,     ...
            DECLARATION entity = (DECLARATION)member.resolve();
            if ( entity is CONSTANT_DECL )
                return ((CONSTANT_DECL)entity).initializer.calculate();
            if ( entity is ENUMERATOR_DECL )
                return ((ENUMERATOR_DECL)entity).val;

            return null;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            // The general idea of generating CCI tree for selectors
            // is that they are represented as qualified identifiers.
            // The only exception is for constants: we just take their values.

            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            if (member is CONSTANT_DECL) {
                node = ((CONSTANT_DECL)member).initializer.convert();
                return node;
            }

            if (member is EXTERNAL_DECL && ((EXTERNAL_DECL)member).entity is Member) {
                Member  memb = (Member)((EXTERNAL_DECL)member).entity;
                Node    qualifier = left_part.convert();
                Node    res;
                if (memb is TypeNode) {
                    // Here we do not take qualifier!- we assume that
                    // qualifier for a class is a namespace, and CCI doesn't accept
                    // namespaces as qualifiers...
                    res = new MemberBinding(null,memb);
                } else if (qualifier is Expression) {
                    res = new QualifiedIdentifier((Expression)qualifier,memb.Name);
                } else // qualifier is TypeNode
                {
                    MemberBinding t = new MemberBinding(null,(TypeNode)qualifier);
                    t.Type = SystemTypes.Type;
                    t.SourceContext = left_part.sourceContext;
                    res = new QualifiedIdentifier(t,memb.Name);
                }
                res.SourceContext = member.sourceContext;
                node = res;
                return node;
            }

            if (left_part is INSTANCE) {
                DECLARATION ent = ((INSTANCE)left_part).entity;
                if (ent is IMPLEMENTATION_DECL && ((IMPLEMENTATION_DECL)ent).implemented_definition == null) {
                    QualifiedIdentifier qid = new QualifiedIdentifier();
                    qid.Qualifier = Identifier.For(ent.name.Name+"_hidden");
                    qid.Identifier = member.name;
                    node = qid;
                    return node;
                }
                if ( ent is UNIT_DECL && !( ent is EXTERNAL_DECL) &&!(ent is PROTOCOL_DECL) )
                {
                    if (ent is MODULE_DECL) // module's members are static
                    {
                        MemberBinding t = new MemberBinding(null, (TypeNode)ent.convert());
                        t.Type = SystemTypes.Type;
                        t.SourceContext = left_part.sourceContext;
                        node = new QualifiedIdentifier(t, member.name);
                    } else {
                        node = member.convert();
                        if(node is Member)
                            node = new MemberBinding(null, (Member)member.convert());
                    }

                    return node;
                }
            }
            if (member is ENUMERATOR_DECL) {
                // This is something like E.e1, where E is an enumeration type,
                // and e1 is its enumerator. Now CCI doesn't compile such constructs 
                // correctly. So I would try just to replace it for e1's value directly...
                ENUMERATOR_DECL enumerator = member as ENUMERATOR_DECL;
                node = new Literal((int)enumerator.val, enumerator.type.convert()as TypeNode);                

                return node;
            }

            Node left = left_part.convert();

            if (left is TypeNode) {
                Node m = member.convert();
                if (m is Member) {
                    MemberBinding mb = new MemberBinding(null,(Member)m);
                    node = mb;
                } else {
                    MemberBinding tp = new MemberBinding(null,(TypeNode)left);
                    tp.Type = SystemTypes.Type;
                    QualifiedIdentifier qual = new QualifiedIdentifier(tp,(Identifier)m);
                    qual.Type = ((Identifier)m).Type;
                    qual.SourceContext = left_part.sourceContext;
                    node = qual;
                }
                return node;
            }

            QualifiedIdentifier qualId = new QualifiedIdentifier();

            bool member_is_accessor = false;
            UNIT_DECL accessor_unit = null;

            if (member is FIELD_DECL && member.enclosing is DEFINITION_DECL) {
                member_is_accessor = true;
                accessor_unit = (UNIT_DECL)member.enclosing;
            } else if (member is ROUTINE_DECL) {
                ROUTINE_DECL proc = member as ROUTINE_DECL;
                if (proc.prototype != null && proc.prototype is FIELD_DECL) {
                    member_is_accessor = true;
                    accessor_unit = (UNIT_DECL)proc.prototype.enclosing;
                }
            }

            // Casting here is very bad for value object and thus commented
            // TODO: to figure out if there are cases when it is needed
            //if ( member_is_accessor )
            //{
            //    BinaryExpression cast = new BinaryExpression();
            //    cast.Operand1 = (Expression)left;
            //    cast.Operand2 = new MemberBinding(null,(Member)accessor_unit.convert());
            //    cast.Operand2.Type = SystemTypes.Type;
            //    cast.NodeType = NodeType.Castclass;
            //    qualId.Qualifier = cast;
            //}
            //else
                qualId.Qualifier = (Expression)left;

            qualId.Identifier = member.name==null ? null : member.name;
            qualId.SourceContext = left_part.sourceContext;

            if (qualId.Identifier == null || qualId.Qualifier == null)
                return null;

            if ( member.type != null )
                qualId.Type = (TypeNode)member.type.convert();

            node = qualId;
            return node;
        }


        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("SELECTOR; TYPE={0}; line={1}",type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("LEFT PART:");
            left_part.report(shift+2*NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("MEMBER:");
            NODE.doShift(shift+2*NODE.reportShift);
            member.report_short(); //.report(shift+2*NODE.reportShift);
            System.Console.WriteLine();
        }
#endif
    }

    // SAFEGUARD
    // =========
    //
    //
    public sealed class SAFEGUARD : DESIGNATOR {
        public UNIT_DECL_LIST definitions;
        public DESIGNATOR     callee;
        public Identifier     member;

        public SELECTOR       real_selector;

        protected override bool containsErrorReport() {
            return (callee!=null?callee.ErrorReported:false) || (real_selector != null?real_selector.ErrorReported:false);
        }

        public SAFEGUARD(UNIT_DECL_LIST defs, DESIGNATOR c, Identifier m)
            : base(ASTNodeType.SAFEGUARD) {
            definitions = defs;
            callee = c;
            member = m;
            real_selector = null;
        }

        public override string verbalize ( ) { return "(...)"+callee.verbalize()+"."+member.Name; }

        public override NODE resolve() {
            if ( real_selector != null )
                return real_selector.resolve();

            for (int i = 0, n = definitions.Length; i < n; i++) {
                DECLARATION interfac = definitions[i];
                DECLARATION resolved = (DECLARATION)interfac.resolve();
             // if ( resolved is UNKNOWN_DECL )
             // {
             //     return resolved;
             // }
             // else 
                if (resolved is DEFINITION_DECL) {
                    DECLARATION m = (DECLARATION)resolved.find(member);
                    if (m == null)
                        continue;

                    CALL call = new CALL();
                    call.arguments = new EXPRESSION_LIST();
                    call.arguments.Add(callee);
                    call.callee = INSTANCE.create(resolved);

                    real_selector = SELECTOR.create(call,m);

                    definitions = null;
                    callee = null;
                    member = null;

                    return real_selector.resolve();
                }
                if (resolved is EXTERNAL_DECL)
                {
                    EXTERNAL_DECL m = resolved.find(member) as EXTERNAL_DECL;
                    if (m == null) continue;

                    CALL call = new CALL();
                    call.arguments = new EXPRESSION_LIST();
                    call.arguments.Add(callee);
                    call.callee = INSTANCE.create(resolved);

                    real_selector = SELECTOR.create(call, m);

                    definitions = null;
                    callee = null;
                    member = null;

                    return real_selector.resolve();
                }
            }
            return this;
        }

        public override object calculate() { return null; }

        public override bool validate() {
            if (real_selector != null)
                return true;

            DECLARATION     memb = null;
            DEFINITION_DECL def  = null;
            bool            err  = false;

            for (int i = 0, n = definitions.Length; i < n; i++) {
                DECLARATION interfac = definitions[i];
                DECLARATION resolved = (DECLARATION)interfac.resolve();

                if (resolved is UNKNOWN_DECL)
                    return false;
                if (resolved is DEFINITION_DECL) {
                    DECLARATION m = (DECLARATION)resolved.find(member);
                    if (m == null)
                        continue;

                    if (def != null) {
                        ERROR.DefinitionAmbiguity(memb.name.Name,def.name.Name,resolved.name.Name,
                                                  this.sourceContext);
                        err = true;
                    }
                    memb = m;
                    def = (DEFINITION_DECL)resolved;
                }
                if (resolved is EXTERNAL_DECL && (((EXTERNAL_DECL)resolved).entity is Interface))
                {
                    Interface interf = ((EXTERNAL_DECL)resolved).entity as Interface;
                    Queue<Interface> iq = new Queue<Interface>();
                    iq.Enqueue(interf);
                    while(iq.Count > 0){
                        interf = iq.Dequeue();
                        MemberList ml = interf.GetMembersNamed(Identifier.For(member.Name));
                        if(ml.Length>0){
                            memb = new EXTERNAL_DECL(ml[0]);
                            break;
                        }
                        foreach (Interface ie in interf.Interfaces) iq.Enqueue(ie);
                    }
                }
            }
            if ( memb == null ) // no member found
            {
                INTERFACE_TYPE interf = INTERFACE_TYPE.create();
                for ( int i=0, n=definitions.Length; i<n; i++ )
                    interf.interfaces.Add((UNIT_DECL)definitions[i].resolve());

                ERROR.NoMemberInInterface(member.Name,interf.ToString(),this.sourceContext);
                err = true;
            }
            return !err; 
        }

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;
            if (real_selector == null)
                return null;

            node = real_selector.convert();
            return node;
        }


        public override TYPE type {
            get {
                if ( internal_type == null && real_selector != null )
                    internal_type = real_selector.member.type;
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("SAFEGUARD line={0}", this.sourceContext.StartLine.ToString());
            if (real_selector != null)
                System.Console.Write(" RESOLVED TO SELECTOR");
            System.Console.Write("; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
            if (real_selector != null) {
                real_selector.report(shift+NODE.reportShift);
                return;
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("UNRESOLVED DEFINITIONS:");
            NODE.doShift(shift+2*NODE.reportShift);
            for (int i = 0, n = definitions.Length; i < n; i++) {
                UNIT_DECL def = definitions[i];
                if ( def.name != null )
                    System.Console.Write("{0} ",def.name.Name);
                else // resolved
                    System.Console.Write("{0} (RESOLVED) ",((UNKNOWN_DECL)def).RealDeclaration.name.Name);
            }
            System.Console.WriteLine();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("OBJECT:");
            if ( callee == null )
                System.Console.WriteLine("MISSED");
            else
                callee.report(shift+2*NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("MEMBER: {0}",member.Name);
        }
#endif
    }

    // CALL
    // ====
    // The node represents function and procedure calls.
    // Notice that _operator_ calls always have the syntactic form of
    // expression and therefore are not represented as CALL nodes.
    //
    public sealed class CALL : DESIGNATOR {
        // Constructor
        public CALL ( ) : base(ASTNodeType.CALL) { arguments = new EXPRESSION_LIST(); }

        public DESIGNATOR      callee;
        public EXPRESSION_LIST arguments;

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            if(callee != null) scope = callee.findScopeAtContext(line, col, documentName);
            if (scope == null)
            {
                for (int i = 0; i < arguments.Length; i++)
                {
                    if (arguments[i] == null) continue;
                    scope = arguments[i].findScopeAtContext(line, col, documentName);
                    if (scope != null)
                        break;
                }
            }
            return scope;
        }

        protected override bool containsErrorReport() {
            bool oneof = false;
            for (int i = 0; i < arguments.Length; i++)
                if (arguments[i] != null)
                    oneof |= arguments[i].ErrorReported;
            return callee.ErrorReported || oneof;
        }

        //--------------------------------------------------------------------------

        public override string verbalize ( ) { return callee.verbalize() + "()"; }

        //-------------------------------------------------------------------------------------

        // resolve
        // -------
        // For CALLs, the function normally returns:
        //
        // PROCEDURE_DECL      -- for ordinary calls;
        // VARIABLE_DECL       -- for calls via procedure type;
        //
        // DEFINITION_DECL     -- for safeguards
        // IMPLEMENTATION_DECL --
        //
        // For unresolved 'callee', the function returns UNKNOWN_DECL.
        //
        // If 'callee' is errorneous, the function just returns its own instance (CALL).
        //
        public override NODE resolve() {
            for ( int i=0, n=arguments.Length; i<n; i++ )
                if (arguments[i] != null)
                    arguments[i].resolve();

            if (callee != null) {
                NODE c = callee.resolve();
                // Check if we've picked right overloaded method depends on arguments.
                if ((c is EXTERNAL_DECL) && ((EXTERNAL_DECL)c).entity as Method != null) {
                    Method m = ((EXTERNAL_DECL)c).entity as Method;
                    Member best = null;
                    MemberList ml = m.DeclaringType.GetMembersNamed(m.Name);
                    bool better = false;
                    bool worse = false;
                    TYPE [] bestt = new TYPE[arguments.Length];

                    foreach (Method mn in ml) {
                        if (mn.Parameters.Length != arguments.Length)
                            continue;
                    
                        for(int i= 0, n = arguments.Length; i<n; i++){
                            if (bestt[i] == null)
                                better = true;
                            else{
                                TYPE t1 = new EXTERNAL_TYPE(mn.Parameters[i].Type);
                                TYPE t2 = bestt[i];
                                TYPE t3 = arguments[i].type;
                                if (TYPE.IsBetterMatch(t1, t2, t3)) {
                                    better = true;
                                }
                                if (TYPE.IsBetterMatch(t2, t1, t3)) {
                                    worse = true;
                                }

                            }
                        }
                        if(better && ! worse){
                            best = mn;
                            for(int i= 0, n = arguments.Length; i<n; i++)
                                bestt[i] = new EXTERNAL_TYPE(mn.Parameters[i].Type);
                        }

                    }
                    // Change with better overload
                    if (best != null)
                        ((EXTERNAL_DECL)c).entity = best;
                }
                if (c is PROCEDURE_DECL) {
                    // For generic standard procedures we should evaluate the real
                    // return type (which depends on actual argument(s)).
                    PROCEDURE_DECL.EvaluateType check_type = ((PROCEDURE_DECL)c).evaluateType;
                    if (check_type != null) {
                        callee.type = check_type(this);
                        //NG: here we have to make internal_type and type correct too
                        internal_type = callee.type;
                        type = callee.type;
                    }
                }
                return c;
            } else
                return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Semantical correctness for function/procedure calls
            // means the following:
            //
            // o  'callee' is either a procedure/function name or
            //    a designator of a procedure type;
            //
            // o  The number of call arguments is equal to the number
            //    of the procedure/function's parameters;
            //
            // o  Types of ith argument & ith parameter are assignment compatible.
            //
            // o  Arguments corresponding to VAR-parameters should be a subset of DESIGNATOR type.
            //
            // o  Cannot pass immutable variables as VAR-arguments.
            //
            if (callee == null)
                return false;
            if (!callee.validate()) {
                //TODO: Think about better error message here.
                if (!callee.ErrorReported) ERROR.CannotResolve(sourceContext, callee.Name);
                return false;
            }
                

            int                param_number = 0;
            VARIABLE_DECL_LIST parameters = null;
            DECLARATION        declaration = null;

            NODE res = callee.resolve();
            if (res is OBJECT) {
                // Conversion to an object
                if (arguments.Length != 1) {
                    ERROR.ExtraParameters(1, sourceContext);
                    return false;
                }
                return true;
            }
            
            if (res is DECLARATION) {
                declaration = (DECLARATION)res;
            } else if (res is SAFEGUARD) // a call of a member of an unresolved definition
            {
                SAFEGUARD guard = (SAFEGUARD)res;
                for (int i = 0, n = guard.definitions.Length; i < n; i++) {
                    UNIT_DECL def = guard.definitions[i];
                    if ( def is UNKNOWN_DECL && ((UNKNOWN_DECL)def).RealDeclaration == null &&
                         !def.ErrorReported) {
                        ERROR.UndeclaredDefinition(def.sourceContext,def.name.Name);
                        def.ErrorReported = true;
                    }
                }
                return false;
            }

            if (declaration is OPERATOR_DECL) {
                parameters = ((OPERATOR_DECL)declaration).parameters;
                param_number = ((OPERATOR_DECL)declaration).paramCount;
                //RM: Checking again won't hurt: we've missed checks on reference types
                //  // We have already performed all checks during
                //  // contructing call for this operator; no more checks.
                //  return true;
            } else if (declaration is PROCEDURE_DECL) {
                PROCEDURE_DECL procedure = (PROCEDURE_DECL)declaration;
                if (procedure.convertStandardCall != null)
                    return true;
                // this is a call to a standard procedure; will do validation later
                param_number = procedure.parameters.Length;
                parameters = procedure.parameters;
            } else if (declaration.type is PROC_TYPE) {
                PROC_TYPE proc_type = (PROC_TYPE)declaration.type;
                param_number = proc_type.parameters.Length;
                parameters = proc_type.parameters;
            } else if (declaration.type is ABSTRACT_ACTIVITY_TYPE || declaration.type is ACTIVITY_TYPE) {
                // This is actually send statement.
                
                // Prohibit for INTEGER, CARDINAL types to be sent without typecast
                for (int i = 0, n = arguments.Length; i < n; i++) {
                    EXPRESSION arg = arguments[i];
                    EXPRESSION result = TYPE.AssignmentCompatibility(new EXTERNAL_TYPE(SystemTypes.Object), arg.type, arg, arg.sourceContext, false);
                    if (result == null) { return false; }
                    arguments[i] = result;

                    if ((arg.type is INTEGER_TYPE) || (arg.type is CARDINAL_TYPE) || (arg.type is REAL_TYPE)) {
                        // for this types we require explicit typecast
                        if ((arg as CALL == null) && (arg as TYPE_CONV == null) && (arg as DESIGNATOR == null) || (arg as LITERAL != null)) {
                            ERROR.ExplicitTypeConversionRequired(sourceContext);
                            return false;
                        }

                    }
                }
                return true;
            } else if (declaration is EXTERNAL_DECL) {
                // This is system or external call
                Node externalProc = ((EXTERNAL_DECL)declaration).entity;
                if ( externalProc is Method ) {
                    // Implementing a check for passing a delegate. Other checks leave to CCI for now
                    if (((Method)externalProc).Parameters.Length != arguments.Length) {
                        //** Seems to be wrong but we do not check all oveloads here,
                        // so we let process this case to CCI
                        return true;
                    }
                    for (int i = 0, n = arguments.Length; i < n; i++) {
                        EXPRESSION arg = arguments[i];
                        Parameter par = ((Method)externalProc).Parameters[i];
                        if ((par.Type.NodeType == NodeType.DelegateNode) && (arg is INSTANCE) && (((INSTANCE)arg).entity is PROCEDURE_DECL)) {
                            // for this types we require explicit typecast
                            bool wrong = false;
                            PROCEDURE_DECL proc = ((INSTANCE)arg).entity as PROCEDURE_DECL;                            
                            DelegateNode del = par.Type as DelegateNode;
                            if (del.Parameters.Length != proc.parameters.Length) {
                                wrong = true;
                            } else {
                                for (int k = 0; k < del.Parameters.Length; k++) {
                                    NodeType parType = del.Parameters[k].Type.NodeType;
                                    if (parType == NodeType.Reference) {   // Take the type and check that on the right side it's also a reference
                                        parType = (((Reference)del.Parameters[k].Type)).ElementType.NodeType;
                                        //TODO: add test that right side is a refernce                                        
                                    }

                                    if (parType != ((TypeNode)proc.parameters[k].type.convert()).NodeType) {
                                        NodeType rt = ((TypeNode)proc.parameters[k].type.convert()).NodeType;
                                        // Exception
                                        if (
                                            ((parType == NodeType.ArrayType) || (parType == NodeType.ArrayTypeExpression))
                                            &&
                                            ((rt == NodeType.ArrayType) || (rt == NodeType.ArrayTypeExpression))
                                            ) {
                                            // it is ok
                                        } else {
                                            wrong = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (wrong) {
                                ERROR.DelegateWithWrongArgs(arg.name.Name, del.Parameters.ToString(), sourceContext);
                                return false;
                            }

                        }
                    }
                    
                    return true; // No checks for now...
                }
                if (externalProc is Property)
                    return true; // No checks for now...
                if (externalProc is Interface)
                    return true; // No checks for now...

                if (externalProc is Class)
                    return true; // This is not call but conversion
                if (externalProc is Struct)
                    return true;   // but let us process it here
                // Note: Strict e.g. Double.

                if (!callee.ErrorReported) {
                    ERROR.IllegalUseOfExternal(((EXTERNAL_DECL)declaration).name.Name,callee.sourceContext);
                    callee.ErrorReported = true;
                }
                return false;
            } else if (declaration is DEFINITION_DECL) {
                // This is not a call but type guard of form like
                //
                //    D(obj)...

                if (arguments.Length != 1 && !callee.ErrorReported)
                    goto SafeguardErr;
                NODE arg = arguments[0];
                arg.resolve();

                // We check the type of the original argument[0] but not
                // "resolved" type. For example, for indexers there is a differenece...
                if (arg.type is OBJECT_TYPE) {
                    OBJECT_DECL unit = (OBJECT_DECL)((OBJECT_TYPE)arg.type).ObjectUnit;
                    if ( IMPLEMENTS.implements(unit.definitions,(DEFINITION_DECL)declaration) )
                        return true;
                } else if (arg.type is INTERFACE_TYPE) {
                    UNIT_DECL_LIST interfaces = ((INTERFACE_TYPE)arg.type).interfaces;
                    for ( int i=0, n=interfaces.Length; i<n; i++ )
                        if (interfaces[i] == declaration)
                            return true;
                    // We don't care :) Correctness will keep to be checked at runtime
                    return true; 
                }

            SafeguardErr :
                ERROR.IllegalSafeguard(declaration.name.Name,callee.sourceContext);
                callee.ErrorReported = true;
                return false;
            } else if (declaration is OBJECT_DECL) {
                // TO DO: This check is not strict enouth
                if (arguments.Length != 1 && !callee.ErrorReported) {
                    ERROR.IllegalSafeguard(declaration.name.Name, callee.sourceContext);
                    callee.ErrorReported = true;
                    return false;
                }
                NODE arg = arguments[0];
                arg.resolve();
                if ((arg.type is INTERFACE_TYPE))
                    return true;
                else if (arg.type!=null && (arg.type.node is Class)) 
                    return true;
                else {
                    ERROR.InternalCompilerError("CALL.validate(): if this is called compiler meant to issue an error about conversion args but had forgotten");
                    /*
                    OBJECT_DECL unit = (OBJECT_DECL)((OBJECT_TYPE)arg.type).object_unit;
                    OBJECT_DECL decl = (OBJECT_DECL)declaration;
                    UNIT_DECL_LIST interfaces = decl.definitions;
                    bool interfaceOk = true;
                    for (int i = 0, n = interfaces.Length; i < n; i++)
                        if (IMPLEMENTS.implements(unit.definitions, interfaces[i])) interfaceOk = false;
                    return interfaceOk;
                     */
                    return false;
                }
            } else if ((declaration.type is EXTERNAL_TYPE) && (((EXTERNAL_TYPE)declaration.type).entity.NodeType == NodeType.DelegateNode)) {
                return true;
            }
            else if (declaration is PROTOCOL_DECL)
            {
                return true;
            }
            else
            {
                if (!callee.ErrorReported)
                {
                    ERROR.IllegalCall(callee.sourceContext);
                    callee.ErrorReported = true;
                }
                return false;
            }

            if (arguments.Length < parameters.Length) {
                ERROR.MissingParameters(parameters.Length,callee.sourceContext);
                return false;
            } else if (arguments.Length > parameters.Length) {
                ERROR.ExtraParameters(parameters.Length,callee.sourceContext);
                return false;
            }

            bool err = false;
            for (int i = 0, n = arguments.Length; i < n; i++) {
                EXPRESSION arg     = arguments[i];
                PARAMETER_DECL par = (PARAMETER_DECL)parameters[i];

                if (arg == null)
                    return false;
                if (!arg.validate())
                    return false;
                // Comparing argument types with parameter types:
                // two types should be "assignment compatible" just as for assignment
                // (see ASSIGNMENT class).

                  //Exclude assigining to delegates
                if ((par.type is PROC_TYPE)||
                    (par.type is EXTERNAL_TYPE) && ((EXTERNAL_TYPE)par.type).entity.NodeType == NodeType.DelegateNode) {

                    // TODO: write MORE checks here (arguments, etc)
                    if (par.type is PROC_TYPE) // Local case
                    {
                        PROC_TYPE proc = par.type as PROC_TYPE;
                        if((arg is INSTANCE)&&(((INSTANCE)arg).entity is PROCEDURE_DECL)){
                            PROCEDURE_DECL argproc = ((INSTANCE)arg).entity as PROCEDURE_DECL;
                            if (argproc.parameters.Length != proc.parameters.Length) {
                                ERROR.AssignmentCompatibility(argproc.Name, proc.Name, arg.sourceContext);
                                this.ErrorReported = true;
                                err = true;
                            } else {
                                for (int j = 0; j < proc.parameters.Length; j++) {
                                    if (!TYPE.AssignmentCompatibilityS(argproc.parameters[j].type, proc.parameters[j].type) ||
                                        (((PARAMETER_DECL)argproc.parameters[j]).Reference != ((PARAMETER_DECL)proc.parameters[j]).Reference)
                                        ) {
                                        ERROR.AssignmentCompatibility(argproc.Name, proc.ToString(), arg.sourceContext);
                                        this.ErrorReported = true;
                                        err = true;
                                    }
                                }
                            }
                            
                        }                        
                    }
                } else {
                    EXPRESSION result = TYPE.AssignmentCompatibilityInProcedureCall(par.type, arg.type, i, this, arg, arg.sourceContext);
                    if (result == null) { err = true; continue; }  // Compatibility error was detected
                    // Replace right_part for the new sub-tree!
                    arguments[i] = result;
                }
                if (par.Reference) {
                    // Cannot pass constants/immutables as VAR-parameters
                    NODE p = arg.resolve();
                    if (p is CONSTANT_DECL) {
                        ERROR.AssignToConstant(p.name.Name,arg.sourceContext);
                        err = true;
                    } else if (p is VARIABLE_DECL || p is INDEXER) {
                        if (p is INDEXER)
                            p = ((INDEXER)p).left_part;
                        if (p is SELECTOR)
                            p = ((SELECTOR)p).member;
                        if (p != null && p.modifiers.Immutable) {
                            NODE scope = p.getEnclosingUnit();
                            if (scope != CONTEXT.current_unit) {
                                ERROR.ModifyImmutable(p.name.Name, sourceContext);
                                err = true;
                            }
                            // else
                            //     -- It's OK; going on
                        }
                    }
                    // Corresponding parameter should be:
                    // INSTANCE, SELECTOR, INDEXER, SELF, DEREFERENCE
                    if ( arg is INSTANCE || arg is SELECTOR || ((arg is INDEXER) && (((INDEXER)arg).calls == null)) ||
                        arg is SELF || arg is DEREFERENCE )
                        continue;  // it's OK; going on

                    string name = par.name != null ? par.name.Name : (i+1).ToString();
                    ERROR.IllegalArgumentForVar(name,arg.sourceContext);
                    err = true;
                }
            }
            if (type != null) type.validate();
            return !err;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates type of the call
        {
            // Type of the call construct is type of the routine called.
            get {
                if (internal_type == null || internal_type is UNKNOWN_TYPE || internal_type is ANY_TYPE) {
                    if (callee != null) {
                        NODE res = callee.resolve();
                        if (res is DEFINITION_DECL) {
                            INTERFACE_TYPE tp = INTERFACE_TYPE.create();
                            tp.interfaces.Add(((DEFINITION_DECL)res));                           
                            internal_type = tp;
                        } else if (res is EXTERNAL_DECL && (((EXTERNAL_DECL)res).entity is Interface || ((EXTERNAL_DECL)res).entity is Struct)) { // Definition imported from another DLL
                            internal_type = EXTERNAL_TYPE.create(((EXTERNAL_DECL)res).entity);
                        } else if (res is EXTERNAL_DECL && (((EXTERNAL_DECL)res).entity is Method)) { // Method imported from another DLL
                            internal_type = EXTERNAL_TYPE.create(((Method)((EXTERNAL_DECL)res).entity).ReturnType);                            
                        } else if (callee.type is PROC_TYPE)
                            internal_type = ((PROC_TYPE)callee.type).return_type;
                        else if ((callee is SELECTOR) && ((callee as SELECTOR).member is EXTERNAL_DECL) && (((callee as SELECTOR).member as EXTERNAL_DECL).entity.NodeType == NodeType.Class))
                            // This is the case of external type. Check written for the case of type conversion
                            internal_type = EXTERNAL_TYPE.create(((callee as SELECTOR).member as EXTERNAL_DECL).entity);
                        else
                            internal_type = callee.type;
                    }
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates constant expressions
        {
            // If this is the call of a standard function returning a value,
            // and the arguments are constants then the result of the call
            // is also a constant and should be calculated at compile time.

            if (val != null)
                return val;
            if (callee == null)
                return null;

            DECLARATION callee_decl = (DECLARATION)callee.resolve();
            if (callee_decl is PROCEDURE_DECL && callee_decl.enclosing == STANDARD.Standard) {
                // This is the call to a _standard_ procedure:
                // Doing special processing...
                val = ((PROCEDURE_DECL)callee_decl).calculateStandardCall(this);
                return val;
            }

            // Otherwise this is a "normal" (user-defined) procedure
            return null;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;
            if (callee == null)
                return null;

            resolve();
            if (!validate())
                return null;

            DECLARATION callee_decl = (DECLARATION)callee.resolve();

            if (callee_decl.type is ACTIVITY_TYPE || callee_decl.type is ABSTRACT_ACTIVITY_TYPE) {
                // This is 'send' or 'receive' operation on an activity instance.

                Expression qualifier = (Expression)callee.convert();

                if (arguments.Length == 0) {
                    // This is 'receive' operation.
                    // compile it as callee.receive()

                    MethodCall receive = new MethodCall();
                    receive.Callee = new QualifiedIdentifier(qualifier,Identifier.For("receive"));
                    receive.Operands = new ExpressionList();  // no args
                    receive.SourceContext = callee.sourceContext;
                    receive.Type = SystemTypes.Object;

                    node = receive;
                    return node;
                }

                // This is 'send' operation.
                // Compile it as callee.send(p1). ... .send(pn);

                MethodCall send = null;

                for (int i = 0, n = arguments.Length; i < n; i++) {
                    send = new MethodCall();
                    send.Callee = new QualifiedIdentifier(qualifier,Identifier.For("send"));
                    send.GiveErrorIfSpecialNameMethod = false; // ??
                    send.IsTailCall = false;
                 // send.NodeType
                    send.Operands = new ExpressionList(1);

                    send.Operands.Add((Expression)arguments[i].convert());
                    send.Type = (TypeNode)STANDARD.protocol.type.convert();

                    qualifier = send;
                }
                node = send;
                return node;
            }

            bool[]             refs       = null;
            VARIABLE_DECL_LIST parameters = null;

            if (callee_decl is PROCEDURE_DECL || callee_decl is OPERATOR_DECL) {
                if (callee_decl.enclosing == STANDARD.Standard)
                    // This is the call to a _standard_ procedure:
                    // Doing special processing...
                    return ((PROCEDURE_DECL)callee_decl).convertStandardCall(this);

                // Otherwise, this is a "normal" (user-defined) procedure call; going on.

                parameters = ((ROUTINE_DECL)callee_decl).parameters;
                DECLARATION proto = ((ROUTINE_DECL)callee_decl).prototype;
                if (proto != null) {
                    proto = proto.resolve() as DECLARATION; //without resolve() compiler thinks that a method without parameters is a property
                    if (parameters.Length == 0 && !(proto is ROUTINE_DECL) &&
                        // && proto != null
                        // It is not the case for the method in external class that implements something
                        !((proto is EXTERNAL_DECL) && (((EXTERNAL_DECL)proto).entity) is Method)
                        )
                        // This is a call to a procedure which is in fact accessor's implementation. 
                        // We shouldn't create a real call because CCI will recognize the situation
                        // and will automatically create its "own" call for appropriate accessor 
                        // function... - Just return callee itself...
                        return callee.convert();
                }
            } else if (callee_decl is VARIABLE_DECL) {
                TYPE type = callee_decl.type;
                if (type is PROC_TYPE)
                    parameters = ((PROC_TYPE)type).parameters;
                // else
                //     -- Impossible: validate() function has already checked
                //     -- the validity of callee; it is either procedure or a
                //     -- variable of a procedure type.
            } else if (callee_decl is DEFINITION_DECL) {
                BinaryExpression binary = new BinaryExpression();
                binary.NodeType = NodeType.Castclass;
                binary.Operand1 = (Expression)arguments[0].convert();
                // binary.Operand2 = new QualifiedIdentifier(
                //                              Identifier.For(NODE.generateFullName(callee_decl.enclosing)),
                //                              callee_decl.name);
                binary.Operand2 = new MemberBinding(null, (Member)callee_decl.convert());
                // new NameBinding(null,(Member)definition));
                binary.SourceContext = callee.sourceContext;

                node = binary;
                return node;
            } else if (callee_decl is OBJECT_DECL) {
                TypeNode m = ((OBJECT_DECL)callee_decl).node as TypeNode;
                // Convertion
                if (m != null) {
                    TypeNode targetCCIType = (TypeNode)m;


                    if (arguments.Length != 1) {
                        if (arguments.Length == 0)
                            ERROR.MissingParameters(1, callee.sourceContext);
                        else
                            ERROR.ExtraParameters(arguments.Length - 1, callee.sourceContext);

                    }


                    TYPE sourceType = arguments[0].type;

                    if (targetCCIType == null) // an error was detected before...
                        return null;
                    Expression expr = (Expression)arguments[0].convert();
                    BinaryExpression result = new BinaryExpression(expr, new MemberBinding(null, targetCCIType),
                                                                   NodeType.Castclass);
                    result.SourceContext = this.sourceContext;
                    node = result;
                    return node;
                } else {
                    ERROR.SystemErrorIn("CALL.convert", "illegal entity in call");
                    return null;
                }

            } else if (callee_decl is EXTERNAL_DECL) {
                // TODO: what about the case when there are several overloaded
                // external method with different number of parameters???

                Node m = ((EXTERNAL_DECL)callee_decl).entity;
                if (m is Method || m is Property) {
                    Method method = m as Method;
                    if (method != null) {
                        ParameterList pars = method.Parameters;
                        refs = new bool[pars.Length];
                        for (int i = 0, n = pars.Length; i < n; i++)
                            refs[i] = (pars[i].Type is Reference);
                    } else // Hope it's an external property
                    {
                        Property property = m as Property;
                        if (property == null) {
                            ERROR.SystemErrorIn("CALL.convert", "illegal entity in call");
                            return null;
                        }
                        // This is a property; no params.
                        node = callee.convert();
                        return node;
                    }
                } else // Then it might be Conversion
                {
                    if (m is Class) {
                        Class property = m as Class;

                        TypeNode targetCCIType = (TypeNode)m;


                        if (arguments.Length != 1) {
                            if (arguments.Length == 0)
                                ERROR.MissingParameters(1, callee.sourceContext);
                            else
                                ERROR.ExtraParameters(arguments.Length - 1, callee.sourceContext);

                        }


                        TYPE sourceType = arguments[0].type;

                        if (targetCCIType == null) // an error was detected before...
                            return null;
                        Expression expr = (Expression)arguments[0].convert();

                        if (arguments[0].type is ARRAY_TYPE) {
                            MethodCall call_math = new MethodCall();
                            call_math.Operands = new ExpressionList();

                            //////////
                            if (!(arguments[0] is INDEXER)) {
                                call_math.Callee = new MemberBinding(null,
                                    CONTEXT.globalMath.GetElementWiseArrayScalarOp(
                                    ((ARRAY_TYPE)arguments[0].type).dimensions.Length,
                                    ((ARRAY_TYPE)arguments[0].type).base_type.convert() as TypeNode,
                                    null,
                                    targetCCIType as TypeNode,
                                    ((ARRAY_TYPE)arguments[0].type).dimensions.Length,
                                    targetCCIType as TypeNode,
                                    NodeType.Castclass,
                                    null,
                                    this.sourceContext));

                                call_math.Operands.Add(expr);
                                //call_math.Operands.Add(right_operand.convert() as Expression);
                            } else {
                                call_math.Operands.Add(((INDEXER)arguments[0]).left_part.convert() as Expression);
                                //call_math.Operands.Add(right_operand.convert() as Expression);

                                EXPRESSION_LIST indices = ((INDEXER)arguments[0]).indices;
                                for (int i = 0; i < indices.Length; i++) {
                                    if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                                        call_math.Operands.Add(indices[i].convert() as Expression);
                                    } else if (indices[i].type is RANGE_TYPE) {
                                        if (indices[i] is ARRAY_RANGE) {
                                            ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                            call_math.Operands.Add(cur_range.from.convert() as Expression);
                                            call_math.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                            call_math.Operands.Add(cur_range.to.convert() as Expression);
                                            call_math.Operands.Add(cur_range.by.convert() as Expression);
                                        } else //it's range_type variable
                                        {
                                            call_math.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                                STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                            call_math.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                            call_math.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                                STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                            call_math.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                                STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                                        }
                                    } else if (indices[i].type is ARRAY_TYPE) {
                                        call_math.Operands.Add(indices[i].convert() as Expression);
                                    }
                                }

                                call_math.Callee = new MemberBinding(null,
                                    CONTEXT.globalMath.GetElementWiseArrayScalarOp(
                                    ((ARRAY_TYPE)((INDEXER)arguments[0]).left_part.type).dimensions.Length,
                                    ((ARRAY_TYPE)((INDEXER)arguments[0]).left_part.type).base_type.convert() as TypeNode,
                                    ((INDEXER)arguments[0]).indices,
                                    targetCCIType as TypeNode,
                                    ((ARRAY_TYPE)((INDEXER)arguments[0]).left_part.type).dimensions.Length,
                                    targetCCIType as TypeNode,
                                    NodeType.Castclass,
                                    null,
                                    this.sourceContext));
                            }
                            call_math.Type = type.convert() as TypeNode;
                            return call_math;
                            ////////////
                        }

                        BinaryExpression result = new BinaryExpression(expr, new MemberBinding(null, targetCCIType),
                                                                       NodeType.Castclass);
                        result.SourceContext = this.sourceContext;
                        node = result;
                        return node;
                    } else
                        if (m is Struct) {
                            Struct property = m as Struct;

                            TypeNode targetCCIType = (TypeNode)m;


                            if (arguments.Length != 1) {
                                if (arguments.Length == 0)
                                    ERROR.MissingParameters(1, callee.sourceContext);
                                else
                                    ERROR.ExtraParameters(arguments.Length - 1, callee.sourceContext);

                            }


                            TYPE sourceType = arguments[0].type;

                            if (targetCCIType == null) // an error was detected before...
                                return null;
                            Expression expr = (Expression)arguments[0].convert();
                            BinaryExpression result = new BinaryExpression(expr, new MemberBinding(null, targetCCIType),
                                                                           NodeType.Castclass);
                            result.SourceContext = this.sourceContext;
                            node = result;
                            return node;
                        } else
                            if (m is Interface) {
                                Interface property = m as Interface;

                                TypeNode targetCCIType = (TypeNode)m;


                                if (arguments.Length != 1) {
                                    if (arguments.Length == 0)
                                        ERROR.MissingParameters(1, callee.sourceContext);
                                    else
                                        ERROR.ExtraParameters(arguments.Length - 1, callee.sourceContext);

                                }


                                TYPE sourceType = arguments[0].type;

                                if (targetCCIType == null) // an error was detected before...
                                    return null;
                                Expression expr = (Expression)arguments[0].convert();
                                BinaryExpression result = new BinaryExpression(expr, new MemberBinding(null, targetCCIType),
                                                                               NodeType.Castclass);
                                result.SourceContext = this.sourceContext;
                                node = result;
                                return node;
                            } else {
                                ERROR.SystemErrorIn("CALL.convert", "illegal entity in call");
                                return null;
                            }
                }
            }
            else if (callee_decl is PROTOCOL_DECL)
                {
                    TypeNode targetCCIType = ((PROTOCOL_DECL)callee_decl).keywords.type.convert() as TypeNode;

                    TYPE sourceType = arguments[0].type;

                    Expression expr = (Expression)arguments[0].convert();
                    BinaryExpression result = new BinaryExpression(expr, new MemberBinding(null, targetCCIType),
                                                                   NodeType.Castclass);
                    result.SourceContext = this.sourceContext;
                    node = result;
                    return node;

                }
            

            // Otherwise this is a "normal" (user-defined) procedure
            MethodCall call = new MethodCall();

            call.Callee = (Expression)callee.convert();
            if (call.Callee == null)
                return null;

            call.GiveErrorIfSpecialNameMethod = false; // ??
            call.IsTailCall = false;
         // call.NodeType
            call.Operands = new ExpressionList();

            // list of assignments for compute
            List<Statement> stmlist = new List<Statement>();

            for (int i = 0, n = arguments.Length; i < n; i++) {
                // TODO (be): beautify hack
                DECLARATION par = parameters!=null ? parameters[i] : null;  // null for external call
                EXPRESSION  argument = arguments[i];
                if (argument == null)
                    return null;
                Expression arg;
                //if (argument is INSTANCE && par != null) {
                //    arg = argument.name;
                //} else {
                    arg = (Expression)(argument.convert());
                //}

                if (par != null && par is PARAMETER_DECL && ((PARAMETER_DECL)par).Reference) {
                    arg = new UnaryExpression(arg,NodeType.RefAddress);
                    arg.SourceContext = arguments[i].sourceContext;
                    arg.Type = (TypeNode)par.type.convert();
                } else if (refs != null && refs.Length > i /* 0 */ && refs[i]) {
                    TypeNode t = arg.Type;
                    arg = new UnaryExpression(arg,NodeType.RefAddress);
                    arg.SourceContext = arguments[i].sourceContext;
                    arg.Type = t;
                }

                Expression tmparg = null;

                if (CONTEXT.useComputeMath) {
                    ConversionState conversionState = new ConversionState();
                    ConversionResult conversionResult;
                    // if argument is data
                    if (ExpressionConverter.Convert(conversionState, argument, true).TryGetValue(out conversionResult)) {
                        if (argument is INSTANCE) {
                            // quick and dirty trick, I don't want the GetHostArray call
                            if (arg is BinaryExpression && (arg as BinaryExpression).Operand1 is MethodCall) {
                                tmparg = (((arg as BinaryExpression).Operand1 as MethodCall).Callee as MemberBinding).TargetObject;
                            }
                        } else {
                            // convert method
                            tmparg = MethodConverter.Convert(
                                conversionState,
                                conversionResult,
                                new MethodConverter.MethodStruct {
                                    Name = "dummy",
                                    Type = this.type,
                                    KernelSource = ComputeKernelTemplates.ElementWiseCopy,
                                    Func = MethodConverter.ConvertDummy
                                }
                            );
                            // please don't be null
                            System.Diagnostics.Debug.Assert(tmparg != null);
                            // operation converted to method call
                        }
                    }
                }
                call.Operands.Add(tmparg == null ? arg : tmparg);
            }
            call.SourceContext = base.sourceContext;
            call.Type = callee.type==null ? null : (TypeNode)(callee.type).convert();
            
            node = call;
    
            return node;
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("FUN CALL; TYPE={0}; line={1}",type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("CALLEE:");
            if ( callee == null )
                System.Console.WriteLine("MISSED");
            else
                callee.report(shift+2*NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("ARGUMENTS:");
            if ( arguments == null || arguments.Length == 0 )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine(" {0}",arguments.Length);
                for (int i = 0, n = arguments.Length; i < n; i++) {
                    if (arguments[i] == null)
                        continue;
                    arguments[i].report(shift+2*NODE.reportShift);
                }
            }
        }
#endif
        public override string ToString() {
 	         return 
                 (callee != null)? 
                 callee.Name + "(" + arguments.ToString() + ")"
                 :
                 base.ToString();
        }
    }

    // SET_CTOR
    // ========
    // This node represents "set constructor" - the notation for explicit
    // set specification. The construct has the following form:
    //
    //   Set = "{" [ Element { "," Element } ] "}".
    //   Element = Expression [ ".." Expression ].
    //
    public sealed class SET_CTOR : DESIGNATOR {
        // Constructor
        public SET_CTOR()
            : base(ASTNodeType.SET_CTOR) {
            elements = new RANGE_LIST();
            set_internal = 0UL;
        }

        //----------------------------------------------------------------------

        public RANGE_LIST elements;
        public ulong      set_internal;

        protected override bool containsErrorReport() {
            bool oneof = false;
            for (int i = 0; i < elements.Length; i++)
                if (elements[i] != null)
                    oneof |= elements[i].ErrorReported;
            return oneof;
        }

        //----------------------------------------------------------------------

        public override string verbalize   ( ) { return "{}"; }

        //----------------------------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //----------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // Conditions for semanticl correctness:
            //
            // o  All constructor components are of integer type.

            for (int i = 0, n = elements.Length; i < n; i++) {
                RANGE range = elements[i];
                if (range.left_border == null)
                    if (n == 1)
                        continue;
                    else
                        return false;
                if (!range.left_border.validate())
                    return false;
                TYPE t = range.left_border.type;
                if (!(t is INTEGER_TYPE) && !(t is CARDINAL_TYPE)) {
                    string s = "";
                    if ( range.left_border.type != null )
                        s = range.left_border.type.ToString();
                    ERROR.IllegalTypeOf(s,"an element of set constructor",range.left_border.sourceContext);
                    return false;
                }
                if (range.right_border == null)
                    continue;
                if (!range.right_border.validate())
                    return false;
                t = range.right_border.type;
                if (!(t is INTEGER_TYPE) && !(t is CARDINAL_TYPE))
                    return false;
            }
            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates type of the set constructor
        {
            // Type of the set constructor is always SET.
            get {
                if ( internal_type == null ) { internal_type = STANDARD.Set.type; }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //------------------------------------------------------------------

        public override object calculate() {
            // If all components of the set constructor are constants, then
            // it can participate in a constant expression.
            //
            // NO!!!- set constructor CANNOT participate in constant expressions!
            //        Moreover, the algorithm below is conceptually wrong because
            //        it assumes that all ctor elements are _constants_, which is wrong.
            //        The similar algorithm should present in Zonnon run-time; this is
            //        why I didn't erase it from here...

            // NO!!!- the above is right only partially; for some cases it's correct
            //        to have constant set constructor, e.g., CONST sc = { 0..3 };

            if (set_internal != 0)
                return set_internal;

            for (int i = 0, n = elements.Length; i < n; i++) {
                int x1 = 0, x2 = 0;
                RANGE element = elements[i];

                if (element.left_border == null) {
                    type = new SET_TYPE(32);  // set constructor is always of a standard width
                    val = set_internal;
                    return set_internal;
                }
                object v1 = element.left_border.calculate();
                if (v1 == null)
                    return null;

                x1 = (int)((long)v1);
                if (x1 < 0) {
                    ERROR.NegativeConst("in set constructor",element.left_border.sourceContext);
                    return null;
                }
                if (x1 > 31) {
                    ERROR.TooBigSetMember((long)x1,element.sourceContext);
                    return null;
                }

                object v2 = null;
                if (element.right_border != null) {
                    v2 = element.right_border.calculate();
                    if (v2 == null)
                        return null;

                    x2 = (int)((long)v2);
                    if (x2 < 0) {
                        ERROR.NegativeConst("in set constructor",element.right_border.sourceContext);
                        return null;
                    }
                    if (x2 > 31) {
                        ERROR.TooBigSetMember((long)x1,element.sourceContext);
                        return null;
                    }
                }
                if ( element.right_border == null ) // single set element
                {
                    set_internal |= (1U<<x1);
                } else // a range of elements
                {
                    for ( int j=x1; j<=x2; j++ )
                        set_internal |= (1U<<j);
                }
            }
            type = new SET_TYPE(32);  // set constructor is always of a standard width

            val = set_internal;
            return set_internal;
        }

        //----------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            val = calculate();
            if (val != null) {
                node = new Literal(val,SystemTypes.UInt64);
                return node;
            }
            // The result of converting set constructor should be a call
            // to a run-time function which constructs the set and returns
            // its run-time representation.

            MethodCall constructor = new MethodCall();
            constructor.Callee = new MemberBinding(null,STANDARD.Sets.GetMembersNamed(Identifier.For("constructor"))[0]);
            constructor.Callee.SourceContext = this.sourceContext;
            constructor.Operands = new ExpressionList();
            constructor.Operands.Add(new Literal((long)this.sourceContext.StartLine,SystemTypes.Int64));
            constructor.Operands.Add(new Literal(this.sourceContext.StartColumn,SystemTypes.Int32));

            for (int i = 0, n = elements.Length; i < n; i++) {
                RANGE element = elements[i];

                Expression left = (Expression)element.left_border.convert();
                left.SourceContext = element.left_border.sourceContext;

                Expression right = null;

                if (element.right_border == null) {
                    constructor.Operands.Add(left);
                } else {
                    right = (Expression)element.right_border.convert();
                    right.SourceContext = element.right_border.sourceContext;
                    constructor.Operands.Add(new Literal(null,SystemTypes.Object));
                    constructor.Operands.Add(left);
                    constructor.Operands.Add(right);
                }
            }
            node = constructor;
            return node;
        }

        //---------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("SET CTOR; TYPE={0}; line={1}",type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("{ ");
            for (int i = 0, n = elements.Length; i < n; i++) {
                elements[i].report_short();
                if (i < n - 1)
                    System.Console.Write(", ");
            }
            System.Console.WriteLine(" }");
        }
#endif
    }

    // NEW
    // ===
    // For all kinds of NEW operator: both for arrays and objects.
    // The common syntax is as follows:
    //
    // New = "NEW" Type [ "(" Expression { "," Expression } ")" ]
    //
    public sealed class NEW : DESIGNATOR {
        // Constructor
        public NEW ( ) : base(ASTNodeType.NEW) { arguments = new EXPRESSION_LIST(); }

        //--------------------------------------------------------------------------

        public TYPE            resolved_new_type;
        public DESIGNATOR      new_type;
        public EXPRESSION_LIST arguments;

        public ACTIVITY_DECL   activity;  // Needed for 'new Activity(...)'

        protected override bool containsErrorReport() {
            bool oneof = false;
            for (int i = 0; i < arguments.Length; i++)
                if (arguments[i] != null)
                    oneof |= arguments[i].ErrorReported;
            return new_type.ErrorReported || oneof;
        }

        //--------------------------------------------------------------------------

        public override string verbalize ( ) { return "NEW"; /* Make clear */ }

        //--------------------------------------------------------------------------

        public override NODE resolve() {
            if ((resolved_new_type == null) && (new_type != null)) {
                new_type.enclosing = this;
                new_type.resolve();
                resolved_new_type = new_type.type;
            }
            if(resolved_new_type == null){

                if ((new_type is SELECTOR) && ((SELECTOR)new_type).member is EXTERNAL_DECL) {
                    resolved_new_type = new EXTERNAL_TYPE(((SELECTOR)new_type).member.convert());
                } else if ((new_type is INSTANCE) && ((INSTANCE)new_type).entity is EXTERNAL_DECL) {
                    resolved_new_type = new EXTERNAL_TYPE(((INSTANCE)new_type).entity.convert());
                }else{
                    if (!ErrorReported)
                    {
                        if (new_type != null && new_type.full_name != null)
                        {
                            ERROR.NoType(sourceContext, new_type.full_name.ToString());
                    } else {
                            ERROR.NoType(sourceContext, ((new_type != null) && (new_type.name != null)) ? new_type.name.Name : "?");
                        }
                        ErrorReported = true;
                    }
                }
            }
            for ( int i=0, n=arguments.Length; i<n; i++ )
            {
                if ( arguments[i] == null ) continue;
                arguments[i].resolve();
            }
            if (resolved_new_type is ACTIVITY_TYPE) {
                if (getEnclosingBlock() != null)
                    getEnclosingBlock().useBarrier(); // Tell enclosing to generate barrier
            }
            return this;
        }

        //--------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            resolve();
            if (resolved_new_type == null) 
                return false;
            if (!resolved_new_type.validate())
                return false;
            if (resolved_new_type is UNKNOWN_TYPE)
                resolved_new_type = ((UNKNOWN_TYPE)resolved_new_type).real_type;

            if (resolved_new_type is SPARSE_TYPE) {
                for (int i = 0, n = arguments.Length; i < n; i++) {
                    EXPRESSION expression = arguments[i];
                    if (!expression.validate())
                        return false;
                    //TODO! To check arguments' types for all the constructors
                    //if (!(expression.type is INTEGER_TYPE) && !(expression.type is CARDINAL_TYPE))
                    //    return false;
                }

                return true;
            }
            if (resolved_new_type is ARRAY_TYPE) {
                //  o  Type should be an array type;
                //  o  The number of arguments should be less(?) or equal to the array's rank;
                //  o  The type of arguments should be integer.

                if (arguments.Length == 0) {
                    // Extract arguments from the type itself
                    ARRAY_TYPE arr = resolved_new_type as ARRAY_TYPE;
                    for ( int i=0, n=arr.dimensions.Length; i<n; i++ )
                        arguments.Add(arr.dimensions[i]);
                } else {
                    for (int i = 0, n = arguments.Length; i < n; i++) {
                        EXPRESSION expression = arguments[i];
                        if (!expression.validate())
                            return false;
                        if ( !(expression.type is INTEGER_TYPE) && !(expression.type is CARDINAL_TYPE) )
                            return false;
                    }
                }
                return true;
            } else if (resolved_new_type is OBJECT_TYPE) {
                //  o  The number of arguments should be equal to the number of object parameters;
                //  o  Argument types should be assignment-compatible to the object parameters.
                OBJECT_DECL objct = (OBJECT_DECL)((OBJECT_TYPE)resolved_new_type).ObjectUnit;
                if ( objct.paramCount > arguments.Length )
                    ERROR.MissingObjectParameters(objct.paramCount,this.sourceContext);
                else if ( objct.paramCount < arguments.Length )
                    ERROR.ExtraObjectParameters(objct.paramCount,this.sourceContext);

                if (objct.paramCount != arguments.Length)
                    return false;

                bool err = false;
                for (int i = 0, n = objct.paramCount; i < n; i++) {
                    DECLARATION par = objct.locals[i];
                    if (par is IMPORT_DECL) { n++; continue; }
                    EXPRESSION arg = this.arguments[i - (n - objct.paramCount)];
                    EXPRESSION result = TYPE.AssignmentCompatibility(par.type,arg.type,arg,arg.sourceContext, false);
                    if ( result == null ) { err = true; continue; }  // Compatibility error was detected
                    // Replace right_part for the new sub-tree!
                    arguments[i - (n - objct.paramCount)] = result;
                }
                return !err;
            } else if (resolved_new_type is EXTERNAL_TYPE) {
                // No checks for now... Let CCI check the correctness.
                return true;
            } else if (resolved_new_type is INTERFACE_TYPE) {
                // This can be only OBJECT
                return ((INTERFACE_TYPE)resolved_new_type).interfaces.Length == 0;
            } else if (resolved_new_type is PROC_TYPE) {
                //  o  There should be only one argument in the argument list;
                //  o  This argument should be of a procedure type;
                //  o  This procedure type should be assignment compatible with the new_type.
                if (arguments.Length != 1)
                    return false;

                NODE proc = arguments[0].resolve();
                if (!(proc is PROCEDURE_DECL))
                    return false;

                return TYPE.sameProcType((PROC_TYPE)resolved_new_type, (PROCEDURE_DECL)proc);
            } else if (resolved_new_type is ACTIVITY_TYPE) {
                //  o  The number of arguments should be equal to the number of activity parameters;
                //  o  Argument types should be assignment-compatible to the activity parameters.
                ACTIVITY_DECL activity = (ACTIVITY_DECL)((ACTIVITY_TYPE)resolved_new_type).activity;
                if ( activity.paramCount > arguments.Length )
                    ERROR.MissingActivityParameters(activity.paramCount,this.sourceContext);
                else if ( activity.paramCount < arguments.Length )
                    ERROR.ExtraActivityParameters(activity.paramCount,this.sourceContext);

                if (activity.paramCount != arguments.Length)
                    return false;

                bool err = false;
                for (int i = 0, n = activity.paramCount; i < n; i++) {
                    DECLARATION par = activity.parameters[i];
                    EXPRESSION  arg = this.arguments[i];
                    EXPRESSION result = TYPE.AssignmentCompatibility(par.type,arg.type,arg,arg.sourceContext, false);
                    if ( result == null ) { err = true; continue; }  // Compatibility error was detected
                    // Replace right_part for the new sub-tree!
                    arguments[i] = result;
                }
                return !err;
            } else {
                ERROR.IllegalTypeInNew(this.sourceContext);
            }
            return false;
        }
        //---------------------------------------------------------------------

        public override TYPE type  // evaluates type of new operator
        {
            // Type of the new operator is always 'new_type'.
            get {
                if (internal_type == null || internal_type is UNKNOWN_TYPE) {
                    internal_type = resolved_new_type;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //------------------------------------------------------------------

        public override object calculate ( ) { return null; }
        // It's always impossible for new operator to participate in constant expressions.

        //------------------------------------------------------------------

        public override Node convert() {
            bool DelegateCase = false;
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            if (resolved_new_type is ARRAY_TYPE) {
                ARRAY_TYPE array = resolved_new_type as ARRAY_TYPE;
                if (!array.isOpen) {
                    ERROR.NonOpenArray(array.ToString(), sourceContext);
                    ErrorReported = true;
                    return null;
                }
                node = array.getConstructionCall(arguments, sourceContext);
                return node;
            }

            if (resolved_new_type is SPARSE_TYPE) {
                SPARSE_TYPE sparse = resolved_new_type as SPARSE_TYPE;
                node = sparse.getConstructionCall(arguments);
                return node;
            }

            if (resolved_new_type is OBJECT_TYPE) {
                Construct construct = new Construct();

                DECLARATION objct = ((OBJECT_TYPE)resolved_new_type).ObjectUnit;

                Struct s = objct.convert() as Struct;
                if (s != null) {   // Prohibit using our fictive constructor
                    InstanceInitializer ctr = s.GetConstructors()[0] as InstanceInitializer;
                    if ((ctr.Parameters.Length == 1) && (ctr.Parameters[0].Name.Name.CompareTo("_fict") == 0)) {
                        ERROR.NoNeedForCallingNewForValueType(sourceContext);
                        ErrorReported = true;
                        return null;
                    }
                }

                // Strange thing: CCI expects _class_ in Construst.Constructor,
                // but not a constructor itself!..
             // construct.Constructor = new MemberBinding(null,((TypeNode)objct.convert()).GetConstructors()[0]); //  NODE.convertTypeName(objct);
                construct.Constructor = new MemberBinding(null,(TypeNode)objct.convert());
                construct.Constructor.Type = SystemTypes.Type;

                construct.Operands = new ExpressionList();
                construct.SourceContext = this.sourceContext;
                construct.Type = (TypeNode)objct.convert();

                if ( objct.modifiers.Value )
                    construct.Operands.Add(new Literal(1,SystemTypes.Int32));
                else
                    for ( int i=0, n=arguments.Length; i<n; i++ )
                        construct.Operands.Add((Expression)arguments[i].convert());

            //  BinaryExpression result = new BinaryExpression();
            //  result.NodeType = NodeType.Castclass;
            //  result.Operand1 = construct;
            //  result.Operand2 = new MemberBinding(null,(TypeNode)objct.convert());
            //  result.SourceContext = this.sourceContext;

                node = construct;  // result
                return node;
            }

            if (resolved_new_type is EXTERNAL_TYPE) {
                Node nn = ((EXTERNAL_TYPE)resolved_new_type).entity;
                TypeNode t = nn as TypeNode;
                if (t == null) {
                    ERROR.SystemErrorIn("NEW.convert","illegal 'entity' "+nn.ToString());
                    return null;
                }

                if (t is DelegateNode) {
                    DelegateCase = true;
                } else {
                    Struct s = t as Struct;
                    if (s != null) {   // Prohibit using our fictive constructor
                        InstanceInitializer ctr =s.GetConstructors()[0] as InstanceInitializer;
                        if ((ctr.Parameters.Length == 1) && (ctr.Parameters[0].Name.Name.CompareTo("_fict") == 0)) {
                            ERROR.NoNeedForCallingNewForValueType(sourceContext);
                            return null;
                        }
                    }
                    Construct construct = new Construct();

                //  MemberList ctors = t.GetConstructors();
                //  Member     ctor = null;
                //  for ( int i=0, n=ctors.Length; i<n; i++ )
                //  {
                //      InstanceInitializer init = (InstanceInitializer)ctors[i];
                //      if ( init.Parameters.Length == arguments.Length )
                //      {
                //          ctor = ctors[i];
                //          break;
                //      }
                //  }

                    Member ctor = null;
                    TypeNode[] types = new TypeNode[arguments.Length];
                    for (int i = 0, n = arguments.Length; i < n; i++) {
                        TYPE tt = arguments[i].type;
                        if (tt == null)
                            continue;
                     // {
                     //     ERROR.SystemErrorIn("NEW.convert","null type of argument "+i);
                     //     continue;
                     // }
                        Node tnode = tt.convert();
                        if (tnode is TypeNode)
                            types[i] = (TypeNode)tnode;
                        else {
                            ERROR.NotImplemented("Problem #081806-01"); //types[i] = null; //(tnode as Method);
                            return null;
                        }
                    }
                    
                    // ctor = t.GetConstructor(types);
                    // - this method doesn't really work because
                    // it looks for exact types, but
                    // we can have byte instead of integer etc.
                    
                    MemberList ctors = t.GetConstructors();
                    //Start searching for the right one
                    //types contains list of out types
                    
                    foreach (InstanceInitializer cons in ctors) {
                        // Test if we can use cons. If yes assign it to ctor
                        TypeNode[] ctypes = cons.GetParameterTypes();
                        // Compare ctypes with types
                        if (types.Length != ctypes.Length)
                            continue; // Doesn't match
                        bool err = false;
                        for (int i = 0; i < types.Length; i++) {
                            bool err2 = false;
                            bool errArray2 = false;
                            bool isMathAndNotMathCompatible = false;
                            EXPRESSION result = TYPE.AssignmentCompatibilityInternal(ref err2, ref errArray2, new EXTERNAL_TYPE(ctypes[i]), new EXTERNAL_TYPE(types[i]), arguments[i],
                                isMathAndNotMathCompatible);
                            if (err2
                                //!types[i].IsAssignableTo(ctypes[i]) - doesn't work for us
                                
                                ) {
                                err = true;
                                break;
                            }
                        }
                        if (!err) { // Match!!!
                            ctor = cons;
                            break;
                        }
                    }


                    if (ctor == null) {
                        // Either no ctors with a given number of pars,
                        // or parameters do not match...

                        // 1) Take all ctors and search for the one with a given
                        //    number of parameters. If there is one then issue
                        //    the message about illegal parameter type(s).
                        for (int i = 0, n = ctors.Length; i < n; i++) {
                            if (((InstanceInitializer)ctors[i]).Parameters.Length == arguments.Length) {
                                string expected = "";
                                // Create helpful error message with all options
                                foreach (InstanceInitializer cons in ctors) {
                                    expected += "\n" + cons.ToString();
                                }
                                ERROR.WrongConstructorParams(t.Name.Name,expected,this.sourceContext);
                                return null;
                            }
                        }
                        // 2) If there were no ctors with a given number of parameters,
                        //    then issue the message about the wrong number of pars.
                        ERROR.WrongConstructor(t.Name.Name,arguments.Length,this.sourceContext);
                        return null;
                    }

                    // Strange thing: CCI expects _class_ in Construst.Constructor,
                    // but not a constructor itself!.. Here this means that
                    // the information about the constructor (ctor variable)
                    // is not necessary for CCI and hence is lost...
              //    construct.Constructor = new MemberBinding(null,ctor);
                    construct.Constructor = new MemberBinding(null,t);
                    construct.Constructor.Type = SystemTypes.Type;

                    construct.Operands = new ExpressionList();
                    construct.SourceContext = this.sourceContext;
              //    construct.Type = t;

                    for ( int i=0, n=arguments.Length; i<n; i++ )
                        construct.Operands.Add((Expression)arguments[i].convert());

                 // BinaryExpression result = new BinaryExpression();
                 // result.NodeType = NodeType.Castclass;
                 // result.Operand1 = construct;
                 // result.Operand2 = new MemberBinding(null,t);
                 // result.SourceContext = this.sourceContext;

                    node = construct; // result;
                    return node;
                }
            }

            if (resolved_new_type is PROC_TYPE || DelegateCase) {
                // You should pass in a MemberBinding as the target object.
                // The Type field of the MemberBinding should be SystemTypes.Type and the bound
                // member should be the type that defines the method that implements the delegate.
                //       - Herman Venter.
                
                EXPRESSION arg = arguments[0];

                NODE n = arguments[0].resolve();
                if (!(n is PROCEDURE_DECL)) {
                    if (n.type is PROC_TYPE && DelegateCase)
                        ERROR.DelegateWithProcType(n.ToString(), arg.sourceContext);
                    else
                        ERROR.DelegateWrongArg(n.ToString(), arg.sourceContext);

                    return null;
                }

                PROCEDURE_DECL proc = (PROCEDURE_DECL)n;
                TypeNode t = (TypeNode)proc.enclosing.convert();

                Expression target = null;

                if (arg is SELECTOR) {
                    NODE targetx = (arg as SELECTOR).left_part.resolve();
                    Node tx = targetx.convert();
                    if (tx is Field)
                        target = ((Field)tx).Name;
                    else
                        target = t.Name;
                } else {
                    target = t.Name;
                }

                

                // Here I _violate_ Herman's recommendation (see above)!
                // Method Looker.VisitMemberBinding _always_loses_ 'TargetObject' information
                // if MemberBinding's Type field contains _a_ type (replacing the entire node
                // for Literal). So I had to create another kind of node (just Identifier)
                // for target object.
                //
                // The second point was that I set Identifier's "type" field by the type
                // of the method's class - NOT as the type of the identifier itself!-
                // because Resolver.VisitConstructDelegate takes the method's class
                // just from this field...

                ConstructDelegate delg = new ConstructDelegate();
                delg.DelegateType = (TypeNode)resolved_new_type.convert();

                delg.MethodName = proc.name;
                delg.SourceContext = arguments[0].sourceContext;

/*                if ( arg is SELECTOR )
                {
                    NODE decl = ((SELECTOR)arg).left_part.resolve();
                    NODE memb = ((SELECTOR)arg).member.resolve();
                    if ( decl is VARIABLE_DECL )
                    {
                     // target = ((VARIABLE_DECL)decl).name;
                        Node l = ((VARIABLE_DECL)decl).convert();
                        Node m = memb.convert();

                        if ( decl.enclosing is MODULE_DECL )
                        {
                         // MemberBinding owner = new MemberBinding(null,(TypeNode)decl.enclosing.convert());
                         // owner.Type = SystemTypes.Type;
                         // target = new MemberBinding(owner,(Field)l);
                         // QualifiedIdentifier qid = new QualifiedIdentifier();
                         // qid.Qualifier = new MemberBinding(null,(TypeNode)decl.enclosing.convert());
                         // qid.Qualifier.Type = SystemTypes.Type;
                         // qid.Identifier = decl.name;
                         // qid.Type = 
                         // target = qid;

                         // target = ((VARIABLE_DECL)decl).name;
                            target = new MemberBinding(null,(Field)l);
                        }
                        else
                            target = new MemberBinding(new This(),(Field)l);
                    }
                }  
  ***/



             // MemberBinding mb = new MemberBinding(target,t);
             // mb.Type = SystemTypes.Type;
                delg.TargetObject = target; //mb;

                node = delg;
                return node;
            }

            if (resolved_new_type is ACTIVITY_TYPE) {
                // new A(actuals) ==> A(barrier).send(act1). ... .send(actn);

                string barrier_name = "_barrier" + getEnclosingBlock().useBarrier();

                MethodCall call = new MethodCall(); 
                activity = (ACTIVITY_DECL)((ACTIVITY_TYPE)resolved_new_type).activity;
                call.Callee = (Expression)new_type.convert();
                call.Operands = new ExpressionList(1);
                if (getEnclosingBlock().useBarrier() == 0)
                    call.Operands.Add(new Literal(null,SystemTypes.Object));
                else
                    call.Operands.Add(Identifier.For(barrier_name));
                call.Type = (TypeNode)STANDARD.protocol.type.convert();

                int n = this.arguments.Length;
                if (n > 0) {

                    for (int i = 0; i < n; i++) {
                        QualifiedIdentifier qual = new QualifiedIdentifier();
                        qual.Qualifier = call;
                        qual.Identifier = Identifier.For("send");

                        call = new MethodCall();
                        call.Callee = qual;
                        call.Operands = new ExpressionList(1);
                            
                            PARAMETER_DECL par = (PARAMETER_DECL)activity.parameters[i];
                            EXPRESSION     arg = arguments[i];

                            BinaryExpression cast = new BinaryExpression();
                            cast.Operand1 = (Expression)arg.convert();
                            cast.Operand2 = new MemberBinding(null,(TypeNode)par.type.convert());
                            cast.Operand2.Type = SystemTypes.Type;
                            cast.NodeType = NodeType.Castclass;
                            
                        call.Operands.Add(cast);
                        call.Type = (TypeNode)STANDARD.protocol.type.convert();
                    }
                }
                node = call;

             // Obsolete generation
             //
             // ROUTINE_DECL activity = ((ACTIVITY_TYPE)new_type).activity;
             // Construct construct = new Construct();
             // construct.Constructor = NODE.convertTypeName(activity);
             // construct.Constructor.Type = (TypeNode)activity.convert();
             // construct.Operands = new ExpressionList();
             //
             // node = construct;

                return node;
            }
         // else  -- some other type
         // {
         //     Nothing to do: the error message has been issued
         //     in validate() function (see above).
         // }
            return node;
        }

        //------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("NEW; TYPE={0}, line={1}",type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("TYPE:");
            if (new_type == null) {
                doShift(shift+2*NODE.reportShift);
                System.Console.WriteLine("MISSED");
            } else
                new_type.report(shift+2*NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("ARGUMENTS:");
            if ( arguments == null || arguments.Length == 0 )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine(" {0}",arguments.Length);
                for ( int i=0, n=arguments.Length; i<n; i++ )
                    arguments[i].report(shift+2*NODE.reportShift);
            }
        }
#endif
    }

    // SELF
    // ====
    //
    //
    public sealed class SELF : DESIGNATOR {
        // Constructor
        public SELF ( ) : base(ASTNodeType.SELF) { }

        //--------------------------------------------------------------------------

        public OBJECT_TYPE this_object;
        public UNIT_DECL   this_unit;

        //--------------------------------------------------------------------------

        public static SELF create() {
            UNIT_DECL current = CONTEXT.current_unit;  // cannot be null?

            //  No restrictions on THIS
            //  if ( current == null || ( !(current is OBJECT_DECL) && !(current is IMPLEMENTATION_DECL) ) )
            //  {
            //      ERROR.WrongThis();
            //      return null;
            //  }
            SELF this_entity = new SELF();

            //  this_entity.enclosing = current;
            //  if ( current is OBJECT_DECL )
            //      this_entity.this_object = (OBJECT_TYPE)(((OBJECT_DECL)current).type);
            //  else // IMPLEMENTATION_DECL; what to do???
            //      this_entity.this_object = null; // ???????

            this_entity.this_unit = current;
            if ( current is OBJECT_DECL )
                this_entity.type = ((OBJECT_DECL)current).type;
        ///    else
        //        ERROR.NotImplemented("SELF outside an object is");

            return this_entity;
        }

        //--------------------------------------------------------------------------

        public override string verbalize ( ) { return "SELF"; }

        //--------------------------------------------------------------------------

        public override NODE resolve() {
            if ( this_unit != null ) { this_unit.resolve(); return this_unit; }
            return this;
        }

        //--------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (this_unit == null)
                return false;
            // Can be used in objects and modules but not implementation
            // (it's more an implementation restriction then language,
            //  but so it is).
            if (this.getEnclosingUnit() is IMPLEMENTATION_DECL) {
                ERROR.NotImplemented(sourceContext, "'self' in implementation declaration is");
                return false;
            }

            if (this_unit.validate())
                return true;
            return false;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates type of this
        {
            get {
             // if ( internal_type == null ) { internal_type = this_object.type; }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //------------------------------------------------------------------

        public override object calculate ( ) { return null; }
        // It's always impossible for this to participate in constant expressions.

        //------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            if (this_unit is MODULE_DECL) {
                ImplicitThis CCIimplicit = new ImplicitThis();
                CCIimplicit.SourceContext = base.sourceContext;
                node = CCIimplicit;
            } else {
                This CCIthis = new This();
                CCIthis.SourceContext = base.sourceContext;
                node = CCIthis;
            }
            return node;
        }
        
        //------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("SELF; TYPE={0}; line={1}",type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();
        }
#endif
    }

    // SELF
    // ====
    //
    //
    public sealed class OBJECT : DESIGNATOR {
        // Constructor
        public OBJECT() : base(ASTNodeType.OBJECT) { name = new Identifier("object"); }

        //--------------------------------------------------------------------------

        public static OBJECT create() {

            OBJECT entity = new OBJECT();
            return entity;
        }

        //--------------------------------------------------------------------------

        public override string verbalize() { return "object"; }

        //--------------------------------------------------------------------------

        public override NODE resolve() {
            return STANDARD.Object;
        }

        //--------------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates type of this
        {
            get {
                return STANDARD.Object.type;
            }
            set {
                /* do nothing */
            }
        }

        //------------------------------------------------------------------

        public override object calculate() { return null; }
        // It's always impossible for this to participate in constant expressions.

        //------------------------------------------------------------------

        public override Node convert() {
            return SystemTypes.Object;
        }

        //------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("SELF; TYPE={0}; line={1}", type != null ? type.ToString() : "NULL", this.sourceContext.StartLine.ToString());
            report_extra();
        }
#endif
    }

    // INSTANCE
    // ========
    // For all cases of _using_ named entities, both declared and undeclared.
    //
    public sealed class INSTANCE : DESIGNATOR {
        // If instance is resolved (i.e., refers to a known entity)
        // then 'entity' field refers to the valid declaration of that entity
        // (i.e., to a DECLARATION node).
        // Otherwise, 'entity' field refers to an UNKNOWN_DECL node.
        // Example:
        //
        // MODULE m1;
        //    IMPORT m2;
        // BEGIN
        //    m2.x := 7;  -- Here m2 is UNKNOWN_DECL
        //    ...
        //
        // Notice also that if INSTANCE is unresolved it cannot resolve itself:
        // Only an "owner" of this node can resolve it (perhaps, using some
        // information only known by that "owner").

        // Constructors
        public INSTANCE(DECLARATION entity)
            : base(ASTNodeType.INSTANCE) {
            this.entity = entity;
			//if (entity.type is UNKNOWN_TYPE)
			if (entity is UNKNOWN_DECL)
				this.originalName = NODE.generateFullName(entity);
			else
				originalName = "";
         // this.sourceContext = Parser.LEXAN.getSourceContext(); --already done in ctor
        }

		public string originalName;
        public static INSTANCE create(DECLARATION entity) {
            if (entity == null) return new INSTANCE(UNKNOWN_DECL.create(Identifier.For("null"), CONTEXT.globalTree));
            INSTANCE instance = new INSTANCE(entity);

            if (entity.enclosing == CONTEXT.globalTree)
                instance.properlyImported = false;
            if (entity is UNIT_DECL) {
                IMPORT_DECL imported_by = ((UNIT_DECL)entity).imported_by;
                if ( imported_by != null && imported_by.enclosing == CONTEXT.current_unit )
                    instance.properlyImported = true;
            }

            return instance;
        }

        //-------------------------------------------------------------------------------------

        public DECLARATION entity;

        public override string ToString() {
            return "<" + base.ASTNodeType.ToString() + " name = \"" + Name + "\""+ " type = \"" + type.ToString() + "\"/>";
        }        

        protected override bool containsErrorReport() {
            return entity.ErrorReported;
        }

        //--------------------------------------------------------------------------

        public override string verbalize ( ) { return entity.name.Name; }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            entity = (DECLARATION)entity.resolve();
            if (name == null)
                name = entity.name;
            if (Name == "#unused")
                return entity;
            if (entity is UNKNOWN_DECL && !entity.ErrorReported && !CONTEXT.firstPass) {
                ERROR.UndeclaredLocal(entity.name.Name,this.sourceContext);                
                entity.ErrorReported = true;
            }
            modifiers = entity.modifiers;
            return entity;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (this.entity is FIELD_DECL && (this.entity.type is ACTIVITY_TYPE || this.entity.type is ABSTRACT_ACTIVITY_TYPE) &&
                (this.getEnclosingDeclaration() is ACTIVITY_DECL || this.getEnclosingDeclaration() is PROCEDURE_DECL))
            {
                if(!ErrorReported) ERROR.ActivityVariableIsNotLocal(sourceContext, Name, entity.getEnclosingUnit().Name);
                ErrorReported = true;
            }
            return entity.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates instance type
        {
            // By definition, type of the instance is the type of the entity it refers to.
            get {
                if (internal_type == null || internal_type is UNKNOWN_TYPE) {
                    internal_type = entity.type;
                }
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates constant expressions
        {
            if (val != null)
                return val;

            DECLARATION ent = entity;

         Calculate:

            if (ent is CONSTANT_DECL) {
                val = ((CONSTANT_DECL)ent).initializer.calculate();
            } else if (ent is ENUMERATOR_DECL) {
                val = ((ENUMERATOR_DECL)ent).val;
            } else if (ent is UNKNOWN_DECL) {
                ent = ((UNKNOWN_DECL)ent).RealDeclaration;
                goto Calculate;
            } else
                val = null;

            return val;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            if (entity is CONSTANT_DECL) {
                // Similar as for SELECTOR: for constants we directly use their values
                node = ((CONSTANT_DECL)entity).initializer.convert();
                return node;
            }
            if (entity is EXTERNAL_DECL) {
                return ((EXTERNAL_DECL)entity).convert();
                // either Identifier (for namespaces), or TypeNode (for classes)
            }
            if (entity is OPERATOR_DECL) {
                OPERATOR_DECL op = entity as OPERATOR_DECL;
                Expression target = new MemberBinding(null, (Member)entity.enclosing.convert());
                target.Type = SystemTypes.Type;
                QualifiedIdentifier qid = new QualifiedIdentifier();
                qid.Qualifier = target;
                qid.Identifier = entity.name;
                qid.SourceContext = this.sourceContext;
                qid.Type = (TypeNode)entity.type.convert();
                qid.Identifier.Type = qid.Type;
                node = qid;
                return node;
            }
            if (entity is PROCEDURE_DECL) {
                PROCEDURE_DECL proc = entity as PROCEDURE_DECL;
                Expression target = null;

                if (entity.enclosing is MODULE_DECL) {
                    target = new MemberBinding(null,(Member)entity.enclosing.convert());
                    target.Type = SystemTypes.Type;
                } else if (entity.enclosing is IMPLEMENTATION_DECL && CONTEXT.current_unit is MODULE_DECL) {
                    UNIT_DECL definition = ((IMPLEMENTATION_DECL)entity.enclosing).implemented_definition;
                    NODE proc_in_def = definition.find(entity.name);
                    if (proc_in_def == null) {
                        // This is a special case: module uses a procedure from implementation 
                        // which is _not_ in the corresponding definition:
                        //
                        //    definition A; 
                        //    end A.
                        //
                        //    implementation A;
                        //        procedure { public } P; ... end P;
                        //    end A.
                        //
                        //    module M implements A;
                        //    begin
                        //        P;  (* NO access to P: it is not in the definition *)
                        //    end M.
                        //
                        // It seems to be against of Zonnon's spirit...

                        // Cannot access to this procedure because it is not in the definition
                        ERROR.IllegalProcAccess(entity.name.Name,entity.enclosing.name.Name,
                                                this.sourceContext);
                        this.ErrorReported = true;
                        return null;
                    } else
                        // This is the case when a module implements a procedure
                        // from a definition...
                        target = new MemberBinding(null,(Member)CONTEXT.current_unit.convert());
                } else if (entity.enclosing is DEFINITION_DECL && CONTEXT.current_unit is MODULE_DECL) {
                    // Module implements definotion
                    // This definition contains procedure
                    // Module calls this procedure
                    target = new MemberBinding(null, (Member)CONTEXT.current_unit.convert());
                    target.Type = SystemTypes.Type;
                } else
                    target = new This();

                QualifiedIdentifier qid = new QualifiedIdentifier();
                qid.Qualifier = target;
                qid.Identifier = entity.name;
                qid.SourceContext = this.sourceContext;

                if (entity.modifiers.Getter || entity.modifiers.Setter) {
                    // 'entity' is a property: we should generate
                    // MemberBinding targeted not at the procedure itself
                    // but at the corresponding property.
                    if ( proc.paramCount == 0 )
                        qid.Type = (TypeNode)proc.return_type.convert();
                    else
                        qid.Type = (TypeNode)proc.parameters[0].type.convert();

                    // For this case we just issue 'id' instead of
                    // this.id. If we generate this.id then we get
                    // a strange error message...
                    Identifier id = Identifier.For(entity.name.Name);
                    id.Type = qid.Type;
                    node = id;
                    return id;
                } else {
                    // Otherwise - a normal procedure
                    qid.Type = (TypeNode)entity.type.convert();
                }
                qid.Identifier.Type = qid.Type;
                node = qid;
                return node;
            }

            if (entity is OBJECT_DECL) {
                TYPE t = ((OBJECT_DECL)entity).type;
                node = t.convert();
                node.SourceContext = this.sourceContext;
                return node;
            }

            if (entity is LOCAL_DECL || entity is PARAMETER_DECL) {
                TypeNode convertedType = (TypeNode)entity.type.convert();
                Identifier id = entity.name;
                id.Type = convertedType;
                id.SourceContext = this.sourceContext;
                if (CONTEXT.useComputeMath && ComputeType.FromType(entity.type).HasValue) {
                    node = new BinaryExpression {
                        NodeType = NodeType.Castclass,
                        Operand2 = new MemberBinding {
                            BoundMember = convertedType,
                        },
                        Operand1 = new MethodCall {
                            Callee = new MemberBinding {
                                TargetObject = id,
                                /* TODO -- this can be a burden sometimes */
                                BoundMember = STANDARD.Data.GetMethod(Identifier.For("GetHostArray")),
                            },
                        }
                    };
                } else {
                node = id;
            }
            } else // FIELD_DECL or ACTIVITY_DECL
            {
                QualifiedIdentifier qid = null;
                Member member = null;
                
                //if (entity is FIELD_DECL) {
                //    ARRAY_TYPE entityArrayType = entity.type as ARRAY_TYPE;
                //    if (entityArrayType != null && entityArrayType.isMath) {
                //        // id will be data. lift it into GetHostArray call
                //        ComputeType mathType;
                //        if (ConversionHelper.GetMathType(entityArrayType.base_type).TryGetValue(out mathType)) {
                //            node = new BinaryExpression {
                //                NodeType = NodeType.Castclass,
                //                Operand2 = new MemberBinding {
                //                    BoundMember = mathType.ScalarType.TypeNode.GetArrayType(entityArrayType.dimensions.Length),
                //                },
                //                Operand1 = new MethodCall {
                //                    Callee = new MemberBinding {
                //                        TargetObject = new MemberBinding {
                //                            BoundMember = (Member)entity.convert(),
                //                        },
                //                        BoundMember = STANDARD.Data.GetMethod(Identifier.For("GetHostArray")),
                //                    },
                //                }
                //            };
                //            return node;
                //        }
                //    }
                //}
                if (entity is ACTIVITY_DECL) {
                    entity.convert();
                    member = (entity as ACTIVITY_DECL).node1;
                } else
                    member = (Member)entity.convert();

                if (member == null)
                    return null; // occurs for nested procedures

                if ( entity.enclosing is MODULE_DECL ) // module member - static
                {
                    MemberBinding target = new MemberBinding(null,(Member)entity.enclosing.convert());
                    target.Type = SystemTypes.Type;

                    qid = new QualifiedIdentifier(target,member.Name);
                } else if (entity.enclosing is DEFINITION_DECL &&
                    (CONTEXT.current_unit.modifiers.Value == false) // For value types inteface casts do not apply
                    ) 
                    // definition member is always implemented as property
                {                    

                    if (CONTEXT.current_unit is MODULE_DECL) {
                        qid = new QualifiedIdentifier();
                        // // We treat the variable i from definition D
                        // // as follows:
                        // //                D.i
                        //
                        // qid.Qualifier = new MemberBinding(null,(Member)entity.enclosing.convert());
                        // qid.Qualifier.Type = SystemTypes.Type;

                        Identifier id = entity.name;
                        id.Type = (TypeNode)entity.type.convert();
                        id.SourceContext = this.sourceContext;
                        node = id;
                        return node;
                    } else  // object or implementation
                    {
                        // We treat the variable i from definition D 
                        // as follows:
                        //                ((D)this).i

                        if (CONTEXT.current_unit is IMPLEMENTATION_DECL) {
                            node = new Identifier(member.Name + "_default");
                        } else {
                            qid = new QualifiedIdentifier();
                            qid.Identifier = member.Name;
                            BinaryExpression cast = new BinaryExpression();
                            cast.Operand1 = new This();
                            cast.Operand2 = new MemberBinding(null, (Member)entity.enclosing.convert());
                            cast.Operand2.Type = SystemTypes.Type;
                            cast.NodeType = NodeType.Castclass;
                            qid.Qualifier = cast;
                            qid.Type = (TypeNode)entity.type.convert();
                            qid.SourceContext = this.sourceContext;
                            node = qid;
                        }
                    }
                    
                    return node;
                } else  // object or implementation member - nonstatic
                {
                    qid = new QualifiedIdentifier(new This(),entity.name); // member.Name);

                    if (entity is PROCEDURE_DECL) {
                        PROCEDURE_DECL procedure = entity as PROCEDURE_DECL;
                        if (procedure.prototype != null && procedure.prototype is FIELD_DECL) {
                            qid.Type = (TypeNode)procedure.prototype.type.convert();
                            qid.Identifier.Type = qid.Type;
                        }
                    } 
                }
                if ( qid.Type == null && (entity != null) && (entity.type != null)) qid.Type = (TypeNode)entity.type.convert();
                qid.SourceContext = this.sourceContext;
                node = qid;
            }
            return node;
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            // NODE.doShift(shift);
            report_unique(shift);

            System.Console.Write("INSTANCE OF ");
            entity.report_short();
            System.Console.WriteLine("; TYPE={0}",type!=null?type.ToString():"NULL");
        }
#endif
    }

    //===================================================================================
    // 3.4 LITERALS
    //===================================================================================

    // LITERAL
    // =======
    // Common class for all kinds of Zonnon literals.
    //
    public abstract class LITERAL : DESIGNATOR {
        // Constructor
        public LITERAL ( ASTNodeType astNodeType  ) : base(astNodeType) { }

        public abstract override NODE resolve ( );
        public abstract override bool validate ( );
        public abstract override TYPE type { get; set; }
        public abstract override object calculate ( );
        public abstract override Node convert ( );

        //-------------------------------------------------------

        public static Literal create(object val, TYPE type, SourceContext sourceContext) {
            TypeNode t = null;
            if (type is ENUM_TYPE)
                t = SystemTypes.Int64;
            else if (type is CHAR_TYPE){
                if (((CHAR_TYPE)type).width == 8)
                    t = SystemTypes.UInt8;
                else
                    t = SystemTypes.Char;                
            } else
                t = (TypeNode)type.convert();
            
            Literal lit = null;
            long maxvalue = 0, minvalue = 0;
            double dmaxvalue = 0.0;
			// Actually otherwise it works wrong 			
            if (t == SystemTypes.Int8) { lit = new Literal((sbyte)(long)val, SystemTypes.Int8); maxvalue = System.SByte.MaxValue; minvalue = System.SByte.MinValue; }
            if (t == SystemTypes.Int16) { lit = new Literal((short)(long)val, SystemTypes.Int16); maxvalue = System.Int16.MaxValue; minvalue = System.Int16.MinValue; }
            if (t == SystemTypes.Int32) { lit = new Literal((int)(long)val, SystemTypes.Int32); maxvalue = System.Int32.MaxValue; minvalue = System.Int32.MinValue; }
            if (t == SystemTypes.Int64) { lit = new Literal((long)val, SystemTypes.Int64); maxvalue = System.Int64.MaxValue; minvalue = System.Int64.MinValue; }

            if (t == SystemTypes.UInt8) { lit = new Literal((byte)(long)val, SystemTypes.UInt8); maxvalue = System.Byte.MaxValue; minvalue = System.Byte.MinValue; }
            if (t == SystemTypes.UInt16) { lit = new Literal((ushort)(long)val, SystemTypes.UInt16); maxvalue = System.UInt16.MaxValue; minvalue = System.UInt16.MinValue; }
            if (t == SystemTypes.UInt32) { lit = new Literal((uint)(long)val, SystemTypes.UInt32); maxvalue = System.UInt32.MaxValue; minvalue = System.UInt32.MinValue; }
            if (t == SystemTypes.UInt64) { lit = new Literal((val is long)?(ulong)(long)val:(ulong)val, SystemTypes.UInt64); }

            if (t == SystemTypes.Single) { lit = new Literal((float)(double)val, SystemTypes.Single); dmaxvalue = System.SByte.MaxValue; }
            if (t == SystemTypes.Double) { lit = new Literal((double)val, SystemTypes.Double); dmaxvalue = System.SByte.MaxValue; }
            if (t == SystemTypes.Decimal) { lit = new Literal((decimal)(double)val, SystemTypes.Decimal); dmaxvalue = System.SByte.MaxValue; }
            
            if (t == SystemTypes.Char) { lit = new Literal((char)val, SystemTypes.Char);  }

            if (t == SystemTypes.String) { lit = new Literal((string)val, SystemTypes.String); }

            if (maxvalue != 0) {
                if((((long)val) > maxvalue) || (((long)val) < minvalue))
                    ERROR.ConstantComputationOverflow(sourceContext);
            }
            if (dmaxvalue > 0.0) {
                if ((((double)val) > dmaxvalue))
                    ERROR.ConstantComputationOverflow(sourceContext);
            }
            if (lit == null)
                ERROR.NotImplemented("please report to developers. Error in LITERAL.create. Feature");
            return lit;

        }

        //-------------------------------------------------------

        public override string verbalize ( ) { return ""; }
        
#if DEBUG
        public abstract override void report ( int shift );
#endif
    }

    // ENUMERATOR
    // ==========
    // For constants of an enumeration type:
    //
    // TYPE e = ( one, two, three );
    // VAR x : e;
    //  ...
    // x := e.one;  // e.one is just the enumerator
    //
    public sealed class ENUMERATOR : LITERAL {
        // Constructor
        public ENUMERATOR ( ) : base(ASTNodeType.ENUMERATOR) { }

        //-------------------------------------------------------------------------------------

        public ENUMERATOR_DECL enumerator;

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            enumerator = (ENUMERATOR_DECL)(enumerator.resolve());
            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            return enumerator.validate();
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates enumerator's type
        {
            // By definition, type of the enumerator is the conaining enumeration type of the entity it refers to.
            get {
                if (internal_type == null)
                    internal_type = enumerator.type;
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates constant expressions
        {
            return enumerator.val;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;


            return node;
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("{0}={1}; TYPE={3}",enumerator.name,enumerator.val,
                type!=null?type.ToString():"NULL");
            report_extra();
        }
#endif
    }

    // STRING_LITERAL
    // ==============
    //
    public sealed class STRING_LITERAL : LITERAL {
        // Constructor
        public STRING_LITERAL ( ) : base(ASTNodeType.STRING_LITERAL) { }

        //-------------------------------------------------------------------------------------

        public string str;

        //-------------------------------------------------------------------------------------

        public static STRING_LITERAL create(string str) {
            STRING_LITERAL String = new STRING_LITERAL();
            // String.enclosing
            // String.modifiers
            // String.name
            // String.operator_kind
            // String.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor
            // String.type
            String.str = "";
            for ( int i=0, n=str.Length; i<n; i++ )
                String.str += str[i];

            return String;
        }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates string's type
        {
            // By definition, type of the string is STRING_TYPE.
            get {
                if (internal_type == null)
                    internal_type = STANDARD.String.type;
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates constant expressions
        {
            return str;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            // resolve();
            // if ( !validate() ) return null;

            node = new Literal(str,SystemTypes.String,base.sourceContext);            
            return node;
        }

        //-------------------------------------------------------------------------------------

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("STRING LITERAL \"{0}\"; TYPE={1}; line={2}",str,type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();
        }
#endif
    }

    // CHAR_LITERAL
    // ============
    // This node is never created during parsing.
    // It is created during tree analyzing, when we have an assignment
    // like
    //         c := 'a';
    //
    // Here we replace original STRING_LITERAL node with semantically
    // equivalent CHAR_LITERAL node. See TYPE.AssignmentCompatible().
    //
    public sealed class CHAR_LITERAL : LITERAL {
        // Constructor
        public CHAR_LITERAL ( ) : base(ASTNodeType.CHAR_LITERAL) { }

        //-------------------------------------------------------------------------------------

        public char ch;

        //-------------------------------------------------------------------------------------

        public static CHAR_LITERAL create(char ch) {
            return CHAR_LITERAL.create(ch,16);
        }

        public static CHAR_LITERAL create(char ch, long width) {
            CHAR_LITERAL Char = new CHAR_LITERAL();
            // Char.enclosing
            // Char.modifiers
            // Char.name
            // Char.operator_kind
            // Char.sourceContext = -- already done in ctor
            Char.ch = ch;

            if (width == 16)
                Char.type = STANDARD.Char.type;
            else
                Char.type = new CHAR_TYPE(width);

            return Char;
        }

        public static CHAR_LITERAL create(char ch, SourceContext context) {
            CHAR_LITERAL Char = CHAR_LITERAL.create(ch);
            Char.sourceContext = context;
            return Char;
        }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates string's type
        {
            // By definition, type of the character literal is CHAR.
            // The default width is 16.
            get {
                if (internal_type == null)
                    internal_type = STANDARD.Char.type;
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates constant expressions
        {
            return ch;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            // resolve();
            // if ( !validate() ) return null;

            long width = ((CHAR_TYPE)type).width;
            TypeNode t;
            Object   v;

            if (width <= 8) { t = SystemTypes.UInt8; v = (byte)ch; } else if (width <= 16) { t = SystemTypes.Char; v = (char)ch; } else {
                t = SystemTypes.Char;
                v = (char)ch;
                ERROR.MaxTypeSize("CHAR", "16", this.sourceContext);
            }

            node = new Literal(v,t,base.sourceContext);
            return node;
        }

        //-------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("CHARACTER LITERAL \'{0}\'; TYPE={1}; line={2}",ch,type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();
        }
#endif
    }

    // INTEGER_LITERAL
    // ===============
    //
    public sealed class INTEGER_LITERAL : LITERAL {
        // Constructor
        public INTEGER_LITERAL ( ) : base(ASTNodeType.INTEGER_LITERAL) { }

        //-------------------------------------------------------------------------------------

        public long integer;

        //-------------------------------------------------------------------------------------

        public static INTEGER_LITERAL create(long number) {
            return INTEGER_LITERAL.create(number,32);
        }

        public static INTEGER_LITERAL create(long number, int width) {
            INTEGER_LITERAL result = new INTEGER_LITERAL();

         // result.enclosing
            result.modifiers = null;
            result.name = null;
         // result.operator_kind

            if (width == 32) {
                // Standard integer type with default width
                // result.type = STANDARD.Integer.type;
                result.type = number>=0 ? STANDARD.Cardinal.type : STANDARD.Integer.type;
            } else if (width == -1) {
                long pos = number>=0 ? number : - number;

                // Integer type with non-specified width;
                // Calculate the minimal possible width for the given literal.
                if (pos <= sbyte.MaxValue)
                    width = 8;
                else if (pos <= short.MaxValue)
                    width = 16;
                else if (pos <= int.MaxValue)
                    width = 32;
                else
                    width = 64;
            }
            if (number >= 0)
//                result.type = new CARDINAL_TYPE(width);//(Math.Max(8, width / 2)); /It was (width - 1)
                result.type = new CARDINAL_TYPE(width-1);//reverted PDR 20120522
            else
                result.type = new INTEGER_TYPE(width);

            result.integer = number;
         // result.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor

            return result;
        }

        //-------------------------------------------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //-------------------------------------------------------------------------------------

        public override bool validate ( ) { return true; }  // checks semantical correctness

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates literal's type
        {
            // By definition, type of the integer literal is integer.
            get {
                if (internal_type == null)
                    internal_type = STANDARD.Integer.type;
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates constant expressions
        {
            return integer;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

         // resolve();
         // if ( !validate() ) return null;

            long width;
            if (type is CARDINAL_TYPE)
                width = ((CARDINAL_TYPE)type).width;
            else
                width = ((INTEGER_TYPE)type).width;

            TypeNode t = SystemTypes.Int64;
            object   v = (long)integer;

            bool signed = (integer < 0) || (estimatedType != null && estimatedType is INTEGER_TYPE);

            if (width > 64) {
                ERROR.MaxTypeSize("'integer'","64",this.sourceContext); 
             // t = SystemTypes.Int64; v = (long)integer;  -- using default values (see declarations above)
            }
            // TODO: Think about unsigned int            
            else if (!signed) {
                if (width <= 8) { t = SystemTypes.UInt8; v = (byte)integer; } else if (width <= 16) { t = SystemTypes.UInt16; v = (ushort)integer; } else if (width <= 32) { t = SystemTypes.UInt32; v = (uint)integer; } else if (width <= 64) { t = SystemTypes.UInt64; v = (ulong)integer; }
            } else // integer < 0
            {
                if (width <= 8) { t = SystemTypes.Int8; v = (byte)integer; } else if (width <= 16) { t = SystemTypes.Int16; v = (short)integer; } else if (width <= 32) { t = SystemTypes.Int32; v = (int)integer; } else if (width <= 64) { t = SystemTypes.Int64; v = (long)integer; }
            }
            node = new Literal(v,t,base.sourceContext);
            return node;
        }

        //-------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);

            System.Console.Write("INTEGER LITERAL {0}",integer);
            if ( type is INTEGER_TYPE )
                System.Console.Write(" width {0}",((INTEGER_TYPE)type).width);
            System.Console.Write("; TYPE={0}",type!=null?type.ToString():"NULL");
            // else // for MIN, MAX, SIZE
            //     -- nothing
            report_extra();
        }
#endif
    }

    // REAL_LITERAL
    // ============
    //
    public sealed class REAL_LITERAL : LITERAL {
        // Constructor
        public REAL_LITERAL ( ) : base(ASTNodeType.REAL_LITERAL) { }

        //-------------------------------------------------------------------------------------

        public double real;

        //-------------------------------------------------------------------------------------

        public static REAL_LITERAL create(double number) {
            REAL_LITERAL result = new REAL_LITERAL();
            return result;
        }

        public static REAL_LITERAL create(double number, int width) {
            REAL_LITERAL result = new REAL_LITERAL();
            
            result.real = number;
            
            if (width == -1)
                width = 64; //Double
            
            if (width == 64) {
                // Standard real type with default width
                result.type = STANDARD.Real.type;
            } else {

                result.type = new REAL_TYPE(width);
            }
         // result.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor

            return result;
        }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates literal's type
        {
            // By definition, type of the real literal is real.
            get {
                if (internal_type == null)
                    internal_type = STANDARD.Real.type;
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates constant expressions
        {
            return real;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            // resolve();
            // if ( !validate() ) return null;

            long width = ((REAL_TYPE)type).width;
     //     TypeNode t;
     //     object   v;
     // 
     //     if      ( width <= 32 ) { t = SystemTypes.Single;  v = (float)real;   } // Float is of w.32
     //     else if ( width <= 64 ) { t = SystemTypes.Double;  v = (double)real;  } // Double is of w.64
     //  // else if ( width <= 96 ) { t = SystemTypes.Decimal; v = (decimal)real; } // Decimal is of w.96
     //     else if ( width <= 96 ) { t = SystemTypes.Double;  v = (double)real; }  // Decimal is of w.96
     //     else
     //     {
     //      // t = SystemTypes.Decimal; v = (decimal)real;
     //         t = SystemTypes.Double;  v = (double)real;
     //         ERROR.MaxTypeSize("REAL","96",this.sourceContext); }
     //
     //     node = new Literal(v,t,base.sourceContext);
            // If the enclosing type (or if englosing is an assignment then the target type is wider then
            // the typr of the constant then we enlarge the constant size
            if (width > 128)
                ERROR.MaxTypeSize("real", "128", this.sourceContext);
            if (width <= 32)
                node = new Literal((float)real, SystemTypes.Single, this.sourceContext);
            else if (width <= 64)
                node = new Literal((double)real, SystemTypes.Double, this.sourceContext);
            else
                node = new Literal((decimal)real, SystemTypes.Decimal, this.sourceContext);
            return node;
        }

        //-------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("REAL LITERAL {0} width {1}; TYPE={2}; line={3}",real,((REAL_TYPE)type).width,
                type!=null?type.ToString():"NULL", this.sourceContext.StartLine.ToString());
            report_extra();
        }
#endif
    }

    // CCI_LITERAL
    // ===========
    //
    public sealed class CCI_LITERAL : LITERAL {
        // Constructor
        public CCI_LITERAL ( ) : base(ASTNodeType.CCI_LITERAL) { }

        //-------------------------------------------------------------------------------------

        public System.Compiler.Literal literal;

        //-------------------------------------------------------------------------------------

        public static CCI_LITERAL create(TYPE typ, System.Compiler.Literal literal) {
            CCI_LITERAL result = new CCI_LITERAL();

            result.literal = literal;
         // result.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor
            result.internal_type = typ;

            return result;
        }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates literal's type
        {
            // "Our" type of CCI literal is always given by 'create' method.
            get { return internal_type; }
            set { internal_type = value; }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates constant expressions
        {
            return literal.Value;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

         // resolve();
         // if ( !validate() ) return null;

            node = literal;
            return node;
        }

        //-------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("CCI LITERAL {0}",literal.Value);
            report_extra();
        }
#endif
    }

    // NULL
    // ====
    //
    public sealed class NULL : LITERAL {
        // Constructor
        public NULL ( ) :base(ASTNodeType.NULL) { }

        //-------------------------------------------------------------------------------------

        public static NULL create() {
            NULL nil = new NULL();
         // nil.enclosing
         // nil.modifiers
         // nil.name
         // nil.operator_kind
         // nil.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor
         // nil.type

            return nil;
        }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates literal's type
        {
            // By definition, type of the null literal is object.
            get {
                if (internal_type == null)
                    internal_type = STANDARD.Object.type;
                return internal_type;
            }
            set {
                internal_type = value;
            }
        }

        //--------------------------------------------------------------------------------------

        public override object calculate ( )  // calculates constant expressions
        {
            return null;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

         // resolve();
         // if ( !validate() ) return null;

            node = new Literal(null,SystemTypes.Object,base.sourceContext);
            return node;
        }

        //-------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("NIL; TYPE={0}",type!=null?type.ToString():"NULL");
            report_extra();
        }
#endif
    }

    //=============================================================================
    // 4 STATEMENTS
    //=============================================================================

    public abstract class STATEMENT : NODE {
        // Constructor
        public STATEMENT ( ASTNodeType astNodeType) : base(astNodeType, null) { }

        public abstract override NODE resolve ( );
        public abstract override bool validate ( );
        public abstract override TYPE type { get; set; }
        public abstract override Node convert ( );
#if DEBUG
        public abstract override void report ( int shift );
#endif
        // finalize
        // --------
        // Common final actions after parsing the statement
        // from a statement sequence.
        //
        public void finalize(NODE enclosing) {
            // Set up common attributes.
            this.enclosing = enclosing; // Default
            this.name = null;
         // statement.sourceContext

            // Now determine the kind of enclosing unit/procedure/statement
            // and adding the statement to it.
            if      ( enclosing is UNIT_DECL )  { ((UNIT_DECL)enclosing).body.statements.Add(this);
                                                  ((UNIT_DECL)enclosing).body.sourceContext = this.sourceContext;
                                                  this.enclosing = ((UNIT_DECL)enclosing).body;
                                                }
            else if (enclosing is BLOCK)
                                                {
                                                    ((BLOCK)enclosing).statements.Add(this);
                                                }
            else if (enclosing is CYCLE) { ((CYCLE)enclosing).statements.Add(this); }
            else if (enclosing is EXCEPTION) { ((EXCEPTION)enclosing).statements.Add(this); }
            else if (enclosing is ROUTINE_DECL)
            {
                ((ROUTINE_DECL)enclosing).body.statements.Add(this);
                ((ROUTINE_DECL)enclosing).body.sourceContext = this.sourceContext;
                this.enclosing = ((ROUTINE_DECL)enclosing).body;
            }
            else if (enclosing is IF_PAIR) { ((IF_PAIR)enclosing).statements.Add(this); }
            else if (enclosing is CASE_ITEM) { ((CASE_ITEM)enclosing).Add(this); }
            // else if ( enclosing is LAUNCH )     { ((LAUNCH)enclosing).statement = this; }
              else {
                // Something's wrong
                ERROR.SystemErrorIn("finalize", "wrong enclosing node");
            }
        }
    }

    // ASSIGNMENT
    // ==========
    //
    public sealed class ASSIGNMENT : STATEMENT {
        // Constructor
        public ASSIGNMENT() : base(ASTNodeType.ASSIGNMENT) { opType = NodeType.Nop; ovlOp = null; }
        NodeType opType; //operation for IsMath operations with arrays
        QualifiedIdentifier ovlOp;

        //--------------------------------------------------

        public DESIGNATOR receiver;
        public EXPRESSION right_part;

        public CALL call;

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            if(receiver != null) scope = receiver.findScopeAtContext(line, col, documentName);
            if (scope == null && right_part != null) scope = right_part.findScopeAtContext(line, col, documentName);
            return scope;
        }

        //--------------------------------------------------

        public static ASSIGNMENT create() {
            ASSIGNMENT assignment = new ASSIGNMENT();
            
            assignment.enclosing = null;
            assignment.modifiers = null;
            assignment.name = null;

            assignment.receiver = null;
            assignment.right_part = null;
         // assignment.sourceContext

            return assignment;
        }

        public void finalize(NODE enclosing, EXPRESSION designator, EXPRESSION right) {
            if (designator == null)
                return;

            designator.enclosing = this;

            this.receiver = (DESIGNATOR)designator;
            this.right_part = right;

            this.receiver.enclosing = this;
            if (this.right_part == null)
                return; // can be null because of parsing errors
            this.right_part.enclosing = this;

            // Semantic processing (types etc.)

            base.finalize(enclosing);
        }

        //--------------------------------------------------

        public override NODE resolve() {
            if (receiver is INDEXER)
                ((INDEXER)receiver).write = true;
            receiver.resolve();
            right_part.resolve();

            if (!CONTEXT.firstPass) {
                bool doNotResolve = false;
                
                // For the following cases do not look for overloaded assignments
                //  "new" operaor on the right hand
                if (right_part is NEW) doNotResolve = true;
                
                // Indexer on the left side with overloaded Set method that can accept right side
                if (receiver is INDEXER)
                {
                    INDEXER irec = (INDEXER)receiver;
                    if (TYPE.AssignmentCompatibilityS(irec.type, right_part.type)) doNotResolve = true;
                }

                if (! doNotResolve)
                {
                    ASSIGNMENT_OPERATOR tmp = new ASSIGNMENT_OPERATOR(":=");
                    tmp.left_operand = receiver;
                    tmp.right_operand = right_part;

                    NODE call = tmp.resolveOperator();
                    if (call is CALL)
                        this.call = (CALL)call;

                    if (right_part.type is ABSTRACT_ACTIVITY_TYPE || right_part.type is ACTIVITY_TYPE) {
                        if (!(receiver.type is ABSTRACT_ACTIVITY_TYPE) && !(receiver.type is ACTIVITY_TYPE)) {
                            // Reconfigure this node to SEND_RECEIVE
                            EXPRESSION_LIST left = new EXPRESSION_LIST();
                            left.Add(receiver);

                            SEND_RECEIVE sr = SEND_RECEIVE.create(left, right_part);
                            sr.enclosing = this.enclosing;
                            sr.sourceContext = this.sourceContext;

                            return sr;
                        }
                    }
                }
            }
            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            NODE l = receiver.resolve();
            if (l is CONSTANT_DECL) {
                ERROR.AssignToConstant(l.name.Name,receiver.sourceContext);
                return false;
            } else if (l is VARIABLE_DECL || l is INDEXER) {
                if (l is INDEXER)
                    l = ((INDEXER)l).left_part;
                if (l is SELECTOR)
                    l = ((SELECTOR)l).member;
                if (l != null && l.modifiers.Immutable) {
                    NODE scope = l.getEnclosingUnit();
                    if (scope != CONTEXT.current_unit) {
                        ERROR.ModifyImmutable(l.name.Name,receiver.sourceContext);
                        return false;
                    }
                 // else
                 //     -- It's OK; going on
                }
            } else if (l is PROCEDURE_DECL) {
                // 'l' can be an accessor. We should check this,
                // and then check if the property really has 'set' accessor.
                PROCEDURE_DECL proc = l as PROCEDURE_DECL;
                if (proc.modifiers.Getter) {
                    // This is 'get' accessor which is not suitable.
                    // We should check if there is a 'set' accessor.
                    NODE setter = ((UNIT_DECL)proc.enclosing).find_setter(proc.name);
                    if (setter != null) {
                        PROCEDURE_DECL setter_proc = setter as PROCEDURE_DECL;
                        // We should replace 'receiver' for the setter we have just found.
                        receiver = INSTANCE.create(setter_proc);
                        // The setter's signature has been already checked...

                        // the final check: setter's parameter should be of a type
                        // which is compatible with the type of the right part.
                        EXPRESSION res = TYPE.AssignmentCompatibility(setter_proc.parameters[0].type,
                                                                      right_part.type,right_part,this.sourceContext, false);
                        if (res == null)
                            return false;
                        // Replace right_part for the new sub-tree!
                        right_part = res;
                        return true;
                    } else {
                        ERROR.AssignToProc(proc.name.Name,receiver.sourceContext);
                        return false;
                    }
                } else if (proc.modifiers.Setter)
                    // This is really an accessor, and it's suitable here.
                {
                    // Nothing to do.
                    return true;
                } else {
                    ERROR.AssignToProc(proc.name.Name,receiver.sourceContext);
                    return false;
                }
            } else if (l is EXTERNAL_DECL) {
                // It's OK; further checks will be performed...
            } else {
                ERROR.WrongAssignmentLeft(receiver.sourceContext);
                return false;
            }

            bool res1 = receiver.validate();
            bool res2 = right_part.validate();

            
            // The message should be issued before. In case it didn't happen and
            // no messages were given it means a compiler problem
            // To prevent success issue this wierd message.
            if (!res1) {
                if (!receiver.ErrorReported) {
                    ERROR.WrongAssignmentLeft(sourceContext); // TODO: change the error
                }
                this.ErrorReported = true;
                return false;
            }
            if (!res2) {
                if (!right_part.ErrorReported) {
                    ERROR.WrongAssignmentRight(sourceContext); // TODO: change the error
                }
                this.ErrorReported = true;
                return false;
            }
            
            //#region compute math
            //{
            //    // allowing assignment to/from math type only if base type(s) are equal
            //    //Boolean correct;
            //    //if (MATH_TYPE.IsAnyMathType(receiver.type, right_part.type, out correct)) {
            //    //    return correct;
            //    //}
            //    MATH_TYPE receiverMathType;
            //    MATH_TYPE rightMathType;
            //    Boolean receiverIsMathType = receiver.type.Is(out receiverMathType);
            //    Boolean rightIsMathType = right_part.type.Is(out rightMathType);
            //    if (receiverIsMathType) {
            //        if (rightIsMathType) {
            //            if (!TYPE.sameType(receiverMathType.BaseType, rightMathType.BaseType)) {
            //                ERROR.AssignmentCompatibility(receiverMathType.ToString(), rightMathType.ToString(), sourceContext);
            //                ErrorReported = true;
            //                return false;
            //            } else {
            //                return true;
            //            }
            //        } else {
            //            if (!TYPE.sameType(receiverMathType.BaseType, right_part.type)) {
            //                ERROR.AssignmentCompatibility(receiverMathType.BaseType.ToString(), right_part.type.ToString(), sourceContext);
            //                ErrorReported = true;
            //                return false;
            //            } else {
            //                return true;
            //            }
            //        }
            //    } else if (rightIsMathType) {
            //        if (!TYPE.sameType(receiver.type, rightMathType.BaseType)) {
            //            ERROR.AssignmentCompatibility(receiver.type.ToString(), rightMathType.BaseType.ToString(), sourceContext);
            //            ErrorReported = true;
            //            return false;
            //        } else if (!(receiver is INSTANCE)) {
            //            ERROR.AssignMathExpressionToNonMath(sourceContext);
            //            ErrorReported = true;
            //            return false;
            //        } else {
            //            return true;
            //        }
            //    }
            //}
            //#endregion

            TYPE left_type = receiver.type;

            //if ((receiver is INDEXER) && (((INDEXER)receiver).calls != null))
            //    left_type = ((INDEXER)receiver).calls.Set.parameters[((INDEXER)receiver).calls.Set.paramCount - 1].type;
            
            //Exclude assigining to external delegates
            if ((left_type is EXTERNAL_TYPE) && ((EXTERNAL_TYPE)left_type).entity.NodeType == NodeType.DelegateNode) {
                // TODO: write checks here (arguments, etc)
            } else {
                TYPE right_type = right_part.type;
                if (right_type is UNKNOWN_TYPE)
                    right_type = right_type.resolve() as TYPE;

                //I think we don't need the following twice commented code
                ////if (receiver is INDEXER)
                ////{
                ////    INDEXER indexer = receiver as INDEXER;
                ////    bool range = false;
                ////    for (int i = 0; i < indexer.indices.Length; i++)
                ////    {
                ////        if (indexer.indices[i] is ARRAY_RANGE)
                ////        {
                ////            range = true;
                ////            break;
                ////        }
                ////    }
                ////    //TODO : better validation
                ////    if (range) return true;
                ////}

                // Temporary check; this should not occur if predefined procs are well implemented
                if (left_type == null) {
                    ERROR.WrongAssignmentLeft(this.sourceContext);
                    return false;
                }
                // Temporary check; this should not occur if predefined procs are well implemented
                if ((right_type == null) && (right_part != null) && !right_part.ErrorReported) {
                    if (right_part.full_name != null) {
                        ERROR.UnknownType(this.sourceContext, right_part.full_name.ToString());
                    } else {
                        ERROR.WrongAssignmentRight(this.sourceContext);
                    }
                    return false;
                }
                // Two types should be "assignment compatible"...
                EXPRESSION result = TYPE.AssignmentCompatibility(left_type, right_type, right_part, this.sourceContext, true);
                if (result == null)
                    return false;
                if ((right_type is ACTIVITY_TYPE || right_type is ABSTRACT_ACTIVITY_TYPE) && !(right_part is NEW))
                {// Creating an alias for channel is forbidden
                    if(!ErrorReported) ERROR.AliasActivityReference(sourceContext);
                    ErrorReported = true;
                }
                // Here we'll check if receiver is property defined and definition and if we're inside implementation
                // then in case of read only property we allow assign it.
                if ((receiver is INSTANCE) && (receiver.modifiers.Getter) && (!receiver.modifiers.Setter)) {
                    NODE encl = this.enclosing;
                    while (!(encl is IMPLEMENTATION_DECL) && (encl != null))
                        encl = encl.enclosing;
                    IMPLEMENTATION_DECL impl = encl as IMPLEMENTATION_DECL;
                    if (impl == null) {
                        ERROR.PropertyIsReadOnly(((INSTANCE)receiver).entity.name.Name, sourceContext);
                        return false;
                    }
                }
                // Replace right_part for the new sub-tree!
                right_part = result;
            }
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type  // evaluates assignment's type
        {
            // By definition, type of assignment statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //--------------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            // If assignment overloading then just generate the call
            // should be generated. For indexers of build-in arrays we keep normal call.
            if (call != null) {
                // unless the target is an overloaded indexer where a method call
                if (((receiver is INDEXER) && 
                    (((INDEXER)receiver).left_part.type.convert().NodeType != NodeType.ArrayTypeExpression) &&
                    (((INDEXER)receiver).left_part.type.convert().NodeType != NodeType.ArrayType) &&
                    (((INDEXER)receiver).left_part.type.convert().NodeType != NodeType.Array)
                    )) {

                    // Create a temprorary variable for the right part
                    /*
                       node[i] := R;
                       compiled into
                       {
                     *   typeof(node[i]) temp = node[i];
                     *   assign(&temp, R);
                     *   node.Set(i, &temp);
                     * }
                     */
                    Block block = new Block();
                    block.Statements = new StatementList();
                    
                    // typeof(node[i]) temp = node[i];
                    LocalDeclarationsStatement loc_stmt = new LocalDeclarationsStatement();
                    loc_stmt.Constant = false;
                    loc_stmt.Declarations = new LocalDeclarationList(1);
                    loc_stmt.InitOnly = false;
                    loc_stmt.SourceContext = this.sourceContext;
                    loc_stmt.Type = ((ETH.Zonnon.INDEXER)(receiver)).type.convert() as TypeNode;
                    loc_stmt.TypeExpression = loc_stmt.Type;
              
                    LocalDeclaration local = new LocalDeclaration();
                    local.InitialValue = receiver.convert().Clone() as Expression;
                    local.Name = Identifier.For("temp");
                    local.SourceContext = this.sourceContext;
                    loc_stmt.Declarations.Add(local);
                    
                    block.Statements.Add(loc_stmt);

                    // assign(&temp, R);
                    MethodCall scall = new MethodCall();
                    scall.Callee = call.callee.convert() as Expression;
                    scall.Operands = new ExpressionList();
                    scall.Operands.Add(new UnaryExpression(Identifier.For("temp"), NodeType.RefAddress, sourceContext));
                    scall.Operands.Add(right_part.convert() as Expression);
                    scall.SourceContext = sourceContext;
                    scall.Type = SystemTypes.Void;
                    block.Statements.Add(new ExpressionStatement(scall,sourceContext));

                    // node.Set(i, &temp);
                    // It can be either call or CCI processed call (normal assignmnet)
                    if (receiver is INDEXER && (receiver as INDEXER).calls != null) {   // We should generate call
                        INDEXER indexer = receiver as INDEXER;
                        PROCEDURE_DECL calee = (receiver as INDEXER).calls.Set; // What to call

                        MethodCall invoke = new MethodCall();
                        Node target = ((INDEXER)receiver).left_part.convert();
                        Node member = calee.convert();

                        invoke.Callee = new MemberBinding(target as Expression, member as Member);
                        invoke.GiveErrorIfSpecialNameMethod = false; // ??

                        invoke.IsTailCall = false;

                        invoke.Operands = new ExpressionList(indexer.indices.Length + 1);
                        for (int i = 0; i < indexer.indices.Length; i++)
                            invoke.Operands.Add(indexer.indices[i].convert() as Expression);
                        invoke.Operands.Add(Identifier.For("temp"));
                        invoke.SourceContext = this.sourceContext;
                        invoke.Type = SystemTypes.Void;
                        ExpressionStatement pcall = new ExpressionStatement(invoke, this.sourceContext);
                        block.Statements.Add(pcall);
                    } else {
                        AssignmentStatement asgn = new AssignmentStatement();
                        asgn.NodeType = NodeType.AssignmentStatement;
                        asgn.Operator = NodeType.Nop; 
                        asgn.Source = Identifier.For("temp");
                        asgn.Target = receiver.convert() as Expression;
                        
                        block.Statements.Add(asgn);
                    }
                    return block;
                } else {
                    node = call.convert();

                    ExpressionStatement expr = new ExpressionStatement();
                    expr.Expression = (Expression)node;
                    // expr.NodeType
                    expr.SourceContext = this.sourceContext;
                    node = expr;

                    return node;
                }
            }

            if (node != null)
                return node;

            NODE resolved = resolve();
            if (resolved is SEND_RECEIVE) {
                node = resolved.convert();
                return node;
            }

            if (!validate())
                return null;

            if (receiver == null)
                return null;
            if (right_part == null)
                return null;

            #region compute math
            if (CONTEXT.useComputeMath) {
                INDEXER indexer;
                INSTANCE receiverInstance;
                if (receiver.Is(out indexer)) {
                    receiverInstance = indexer.left_part as INSTANCE;
                } else {
                    receiverInstance = receiver as INSTANCE;
                }
                if (receiverInstance != null) {
                    ComputeType receiverComputeType;
                    if (ComputeType.FromType(receiverInstance.type).TryGetValue(out receiverComputeType)) {
                        // receiver will be Data
                        ConversionState conversionState = new ConversionState();
                        ConversionResult conversionResult;
                        if (ExpressionConverter.Convert(conversionState, right_part, false, true).TryGetValue(out conversionResult)) {
                            /*
                             * new OperationX(arg1, arg2, ..., ref receiver);
                             */
                            node = AssignmentConverter.Convert(conversionState, conversionResult, receiverInstance.name, receiverComputeType, indexer);
                            if (node != null) {
                                return node;
                            }
                        } else if (indexer == null) {
                            /* 
                             * receiver = (
                             *     Array __right = [right_part.convert()];
                             *     Data __result = [receiver];
                             *     if (__right == null) {
                             *         throw new InvalidOperationException();
                             *     } else {
                             *         if (__result != null) {
                             *             UInt64[] __dimensions = ComputeHelper.GetDimensions(__right);
                             *             if(!ComputeHelper.AreDimensionsEqual(__dimensions, __result.GetDimensions())) {
                             *                 throw new InvalidOperationException();
                             *             }
                             *             Buffer.BlockCopy(__right, 0, __result.GetHostArray(), 0, Buffer.ByteLength(__right));
                             *         } else {
                             *             #if right_part.type is NEW
                             *                 __result = new Data(__right);
                             *             #else
                             *                 __result = new Data((Array)__right.Clone());
                             *             #endif
                             *         }
                             *     }
                             *     __result;
                             * );
                             */

                            #region generate code
                            Identifier rightIdentifier = Identifier.For("__right");
                            Identifier resultIdentifier = Identifier.For("__result");
                            Identifier dimensionsIdentifier = Identifier.For("__dimensions");

                            Expression dataConstructorArgument;
                            if (right_part is NEW) {
                                dataConstructorArgument = rightIdentifier;
                            } else {
                                // right_part is not NEW - might be aliased
                                dataConstructorArgument = new BinaryExpression {
                                    NodeType = NodeType.Castclass,
                                    Operand1 = new MethodCall {
                                        Callee = new MemberBinding {
                                            TargetObject = rightIdentifier,
                                            BoundMember = SystemTypes.Array.GetMethod(Identifier.For("Clone")),
                                        }
                                    },
                                    Operand2 = new MemberBinding {
                                        BoundMember = SystemTypes.Array,
                                    }
                                };
                            }

                            node = new AssignmentStatement {
                                Target = receiverInstance.name,
                                Source = new BlockExpression {
                                    Block = new Block {
                                        Statements = new StatementList(
                                            new VariableDeclaration {
                                                Name = rightIdentifier,
                                                Type = SystemTypes.Array,
                                                Initializer = (Expression)right_part.convert(),
                                            },
                                            new VariableDeclaration {
                                                Name = resultIdentifier,
                                                Type = STANDARD.Data,
                                                Initializer = receiverInstance.name,
                                            },
                                            new If {
                                                Condition = new BinaryExpression(rightIdentifier, Literal.Null, NodeType.Eq),
                                                TrueBlock = new Block {
                                                    Statements = new StatementList(
                                                        NodeHelper.GetThrowFor(SystemTypes.InvalidOperationException)
                                                    ),
                                                },
                                                FalseBlock = new Block {
                                                    Statements = new StatementList(
                                                        new If {
                                                            Condition = new BinaryExpression(resultIdentifier, Literal.Null, NodeType.Ne),
                                                            TrueBlock = new Block {
                                                                Statements = new StatementList(
                                                                    new VariableDeclaration {
                                                                        Name = dimensionsIdentifier,
                                                                        Type = SystemTypes.UInt64.GetArrayType(1),
                                                                        Initializer = new MethodCall {
                                                                            Callee = new MemberBinding {
                                                                                BoundMember = STANDARD.ComputeHelper.GetMethod(Identifier.For("GetDimensions"), SystemTypes.Array)
                                                                            },
                                                                            Operands = new ExpressionList(rightIdentifier),
                                                                        },
                                                                    },
                                                                    NodeHelper.GetThrowIfDimensionsNotEqual(dimensionsIdentifier, new MethodCall {
                                                                        Callee = new MemberBinding {
                                                                            TargetObject = resultIdentifier,
                                                                            BoundMember = STANDARD.Data.GetMethod(Identifier.For("GetDimensions")),
                                                                        }
                                                                    }),
                                                                    new ExpressionStatement {
                                                                        Expression = new MethodCall {
                                                                            Callee = new MemberBinding {
                                                                                BoundMember = STANDARD.SystemBuffer.GetMembersNamed(Identifier.For("BlockCopy"))[0],
                                                                            },
                                                                            Operands = new ExpressionList(
                                                                                rightIdentifier,
                                                                                Literal.Int32Zero,
                                                                                new MethodCall {
                                                                                    Callee = new MemberBinding {
                                                                                        TargetObject = resultIdentifier,
                                                                                        BoundMember = STANDARD.Data.GetMethod(Identifier.For("GetHostArray")),
                                                                                    }
                                                                                },
                                                                                Literal.Int32Zero,
                                                                                new MethodCall {
                                                                                    Callee = new MemberBinding {
                                                                                        BoundMember = STANDARD.SystemBuffer.GetMembersNamed(Identifier.For("ByteLength"))[0],
                                                                                    },
                                                                                    Operands = new ExpressionList(
                                                                                        rightIdentifier
                                                                                    ),
                                                                                }
                                                                            ),
                                                                        }
                                                                    }
                                                                ),
                                                            },
                                                            FalseBlock = new Block {
                                                                Statements = new StatementList(
                                                                    new AssignmentStatement {
                                                                        Target = resultIdentifier,
                                                                        Source = new Construct {
                                                                            Constructor = new MemberBinding {
                                                                                BoundMember = STANDARD.Data.GetConstructor(SystemTypes.Array),
                                                                            },
                                                                            Operands = new ExpressionList(
                                                                                dataConstructorArgument
                                                                            ),
                                                                        }
                                                                    }
                                                                ),
                                                            }
                                                        }
                                                    ),
                                                }
                                            },
                                            new ExpressionStatement {
                                                Expression = resultIdentifier,
                                            }
                                        ),
                                    },
                                },
                            };
                            #endregion
                            return node;
                        }
                    } else {
                        // receiver is not data, still we can convert something
                        Expression expr = MethodConverter.ConvertExpression(right_part, receiverInstance.type);
                        if (expr != null) {
                            /*
                             * receiver = OperationX.call(arg1, arg2, ...);
                             */
                            return new AssignmentStatement {
                                Target = receiverInstance.convert() as Expression,
                                Source = expr
                            };
                        }
                    }
                }
            }
            #endregion

            #region Math Assignment 
            //~ element-wise assignment
            //But we don't do it, if binary or unary operator stays in the right part,
            //and left part is not an indexer
            //because in this case a new array will be created;
            //If assignment for user-added types was overloaded, we have to do it;
            if ((receiver.type is ARRAY_TYPE) && (right_part.type is ARRAY_TYPE) &&
                    ((((ARRAY_TYPE)receiver.type).isMath) || (((ARRAY_TYPE)right_part.type).isMath))
                    && (!(right_part is NEW))) {
                MethodCall mathCall;

                //#region optimization

                //MULTIPLY multPart = null;
                //bool isMultPartRight = true;
                //bool isRightPartPlus = false;
                //bool isRightPartMinus = false;

                //if (right_part is MULTIPLY_ELEMENTWISE)
                //{
                //    MULTIPLY_ELEMENTWISE me = right_part as MULTIPLY_ELEMENTWISE;
                //    ARRAY_TYPE lo = null, ro = null;
                //    if ((me.left_operand is INSTANCE) && (me.left_operand.type is ARRAY_TYPE))
                //    {
                //        lo = me.left_operand.type as ARRAY_TYPE;
                //        if (lo.dimensions.Length <= 2)
                //            if ((me.right_operand is INSTANCE) && (me.right_operand.type is ARRAY_TYPE))
                //            {
                //                ro = me.right_operand.type as ARRAY_TYPE;
                //                if (ro.dimensions.Length <= 2)
                //                {
                //                    mathCall = new MethodCall();
                //                    mathCall.Operands = new ExpressionList();

                //                    mathCall.Operands.Add(me.left_operand.convert() as Expression);
                //                    mathCall.Operands.Add(me.right_operand.convert() as Expression);
                //                    mathCall.Operands.Add(receiver.convert() as Expression);

                //                    mathCall.Callee = new MemberBinding(null,
                //                        CONTEXT.globalMath.GetOptimizedElementWiseMult(
                //                            lo.dimensions.Length, 
                //                            lo.base_type.convert() as TypeNode, 
                //                            ro.base_type.convert() as TypeNode,
                //                            ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode,
                //                            receiver.name.Name.CompareTo(me.left_operand.name.Name) == 0,
                //                            this.sourceContext));

                //                    ExpressionStatement res = new ExpressionStatement(mathCall, sourceContext);
                //                    return res;
                //                }
                //            }
                //    }
                //}

                //else if (right_part is MULTIPLY)
                //{
                //    multPart = right_part as MULTIPLY;
                //}

                //else if (right_part is PLUS)
                //{
                //    if ((right_part as PLUS).left_operand is MULTIPLY)
                //    {
                //        multPart = (right_part as PLUS).left_operand as MULTIPLY;
                //        isRightPartPlus = true;
                //        isMultPartRight = false;   
                //    }
                //    else if ((right_part as PLUS).right_operand is MULTIPLY)
                //    {
                //        multPart = (right_part as PLUS).right_operand as MULTIPLY;
                //        isRightPartPlus = true;
                //    }
                //}

                //else if (right_part is MINUS)
                //{
                //    if ((right_part as MINUS).right_operand is MULTIPLY)
                //    {
                //        multPart = (right_part as MINUS).right_operand as MULTIPLY;
                //        isRightPartMinus = true;
                //    }
                //}

                //if (multPart != null)
                //{
                //    if ((multPart.right_operand is TRANSPOSE) && 
                //        (multPart.left_operand.type is ARRAY_TYPE) &&
                //        !isMultPartRight)
                //        //M3 := !M1 * M2 + q
                //    {
                //        mathCall = new MethodCall();
                //        mathCall.Operands = new ExpressionList();

                //        mathCall.Operands.Add(multPart.left_operand.convert() as Expression);
                //        mathCall.Operands.Add((multPart.right_operand as TRANSPOSE).operand.convert() as Expression);
                //        mathCall.Operands.Add(receiver.convert() as Expression);
                //        if (isRightPartPlus)
                //            mathCall.Operands.Add((right_part as PLUS).right_operand.convert() as Expression);

                //        TypeNode constType;
                //        if (isRightPartPlus)
                //            constType = (right_part as PLUS).right_operand.type.convert() as TypeNode;
                //        else
                //            constType = ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode;

                //        mathCall.Callee = new MemberBinding(null,
                //            CONTEXT.globalMath.GetOptimizedMMTransposed_WithCopying(
                //                ((ARRAY_TYPE)(multPart.left_operand).type).base_type.convert() as TypeNode,
                //                ((ARRAY_TYPE)((multPart.right_operand as TRANSPOSE).operand).type).base_type.convert() as TypeNode,
                //                ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode,
                //                constType,
                //                isRightPartPlus,
                //                this.sourceContext));

                //        ExpressionStatement res = new ExpressionStatement(mathCall, sourceContext);
                //        return res;
                //    }

                //    else if (!isRightPartPlus && !isRightPartMinus &&
                //        (multPart.right_operand.type is ARRAY_TYPE) &&
                //        ((multPart.right_operand.type as ARRAY_TYPE).dimensions.Length == 1) &&
                //        (multPart.left_operand.type is ARRAY_TYPE) &&
                //        ((multPart.left_operand.type as ARRAY_TYPE).dimensions.Length == 2) &&
                //        (receiver is INSTANCE))
                //        //V1 := M * V2
                //    {
                //        mathCall = new MethodCall();
                //        mathCall.Operands = new ExpressionList();

                //        mathCall.Operands.Add(multPart.left_operand.convert() as Expression);
                //        mathCall.Operands.Add(multPart.right_operand.convert() as Expression);
                //        mathCall.Operands.Add(receiver.convert() as Expression);

                //        mathCall.Callee = new MemberBinding(null,
                //            CONTEXT.globalMath.GetOptimizedMatrixVectorMult(
                //                ((ARRAY_TYPE)(multPart.left_operand).type).base_type.convert() as TypeNode,
                //                ((ARRAY_TYPE)(multPart.right_operand).type).base_type.convert() as TypeNode,
                //                ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode,
                //                this.sourceContext));

                //        ExpressionStatement res = new ExpressionStatement(mathCall, sourceContext);
                //        return res;
                //    }

                //    else if (!isRightPartPlus && isRightPartMinus && isMultPartRight &&
                //        ((right_part as MINUS).right_operand is MULTIPLY) &&
                //        (multPart.type is ARRAY_TYPE) &&
                //        (multPart.right_operand.type is ARRAY_TYPE) &&
                //        ((multPart.right_operand.type as ARRAY_TYPE).dimensions.Length == 1) &&
                //        (multPart.left_operand.type is ARRAY_TYPE) &&
                //        ((multPart.left_operand.type as ARRAY_TYPE).dimensions.Length == 2) &&
                //        ((right_part as MINUS).left_operand.type is ARRAY_TYPE) &&
                //        ((right_part as MINUS).left_operand.type as ARRAY_TYPE).dimensions.Length == 1)
                //    //V1 := V2 - M * V3;
                //    {
                //        mathCall = new MethodCall();
                //        mathCall.Operands = new ExpressionList();

                //        mathCall.Operands.Add((right_part as MINUS).left_operand.convert() as Expression);
                //        mathCall.Operands.Add(multPart.left_operand.convert() as Expression);
                //        mathCall.Operands.Add(multPart.right_operand.convert() as Expression);
                //        mathCall.Operands.Add(receiver.convert() as Expression);

                //        mathCall.Callee = new MemberBinding(null,
                //            CONTEXT.globalMath.GetOptimizedVectorMatrixVectorMultMin(
                //                ((ARRAY_TYPE)((right_part as MINUS).left_operand.type)).base_type.convert() as TypeNode,
                //                ((ARRAY_TYPE)(multPart.left_operand).type).base_type.convert() as TypeNode,
                //                ((ARRAY_TYPE)(multPart.right_operand).type).base_type.convert() as TypeNode,
                //                ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode,
                //                this.sourceContext));

                //        ExpressionStatement res = new ExpressionStatement(mathCall, sourceContext);
                //        return res;
                //    }

                //    else if (!isRightPartPlus && isRightPartMinus && isMultPartRight &&
                //        ((right_part as MINUS).right_operand is MULTIPLY) &&
                //        (multPart.type is ARRAY_TYPE) &&
                //        (multPart.left_operand is MULTIPLY) &&
                //        (multPart.left_operand.type is ARRAY_TYPE) &&
                //        ((multPart.left_operand.type as ARRAY_TYPE).dimensions.Length == 1) &&
                //        (multPart.right_operand.type is ARRAY_TYPE) &&
                //        ((multPart.right_operand.type as ARRAY_TYPE).dimensions.Length == 2) &&
                //        ((right_part as MINUS).left_operand.type is ARRAY_TYPE) &&
                //        (((right_part as MINUS).left_operand.type as ARRAY_TYPE).dimensions.Length == 1) &&
                //        receiver.name.Name.CompareTo((right_part as MINUS).left_operand.name.Name) == 0)
                //    //V1 := V1 - c1 * V2 * M;
                //    {
                //        mathCall = new MethodCall();
                //        mathCall.Operands = new ExpressionList();

                //        mathCall.Operands.Add((multPart.left_operand as MULTIPLY).left_operand.convert() as Expression);
                //        mathCall.Operands.Add((multPart.left_operand as MULTIPLY).right_operand.convert() as Expression);
                //        mathCall.Operands.Add(multPart.right_operand.convert() as Expression);
                //        mathCall.Operands.Add(receiver.convert() as Expression);

                //        mathCall.Callee = new MemberBinding(null,
                //            CONTEXT.globalMath.GetOptimizedVectorConstVectorMatrixMultMultMin(
                //                (multPart.left_operand as MULTIPLY).left_operand.type.convert() as TypeNode,
                //                ((ARRAY_TYPE)(multPart.left_operand as MULTIPLY).right_operand.type).base_type.convert() as TypeNode,
                //                ((ARRAY_TYPE)(multPart.right_operand.type)).base_type.convert() as TypeNode,
                //                ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode,
                //                this.sourceContext));

                //        ExpressionStatement res = new ExpressionStatement(mathCall, sourceContext);
                //        return res;
                //    }

                //    else if (
                //        ((isRightPartPlus || isRightPartMinus) &&
                //        isMultPartRight &&
                //        (multPart.type is ARRAY_TYPE) &&
                //        (multPart.right_operand.type is ARRAY_TYPE) &&
                //        ((multPart.right_operand.type as ARRAY_TYPE).dimensions.Length == 1) &&
                //        !(multPart.left_operand.type is ARRAY_TYPE)) 
                //        &&(
                //        (isRightPartMinus &&
                //        ((right_part as MINUS).right_operand is MULTIPLY) &&
                //        ((right_part as MINUS).left_operand.type is ARRAY_TYPE) &&
                //        ((right_part as MINUS).left_operand.type as ARRAY_TYPE).dimensions.Length == 1) 
                //        || 
                //        (isRightPartPlus &&
                //        ((right_part as PLUS).right_operand is MULTIPLY) &&
                //        ((right_part as PLUS).left_operand.type is ARRAY_TYPE) &&
                //        ((right_part as PLUS).left_operand.type as ARRAY_TYPE).dimensions.Length == 1)
                //        ))

                //    //V1 := V2 +- c1 * V3;
                //    {
                //        mathCall = new MethodCall();
                //        mathCall.Operands = new ExpressionList();

                //        BINARY rp = right_part as BINARY;

                //        mathCall.Operands.Add(rp.left_operand.convert() as Expression);
                //        mathCall.Operands.Add(multPart.left_operand.convert() as Expression);
                //        mathCall.Operands.Add(multPart.right_operand.convert() as Expression);
                //        mathCall.Operands.Add(receiver.convert() as Expression);

                //        mathCall.Callee = new MemberBinding(null,
                //            CONTEXT.globalMath.GetOptimizedVectorConstVectorMulPlusOrMinus(
                //                ((ARRAY_TYPE)(rp.left_operand.type)).base_type.convert() as TypeNode,
                //                multPart.left_operand.type.convert() as TypeNode,
                //                ((ARRAY_TYPE)(multPart.right_operand).type).base_type.convert() as TypeNode,
                //                ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode,
                //                receiver.name.Name.CompareTo(rp.left_operand.name.Name) == 0,
                //                isRightPartMinus,
                //                this.sourceContext));

                //        ExpressionStatement res = new ExpressionStatement(mathCall, sourceContext);
                //        return res;
                //    }
                //}

                //#endregion

                AssignmentStatement mathAssignment = new AssignmentStatement();
                mathAssignment.NodeType = NodeType.AssignmentStatement;
                mathAssignment.Operator = NodeType.Nop;
                mathAssignment.SourceContext = this.sourceContext;
                
                #region auxilary (defining receiverIsIndexer, receiver_base_type, opType, ovlType, etc.)
                bool receiverIsIndexer = receiver is INDEXER;
                bool right_partIsIndexer = right_part is INDEXER;

                TYPE right_part_base_type;
                TYPE receiver_base_type;

                //destination
                if (!receiverIsIndexer) {
                    receiver_base_type = ((ARRAY_TYPE)receiver.type).base_type;
                } else {
                    receiver_base_type = ((ARRAY_TYPE)((INDEXER)receiver).left_part.type).base_type;
                }
                //source
                if (!right_partIsIndexer) {
                    right_part_base_type = ((ARRAY_TYPE)right_part.type).base_type;
                } else {
                    right_part_base_type = ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).base_type;
                }

                //we have to check, whether there is an overloaded ':='
                if ((!(receiver_base_type is INTEGER_TYPE) && !(receiver_base_type is CARDINAL_TYPE) &&
                    !(receiver_base_type is REAL_TYPE) && !(receiver_base_type is SET_TYPE)) ||
                    (!(right_part_base_type is INTEGER_TYPE) && !(right_part_base_type is CARDINAL_TYPE) &&
                    !(right_part_base_type is REAL_TYPE) && !(right_part_base_type is SET_TYPE))
                    ) {
                    ASSIGNMENT_OPERATOR assign_op = new ASSIGNMENT_OPERATOR(":=");
                    OPERATOR_DECL op = assign_op.findBestOpDeclForBinaryOperator(receiver_base_type, right_part_base_type);
                    if (op != null) {
                        opType = NodeType.MethodCall;
                        ovlOp = (INSTANCE.create(op)).convert() as QualifiedIdentifier;
                    }
                }
                #endregion

                #region case when we have to check array lengths and do reference assignment
                if (!receiverIsIndexer && (opType != NodeType.MethodCall) &&
                    ((right_part is BINARY) || (right_part is UNARY) || (right_part is CALL)))
                //TO BE CHECKED: (right_part is CALL)
                {
                    mathAssignment.Source = right_part.convert() as Expression;
                    mathAssignment.Target = receiver.convert() as Expression;

                    Block block = new Block(new StatementList());
                    if (((ARRAY_TYPE)receiver.type).const_dimensions[0] != 0) //receiver is a static array
                    {
                        string arr_name = "__math_temp";

                        LocalDeclarationsStatement lds = new LocalDeclarationsStatement();
                        lds.Constant = false;
                        lds.Declarations = new LocalDeclarationList(1);
                        lds.InitOnly = false;
                        ArrayTypeExpression ate = right_part.type.convert() as ArrayTypeExpression;
                        lds.Type = new ArrayTypeExpression(ate.ElementType, ate.Rank);

                        LocalDeclaration ld = new LocalDeclaration();
                        ld.Name = Identifier.For(arr_name);
                        ld.InitialValue = right_part.convert() as Expression;
                        lds.Declarations.Add(ld);

                        block.Statements.Add(lds);

                        for (int i = 0; i < ((ARRAY_TYPE)receiver.type).const_dimensions.Length; i++) {
                            block.Statements.Add(
                                CONTEXT.globalMath.GenerateIfStatementWithThrow(
                                    new Literal(((ARRAY_TYPE)receiver.type).const_dimensions[i], SystemTypes.Int32),
                                    new MethodCall(
                                        new MemberBinding(
                                            Identifier.For(arr_name),
                                            SystemTypes.Array.GetMembersNamed(Identifier.For("GetLength"))[0]),
                                            new ExpressionList(new Expression[] { new Literal(i, SystemTypes.Int32) }),
                                            NodeType.Call, SystemTypes.Int32),
                                    NodeType.Ne,
                                    STANDARD.IncompatibleSizesException,
                                    this.sourceContext.StartLine,
                                    this.sourceContext.StartColumn,
                                    sourceContext));
                        }

                        mathAssignment.Source = Identifier.For(arr_name);
                    }

                    block.Statements.Add(mathAssignment);
                    return block;
                }
#endregion

                #region case like a[2..4] := a[1..3]
                if ((receiverIsIndexer && right_partIsIndexer) &&
                    ((receiver as INDEXER).left_part.name == (right_part as INDEXER).left_part.name))
                //this is the case like a[2..4] := a[1..3]; //a[2] := a[1]; a[3] := a[2]; a[4] := a[3];
                {
                    //type[...] __math_temp = new type[...];  //type here is equal to typeof(a)
                    //__math_temp = DeepCopy(__math_temp, a);
                    //a = DeepCopyCorrIndexing(a, __math_temp, indices);
                    Block block = new Block(new StatementList());

                    //type[...] __math_temp = new type[...];
                    string arr_name = "__math_temp";
                    LocalDeclarationsStatement lds = new LocalDeclarationsStatement();
                    lds.Constant = false;
                    lds.Declarations = new LocalDeclarationList(1);
                    lds.InitOnly = false;
                    ArrayTypeExpression ate = (receiver as INDEXER).left_part.type.convert() as ArrayTypeExpression;
                    lds.Type = new ArrayTypeExpression(ate.ElementType, ate.Rank);
                    LocalDeclaration ld = new LocalDeclaration();
                    ld.Name = Identifier.For(arr_name);
                    //ld.InitialValue = new_array;
                    lds.Declarations.Add(ld);
                    block.Statements.Add(lds);

                    //__math_temp = DeepCopy(__math_temp, a);
                    MethodCall mathCall1 = new MethodCall();
                    mathCall1.Operands = new ExpressionList();
                    mathCall1.Operands.Add(Identifier.For(arr_name));
                    mathCall1.Operands.Add(((INDEXER)receiver).left_part.convert() as Expression);
                    mathCall1.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetDeepCopyWithMemoryAlloc(
                        ate.Rank,
                        ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).dimensions.Length,
                        ate.ElementType,
                        ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).base_type.convert() as TypeNode,
                        null,
                        opType, ovlOp,
                        this.sourceContext));

                    block.Statements.Add(new AssignmentStatement(
                        Identifier.For(arr_name),
                        mathCall1,
                        NodeType.Nop,
                        this.sourceContext));

                    //a = DeepCopyCorrIndexing(a, __math_temp, indices);
                    MethodCall mathCall2 = new MethodCall();
                    mathCall2.Operands = new ExpressionList();
                    mathCall2.Operands.Add(((INDEXER)receiver).left_part.convert() as Expression);
                    mathCall2.Operands.Add(Identifier.For(arr_name));
                    //receiver indices
                    EXPRESSION_LIST indices = ((INDEXER)receiver).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            mathCall2.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                mathCall2.Operands.Add(cur_range.from.convert() as Expression);
                                mathCall2.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                mathCall2.Operands.Add(cur_range.to.convert() as Expression);
                                mathCall2.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                mathCall2.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                mathCall2.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                mathCall2.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                mathCall2.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            mathCall2.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                    //source indices
                    indices = ((INDEXER)right_part).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            mathCall2.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                mathCall2.Operands.Add(cur_range.from.convert() as Expression);
                                mathCall2.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                mathCall2.Operands.Add(cur_range.to.convert() as Expression);
                                mathCall2.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                mathCall2.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                mathCall2.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                mathCall2.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                mathCall2.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            mathCall2.Operands.Add(indices[i].convert() as Expression);
                        }
                    }

                    mathCall2.Callee = new MemberBinding(null,
                        CONTEXT.globalMath.GetDeepCopy(
                        ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).dimensions.Length,
                        ate.Rank,
                        ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).base_type.convert() as TypeNode,
                        ate.ElementType,
                        ((INDEXER)receiver).indices,
                        ((INDEXER)right_part).indices,
                        opType, ovlOp,
                        this.sourceContext));

                    block.Statements.Add(new AssignmentStatement(
                        (receiver as INDEXER).left_part.convert() as Expression,
                        mathCall2,
                        NodeType.Nop,
                        this.sourceContext));

                    return block;
                }
                #endregion

                #region default case
                mathCall = new MethodCall();
                mathCall.Operands = new ExpressionList();

                //destination
                if (!receiverIsIndexer) {
                    mathCall.Operands.Add(receiver.convert() as Expression);
                    if (CONTEXT.useComputeMath) mathAssignment.Target = receiver.name;
                    else mathAssignment.Target = receiver.convert() as Expression;
                } else {
                    mathCall.Operands.Add(((INDEXER)receiver).left_part.convert() as Expression);
                    if (CONTEXT.useComputeMath) mathAssignment.Target = ((INDEXER)receiver).left_part.name;
                    else mathAssignment.Target = ((INDEXER)receiver).left_part.convert() as Expression;
                }
                //source
                if (!right_partIsIndexer) {
                    mathCall.Operands.Add(right_part.convert() as Expression);
                } else {
                    mathCall.Operands.Add(((INDEXER)right_part).left_part.convert() as Expression);
                }

                if (receiverIsIndexer) //destination
                {
                    EXPRESSION_LIST indices = ((INDEXER)receiver).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            mathCall.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                mathCall.Operands.Add(cur_range.from.convert() as Expression);
                                mathCall.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                mathCall.Operands.Add(cur_range.to.convert() as Expression);
                                mathCall.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                mathCall.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                mathCall.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                mathCall.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                mathCall.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            mathCall.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }
                if (right_partIsIndexer) //source
                {
                    EXPRESSION_LIST indices = ((INDEXER)right_part).indices;
                    for (int i = 0; i < indices.Length; i++) {
                        if ((indices[i].type is INTEGER_TYPE) || (indices[i].type is CARDINAL_TYPE)) {
                            mathCall.Operands.Add(indices[i].convert() as Expression);
                        } else if (indices[i].type is RANGE_TYPE) {
                            if (indices[i] is ARRAY_RANGE) {
                                ARRAY_RANGE cur_range = indices[i] as ARRAY_RANGE;
                                mathCall.Operands.Add(cur_range.from.convert() as Expression);
                                mathCall.Operands.Add(new Literal(cur_range.wasToWritten, SystemTypes.Boolean));
                                mathCall.Operands.Add(cur_range.to.convert() as Expression);
                                mathCall.Operands.Add(cur_range.by.convert() as Expression);
                            } else //it's range_type variable
                            {
                                mathCall.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]));
                                mathCall.Operands.Add(new Literal(true, SystemTypes.Boolean));
                                mathCall.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]));
                                mathCall.Operands.Add(new MemberBinding(indices[i].convert() as Expression,
                                    STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]));
                            }
                        } else if (indices[i].type is ARRAY_TYPE) {
                            mathCall.Operands.Add(indices[i].convert() as Expression);
                        }
                    }
                }

                if (!receiverIsIndexer) {
                    if (!right_partIsIndexer) {
                        if (((ARRAY_TYPE)receiver.type).const_dimensions[0] != 0) //receiver is a static array
                        {
                            mathCall.Callee = new MemberBinding(null,
                                CONTEXT.globalMath.GetDeepCopy(
                                ((ARRAY_TYPE)receiver.type).dimensions.Length,
                                ((ARRAY_TYPE)right_part.type).dimensions.Length,
                                ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode,
                                ((ARRAY_TYPE)right_part.type).base_type.convert() as TypeNode,
                                null,
                                null,
                                opType, ovlOp,
                                this.sourceContext));
                        } else //receiver is a dynamic array
                        {
                            mathCall.Callee = new MemberBinding(null,
                                CONTEXT.globalMath.GetDeepCopyWithMemoryAlloc(
                                ((ARRAY_TYPE)receiver.type).dimensions.Length,
                                ((ARRAY_TYPE)right_part.type).dimensions.Length,
                                ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode,
                                ((ARRAY_TYPE)right_part.type).base_type.convert() as TypeNode,
                                null,
                                opType, ovlOp,
                                this.sourceContext));
                        }
                    } else //right_partIsIndexer
                    {
                        if (((ARRAY_TYPE)receiver.type).const_dimensions[0] != 0) //receiver is a static array
                        {
                            mathCall.Callee = new MemberBinding(null,
                                CONTEXT.globalMath.GetDeepCopy(
                                ((ARRAY_TYPE)receiver.type).dimensions.Length,
                                ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).dimensions.Length,
                                ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode,
                                ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).base_type.convert() as TypeNode,
                                null,
                                ((INDEXER)right_part).indices,
                                opType, ovlOp,
                                this.sourceContext));
                        } else //receiver is a dynamic array
                        {
                            mathCall.Callee = new MemberBinding(null,
                                CONTEXT.globalMath.GetDeepCopyWithMemoryAlloc(
                                ((ARRAY_TYPE)receiver.type).dimensions.Length,
                                ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).dimensions.Length,
                                ((ARRAY_TYPE)receiver.type).base_type.convert() as TypeNode,
                                ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).base_type.convert() as TypeNode,
                                ((INDEXER)right_part).indices,
                                opType, ovlOp,
                                this.sourceContext));
                        }
                    }
                } else //receiverIsIndexer
                {
                    if (!right_partIsIndexer) {
                        mathCall.Callee = new MemberBinding(null,
                                CONTEXT.globalMath.GetDeepCopy(
                                ((ARRAY_TYPE)((INDEXER)receiver).left_part.type).dimensions.Length,
                                ((ARRAY_TYPE)right_part.type).dimensions.Length,
                                ((ARRAY_TYPE)((INDEXER)receiver).left_part.type).base_type.convert() as TypeNode,
                                ((ARRAY_TYPE)right_part.type).base_type.convert() as TypeNode,
                                ((INDEXER)receiver).indices,
                                null,
                                opType, ovlOp,
                                this.sourceContext));
                    } else {
                        mathCall.Callee = new MemberBinding(null,
                                CONTEXT.globalMath.GetDeepCopy(
                                ((ARRAY_TYPE)((INDEXER)receiver).left_part.type).dimensions.Length,
                                ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).dimensions.Length,
                                ((ARRAY_TYPE)((INDEXER)receiver).left_part.type).base_type.convert() as TypeNode,
                                ((ARRAY_TYPE)((INDEXER)right_part).left_part.type).base_type.convert() as TypeNode,
                                ((INDEXER)receiver).indices,
                                ((INDEXER)right_part).indices,
                                opType, ovlOp,
                                this.sourceContext));
                    }
                }

                //mathCall.Type = resType.convert() as TypeNode;
                //ToDo: mathCall type??

                if (CONTEXT.useComputeMath) mathAssignment.Source = new Construct {
                    Constructor = new MemberBinding {
                        BoundMember = STANDARD.Data.GetConstructor(SystemTypes.Array),
                    },
                    Operands = new ExpressionList(
                        mathCall
                    ),
                };
                else mathAssignment.Source = mathCall;
                return mathAssignment;
#endregion
            }
            #endregion

            #region Range Assignment
            if ((receiver.type is RANGE_TYPE) && (right_part.type is RANGE_TYPE)) {
                if (right_part is ARRAY_RANGE) // r: range; r := 1..5 by 2;
                {
                    //receiver.from = right_part.from
                    AssignmentStatement as1 = new AssignmentStatement();
                    as1.Operator = NodeType.Nop;
                    as1.Source = ((ARRAY_RANGE)right_part).from.convert() as Expression;
                    as1.Target = new MemberBinding(receiver.convert() as Expression,
                        STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]);

                    //receiver.to = right_part.to
                    AssignmentStatement as2 = new AssignmentStatement();
                    as2.Operator = NodeType.Nop;
                    as2.Source = ((ARRAY_RANGE)right_part).to.convert() as Expression;
                    as2.Target = new MemberBinding(receiver.convert() as Expression,
                        STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]);

                    //receiver.by = right_part.by
                    AssignmentStatement as3 = new AssignmentStatement();
                    as3.Operator = NodeType.Nop;
                    as3.Source = ((ARRAY_RANGE)right_part).by.convert() as Expression;
                    as3.Target = new MemberBinding(receiver.convert() as Expression,
                        STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]);

                    Block block = new Block(new StatementList());
                    block.Statements.Add(as1);
                    block.Statements.Add(as2);
                    block.Statements.Add(as3);
                    return block;
                } else // r1, r2: range; r1 := r2;
                {
                    //receiver.from = right_part.from
                    AssignmentStatement as1 = new AssignmentStatement();
                    as1.Operator = NodeType.Nop;
                    as1.Source = new MemberBinding(right_part.convert() as Expression,
                        STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]);
                    as1.Target = new MemberBinding(receiver.convert() as Expression,
                        STANDARD.Ranges.GetMembersNamed(Identifier.For("from"))[0]);

                    //receiver.to = right_part.to
                    AssignmentStatement as2 = new AssignmentStatement();
                    as2.Operator = NodeType.Nop;
                    as2.Source = new MemberBinding(right_part.convert() as Expression,
                        STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]);
                    as2.Target = new MemberBinding(receiver.convert() as Expression,
                        STANDARD.Ranges.GetMembersNamed(Identifier.For("to"))[0]);

                    //receiver.by = right_part.by
                    AssignmentStatement as3 = new AssignmentStatement();
                    as3.Operator = NodeType.Nop;
                    as3.Source = new MemberBinding(right_part.convert() as Expression,
                        STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]);
                    as3.Target = new MemberBinding(receiver.convert() as Expression,
                        STANDARD.Ranges.GetMembersNamed(Identifier.For("by"))[0]);

                    Block block = new Block(new StatementList());
                    block.Statements.Add(as1);
                    block.Statements.Add(as2);
                    block.Statements.Add(as3);
                    return block;
                }
            }
            #endregion

            if (receiver is INDEXER && (receiver as INDEXER).calls != null) {   // We should generate call
                INDEXER indexer = receiver as INDEXER;
                PROCEDURE_DECL calee = (receiver as INDEXER).calls.Set; // What to call

                MethodCall invoke = new MethodCall();
                Node target = ((INDEXER)receiver).left_part.convert();
                Node member = calee.convert();

                if (target == null || member == null)
                    return null;
                
                invoke.Callee = new MemberBinding(target as Expression, member as Member);
                invoke.GiveErrorIfSpecialNameMethod = false; // ??

                invoke.IsTailCall = false;

                invoke.Operands = new ExpressionList(indexer.indices.Length + 1);
                for (int i = 0; i < indexer.indices.Length; i++)
                    invoke.Operands.Add(indexer.indices[i].convert() as Expression);
                invoke.Operands.Add(right_part.convert() as Expression);
                invoke.SourceContext = this.sourceContext;
                invoke.Type = SystemTypes.Void;
                ExpressionStatement pcall = new ExpressionStatement(invoke, this.sourceContext);
                return pcall;
            }

            if ((receiver is INDEXER) && ((receiver as INDEXER).left_part.type is SPARSE_TYPE)) {
                TypeNode curType;
                SPARSE_TYPE curSparseType = (receiver as INDEXER).left_part.type as SPARSE_TYPE;
                if (curSparseType.isVector)
                    curType = STANDARD.SparseVector.GetTemplateInstance(CONTEXT.symbolTable,
                        curSparseType.base_type.convert() as TypeNode);
                else
                    curType = STANDARD.SparseMatrix.GetTemplateInstance(CONTEXT.symbolTable,
                        curSparseType.base_type.convert() as TypeNode);
                MethodCall invoke = new MethodCall();
                if (curSparseType.isVector)
                    invoke.Callee = new MemberBinding((receiver as INDEXER).left_part.convert() as Expression,
                        curType.GetMembersNamed(Identifier.For("SetElem"))[0]);
                else
                    invoke.Callee = new MemberBinding((receiver as INDEXER).left_part.convert() as Expression,
                        curType.GetMembersNamed(Identifier.For("SetElem"))[0]);

                invoke.IsTailCall = false;

                invoke.Operands = new ExpressionList((receiver as INDEXER).indices.Length);
                invoke.Operands.Add(new Literal(sourceContext.StartLine, SystemTypes.Int64));
                invoke.Operands.Add(new Literal(sourceContext.StartColumn, SystemTypes.Int32));

                for (int i = 0; i < (receiver as INDEXER).indices.Length; i++)
                    invoke.Operands.Add((receiver as INDEXER).indices[i].convert() as Expression);
                invoke.Operands.Add(right_part.convert() as Expression);
                invoke.SourceContext = this.sourceContext;
                invoke.Type = SystemTypes.Void;

                ExpressionStatement pcall = new ExpressionStatement(invoke, this.sourceContext);
                return pcall;
            }

            AssignmentStatement assignment = new AssignmentStatement();

            assignment.NodeType = NodeType.AssignmentStatement;
            assignment.Operator = NodeType.Nop;  // this means "normal" assignment, but not += etc.
         // assignment.OperatorOverload;

            assignment.Source = right_part.convert() as Expression;
            if (assignment.Source == null && !right_part.ErrorReported) {
                    ERROR.AssignmentCompatibility("variable", "not expression", sourceContext);
            }
            assignment.SourceContext = base.sourceContext;

            Expression targ = receiver.convert() as Expression;

            // Here we'll check if receiver is property defined and definition and if we're inside implementation
            // then if the property is readonly we allow writing directly.
            if ((receiver is INSTANCE) && (receiver.modifiers.Getter) && (!receiver.modifiers.Setter)) {
                NODE encl = this.enclosing;
                DEFINITION_DECL def = ((ETH.Zonnon.INSTANCE)(receiver)).entity.enclosing as DEFINITION_DECL;
                OBJECT_DECL unitobj = this.getEnclosingUnit() as OBJECT_DECL;
                IMPLEMENTATION_DECL impl = encl as IMPLEMENTATION_DECL;
                bool local = (unitobj != null) ? unitobj.definitions.find(def) != null : (impl != null) ? impl.implemented_definition == def : false;

                if (local) { // Interesting only in case of implementation
                    // Hope that "_default" will be generated. Otherwise CCI will get its own error
                    targ = new Identifier(((INSTANCE)receiver).entity.name.Name + "_default");
                }
            }

            // Here we'll check if receiver is property defined and definition and if we're inside a constructor
            // then we perform reading and writing directly.
            if ((receiver is INSTANCE) && (receiver.modifiers.Getter || receiver.modifiers.Setter)) {
                NODE encl = this.enclosing;
                DEFINITION_DECL def = ((ETH.Zonnon.INSTANCE)(receiver)).entity.enclosing as DEFINITION_DECL;
                OBJECT_DECL unitobj = this.getEnclosingUnit() as OBJECT_DECL;
                IMPLEMENTATION_DECL impl = encl as IMPLEMENTATION_DECL;
                bool local = (unitobj != null) ? unitobj.definitions.find(def) != null : (impl != null) ? impl.implemented_definition == def : false;
                
                while (!(encl is BLOCK) && (encl != null))
                    encl = encl.enclosing;
                if (encl != null && encl.enclosing == this.getEnclosingUnit()) { // Interesting only in case of implementation
                    // Hope that "_default" will be generated. Otherwise CCI will get its own error
                   targ = new Identifier(((INSTANCE)receiver).entity.name.Name + "_default");
                }
            }


            assignment.Target = targ;

            node = assignment;

            return node;
        }

        //----------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("ASSIGNMENT line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("RECEIVER");
            if (receiver == null) {
                NODE.doShift(shift+2*NODE.reportShift);
                Console.WriteLine("NULL");
            } else
                receiver.report(shift+2*NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("RIGHT PART");
            right_part.report(shift+2*NODE.reportShift);
        }
#endif
    }

    // CALL_STMT
    // =========
    //
    public sealed class CALL_STMT : STATEMENT {
        // Constructor
        public CALL_STMT ( ) : base(ASTNodeType.CALL_STMT) { }

        //---------------------------------------------------------------------

        public CALL call;

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            if(call != null) scope = call.findScopeAtContext(line, col, documentName);
            return scope;
        }
        //---------------------------------------------------------------------

        public static CALL_STMT create(NODE enclosing, DESIGNATOR designator) {
            CALL_STMT call_stmt = new CALL_STMT();

            if ( designator is CALL )
                call_stmt.call = (CALL)designator;
            else {
                call_stmt.call = new CALL();
                call_stmt.call.callee = designator;
             // call_stmt.call.arguments  -- no args
            }

            call_stmt.enclosing = enclosing;
            call_stmt.modifiers = null;
         // call.name;
         // call_stmt.sourceContext

            // Semantic processing
            call_stmt.finalize(enclosing);
            return call_stmt;
        }

        //---------------------------------------------------------------------

        public override NODE resolve ( ) { call.resolve(); return this; }

        //------------------------------------------------------------------------------

        public override bool validate ( ) { return call.validate(); } // checks semantical correctness

        //------------------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of call statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            Node tmp = call.convert();
            if (tmp != null)
                tmp.SourceContext = call.sourceContext;

            if (tmp is Expression) {
                ExpressionStatement expr = new ExpressionStatement();
                expr.Expression = (Expression)tmp;
                expr.SourceContext = tmp.SourceContext;
             // expr.NodeType
                node = expr;
            } else if (tmp is Statement) {
                node = tmp;
            } else // ?????
            {
            }
            return node;
        }

        //------------------------------------------------------------------------------

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("CALL STATEMENT line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("CALLEE:");
            if ( call.callee == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                call.callee.report(shift+2*NODE.reportShift);
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("ARGUMENTS:");
            if ( call.arguments == null || call.arguments.Length == 0 )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine(" {0}",call.arguments.Length);
                for (int i = 0, n = call.arguments.Length; i < n; i++) {
                    EXPRESSION arg = call.arguments[i];
                    if (arg == null) {
                        NODE.doShift(shift+2*NODE.reportShift);
                        System.Console.WriteLine("MISSED");
                    } else
                        call.arguments[i].report(shift+2*NODE.reportShift);
                }
            }
        }
#endif
    }

    // EXIT
    // ====
    //
    public sealed class EXIT : STATEMENT {
        // Constructor
        public EXIT ( ) : base(ASTNodeType.EXIT) { }

        //---------------------------------------------------------------------

        public static EXIT create(NODE enclosing) {
            EXIT exit = new EXIT();
            exit.finalize(enclosing);
            return exit;
        }

        //---------------------------------------------------------------------

        public override NODE resolve ( ) { return this; }

        //---------------------------------------------------------------------

        public override bool validate ( ) { return true; } // checks semantical correctness

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of call statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

         // resolve();
         // if ( !validate() ) return null;

            // node = new Exit();  // perhaps, we should add a level value?
            Goto gt = new Goto();
            // Looking for the enclosing Loop statement
            NODE scope = this.enclosing;
            while (scope != null && !(scope is LOOP) && !(scope is NAMESPACE_DECL))
                scope = scope.enclosing;
            if (scope is LOOP) {
                gt.TargetLabel = ((LOOP)scope).Label;
                ((LOOP)scope).LabelUsed = true;
                gt.SourceContext = sourceContext;
                node = gt;
            } else {
                node = null;
                ERROR.ExitStatementDoesntBelongAnyLoopStatement(sourceContext);
            }
            return node;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("EXIT");
            report_extra();
        }
#endif
    }

    // RETURN
    // ======
    //
    public sealed class RETURN : STATEMENT {
        // Constructor
        public RETURN ( ) : base(ASTNodeType.RETURN) { }

        //---------------------------------------------------------------------

        public ROUTINE_DECL routine;
        public EXPRESSION   return_value;

        //---------------------------------------------------------------------

        public static RETURN create() {
            RETURN r = new RETURN();
            r.routine = CONTEXT.current_routine;
            return r;
        }

        public new void finalize(NODE enclosing) {
            base.finalize(enclosing);
        }

        //---------------------------------------------------------------------

        public override NODE resolve() {
            if ( routine != null )
                routine.resolve();
         // else
         //     -- 'routine' can be null if we return from a module/object

            if (return_value != null)
                return_value.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (return_value != null && !return_value.validate())
                return false;

            // o If the containing procedure returns nothing then
            //   'val' should be null;
            //
            // o If the containing procedure returns a value then
            //   'val' should be non-null;
            //
            // o Expression type of the return statement should be
            //   compliant with the type returning by the procedure.

            if ( routine == null )  // This is return from a module/object...
            {
                if ( return_value != null )  // ...but a value is given!..
                {
                    ERROR.ExtraReturnValue(CONTEXT.current_unit.name.Name,return_value.sourceContext);
                    return false;
                } else
                    return true;
            } else {
                if (routine.return_type == null || routine.return_type is VOID_TYPE) {
                    if (return_value != null) {
                        string s = "";
                        if (routine is PROCEDURE_DECL)
                            s = "Procedure " + routine.name.Name;
                        else if (routine is OPERATOR_DECL)
                            s = "Operator " + ((OPERATOR_DECL)routine).code;

                        ERROR.ExtraReturnValue(s,return_value.sourceContext);
                        return false;
                    }
                } else {
                    if (return_value == null) {
                        string s = "";
                        if (routine is PROCEDURE_DECL)
                            s = "procedure " + routine.name.Name;
                        else if (routine is OPERATOR_DECL)
                            s = "operator " + ((OPERATOR_DECL)routine).code;
                        else if (routine is ACTIVITY_DECL)
                            s = "activity " + routine.name.Name;

                        ERROR.MissedReturnValue(routine.name.Name,routine.sourceContext);
                        return false;
                    }
                }

                if (return_value != null) {
                    // Compare type of returned value with routine's return type:
                    // two types should be "assignment compatible" just as for assignment
                    // (see ASSIGNMENT class).
                    EXPRESSION result = TYPE.AssignmentCompatibility(routine.return_type,
                                                                     return_value.type,
                                                                     return_value,
                                                                     return_value.sourceContext,
                                                                     false);
                    if (result != null) {
                        // Replace right_part for the new sub-tree!
                        return_value = result;
                        return true;
                    }
                    return false;
                }

                return true;
            }
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of return statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            Return return_stmt = new Return();

            if (return_value != null) {

                Expression expr = null;
                if (CONTEXT.useComputeMath) {
                    expr = MethodConverter.ConvertExpression(return_value, return_value.type);
                }
                if (expr != null) {
                    return_stmt.Expression = expr;
                } else {
                    return_stmt.Expression = (Expression)return_value.convert();
                }     
            }
         // return_stmt.NodeType;
            return_stmt.SourceContext = base.sourceContext;

            node = return_stmt;
            return node;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("RETURN line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            if (return_value == null)
                return;
            return_value.report(shift+NODE.reportShift);
        }
#endif
    }

    // REPLY
    // =====
    //
    public sealed class REPLY : STATEMENT {
        // Constructor
        public REPLY ( ) : base(ASTNodeType.REPLY) { values_to_reply = new EXPRESSION_LIST(); }

        //---------------------------------------------------------------------

        public ACTIVITY_DECL   activity;
        public EXPRESSION_LIST values_to_reply;

        //---------------------------------------------------------------------

        public static REPLY create() {
            REPLY r = new REPLY();
            r.activity = (ACTIVITY_DECL)CONTEXT.current_routine;
            return r;
        }

        public new void finalize(NODE enclosing) {
            base.finalize(enclosing);
        }

        //---------------------------------------------------------------------

        public override NODE resolve() {
            if ( activity != null )
                activity.resolve();
         // else
         //     -- 'activity' cannot be null because we create REPLY instances
         //     -- only from within activities (see Parser).

            for ( int i=0,n=values_to_reply.Length; i<n; i++ )
                if (values_to_reply[i] != null)
                    values_to_reply[i].resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            for (int i = 0, n = values_to_reply.Length; i < n; i++) {
                if (values_to_reply[i] == null)
                    return false;
                if (!values_to_reply[i].validate())
                    return false;
                // Prohibit for INTEGER, CARDINAL types to be sent without typecast in Activities

                if ((values_to_reply[i].type is INTEGER_TYPE) || (values_to_reply[i].type is CARDINAL_TYPE) || (values_to_reply[i].type is REAL_TYPE)) {
                    // for this types we require explicit typecast
                    if ((values_to_reply[i] as CALL == null) && (values_to_reply[i] as TYPE_CONV == null) && (values_to_reply[i] as DESIGNATOR == null) || (values_to_reply[i] as LITERAL != null)) {
                        ERROR.ExplicitTypeConversionRequired(sourceContext);
                        return false;
                    }

                }
            }
            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type {
            // By definition, type of reply statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            MethodCall reply = null;
            Expression qualifier = Identifier.For("protocol");

            for (int i = 0, n = values_to_reply.Length; i < n; i++) {
                reply = new MethodCall();
                reply.Callee = new QualifiedIdentifier(qualifier,Identifier.For("reply"));
                reply.Operands = new ExpressionList(1);
                reply.Operands.Add((Expression)values_to_reply[i].convert());
                reply.SourceContext = values_to_reply[i].sourceContext;

                qualifier = reply;
            }
            node = new ExpressionStatement(reply);
            node.SourceContext = this.sourceContext;
            return node;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("REPLY line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            for ( int i=0,n=values_to_reply.Length; i<n; i++ )
                if (values_to_reply[i] != null)
                    values_to_reply[i].report(shift + NODE.reportShift);
        }
#endif
    }

    // AWAIT
    // =====
    //
    public sealed class AWAIT : STATEMENT {
        // Constructor
        public AWAIT ( ) : base(ASTNodeType.AWAIT) { }

        //---------------------------------------------------------------------

        public EXPRESSION val;

        //---------------------------------------------------------------------

        public static AWAIT create() {
            return new AWAIT();
        }

        public new void finalize(NODE enclosing) {
            base.finalize(enclosing);
        }

        //---------------------------------------------------------------------

        public override NODE resolve ( )
        {
            //Set "activeBody" flag if in body
            DECLARATION decl = this.getEnclosingDeclaration();
            if (decl is UNIT_DECL) ((UNIT_DECL)decl).activeBody = true;
            if ( val != null ) val.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o  'val' should be always non-null;
            // o  'val' should by of type BOOLEAN for conditional await and integer for temporal.
            bool ok = (val != null && val.validate() &&
                (val.type is BOOLEAN_TYPE
                || val.type is INTEGER_TYPE || val.type is CARDINAL_TYPE));
            if (!ok)
            {
                ERROR.IllegalConditionType(sourceContext);
                ErrorReported = true;
            }

            bool Protected = false;

            if (CONTEXT.current_unit is OBJECT_DECL)
                Protected = (CONTEXT.current_unit as OBJECT_DECL).modifiers.Protected;
            else if (CONTEXT.current_unit is MODULE_DECL)
                Protected = (CONTEXT.current_unit as MODULE_DECL).modifiers.Protected;
            else
            {
                ERROR.AwaitOutsideUnit(this.sourceContext);            
                ErrorReported = true;
            }

            if (!Protected)
            {
                ERROR.AwaitIsDeclaredInNonProtectedMethod(sourceContext);
                ErrorReported = true;
                ok = false;
            }

            return ok;
            
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of await statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        // For non-protected objects:
        //
        //      while ( !expression ) 
        //          Monitor.Wait(this);
        //
        // For protected-only objects:
        //
        //      while ( !expression )
        //      {
        //          _lock.LeaveMethod();
        //          Monitor.Wait(this);
        //          _lock.EnterMethod();
        //      }
        //
        // For protected- and shared-objects:
        //
        //      while ( !expression )
        //      {
        //          _lock.LeaveSharedMethod();
        //          Monitor.Wait(this);
        //          _lock.EnterSharedMethod();
        //      }
        //
        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            bool RWL = getEnclosingUnit().modifiers.Shared;
            
            ROUTINE_DECL routine = CONTEXT.current_routine as ROUTINE_DECL;
            bool Shared = (routine == null) ? false : routine.modifiers.Shared;

            if (val.type is BOOLEAN_TYPE)
            {                                                               
                While while_stmt = new While();
                while_stmt.SourceContext = val.sourceContext;
                while_stmt.Condition = new UnaryExpression((Expression)val.convert(), NodeType.LogicalNot);
                while_stmt.Condition.SourceContext = val.sourceContext;

                while_stmt.Body = new Block();
                while_stmt.Body.Statements = new StatementList();


                AssemblyNode system = AssemblyNode.GetAssembly(typeof(System.Threading.Monitor).Assembly);
                TypeNode monitor = system.GetType(Identifier.For("System.Threading"), Identifier.For("Monitor"));


                // Monitor.Wait(this);

                MethodCall wait = new MethodCall();
                wait.Operands = new ExpressionList();

                //if (RWL)
                //{
                //    if(Shared)
                //        wait.Callee = new QualifiedIdentifier(Identifier.For("_lock"), Identifier.For("WaitShared"));
                //    else
                //        wait.Callee = new QualifiedIdentifier(Identifier.For("_lock"), Identifier.For("Wait"));
                //}
                //else
                {
                    wait.Callee = new QualifiedIdentifier(new MemberBinding(null, monitor), Identifier.For("Wait"));
                    wait.Operands.Add(GetLockObject());
                }

                while_stmt.Body.Statements.Add(new ExpressionStatement(wait));

                node = while_stmt;          
            }
            else // val.type is INTEGER_TYPE
            {
                Block sleep = new Block();
                sleep.Statements = new StatementList();

                sleep.Statements.Add(EvictLockLeave(RWL,Shared));               

                AssemblyNode system = AssemblyNode.GetAssembly(typeof(System.String).Assembly);
                TypeNode thread = system.GetType(Identifier.For("System.Threading"), Identifier.For("Thread"));

                MethodCall call = new MethodCall();
                call.Callee = new QualifiedIdentifier(new MemberBinding(null, thread), Identifier.For("Sleep"));          
                call.Operands = new ExpressionList();
                Expression v = val.convert() as Expression;
                call.Operands.Add(v);
                call.SourceContext = sourceContext;                

                Try try_catch = new Try();
                try_catch.TryBlock = new Block();
                try_catch.TryBlock.Statements = new StatementList();

                try_catch.TryBlock.Statements.Add(new ExpressionStatement(call, sourceContext));

                ///=====
                try_catch.Finally = new Finally();
                try_catch.Finally.Block = new Block();
                try_catch.Finally.Block.Statements = new StatementList();
                try_catch.Finally.Block.Statements.Add(AWAIT.EvictLockEnter(RWL, Shared));
                sleep.Statements.Add(try_catch);
                node = sleep;
            }
            return node;
        }

        /// <summary>
        /// Generates statement to enter atomic interval
        /// </summary>
        /// <param name="_lock">object to lock on if thre is no RWL</param>
        /// <param name="RWL">reader writer lock</param>
        /// <param name="Shared">reader lock. only if RWL is true</param>
        /// <returns></returns>
        internal static Statement EvictLockLeave(bool RWL, bool Shared)
        {
            /*
             *  We need a better RWL lock. Till then use normal lock in all cases
             */

            Expression _lock = GetLockObject();

            AssemblyNode system = AssemblyNode.GetAssembly(typeof(System.Threading.Monitor).Assembly);
            TypeNode monitor = system.GetType(Identifier.For("System.Threading"), Identifier.For("Monitor"));


            Block unlock = new Block();
            unlock.Statements = new StatementList();

            // We need to pulse if !RWL lock. RWL does it in RTL

//            if (!RWL) -  Lock is always not RWL so far
//            {
                MethodCall pulse = new MethodCall();
                pulse.Operands = new ExpressionList();
                pulse.Callee = new QualifiedIdentifier(new MemberBinding(null, monitor), Identifier.For("PulseAll"));
                pulse.Operands.Add(_lock);
                unlock.Statements.Add(new ExpressionStatement(pulse));
//            }

            MethodCall call = new MethodCall();
            call.Operands = new ExpressionList();
            // First we release the lock. There must be a lock as await can be used only in a protected object                
            //if (RWL)
            //// Only in this case RWL lock apply
            //{
            //    if (Shared)
            //        // _lock.LeaveSharedMethod();
            //        call.Callee = new QualifiedIdentifier(Identifier.For("_lock"), Identifier.For("LeaveSharedMethod"));
            //    else
            //        // _lock.LeaveMethod();
            //        call.Callee = new QualifiedIdentifier(Identifier.For("_lock"), Identifier.For("LeaveMethod"));
            //}
            //else
            // System.Threading.Monitor
            {
                call.Callee = new QualifiedIdentifier(new MemberBinding(null, monitor), Identifier.For("Exit"));
                call.Operands.Add(_lock);
            }

            unlock.Statements.Add(new AssignmentStatement(Identifier.For("_ctowner"), new Literal((int)0, SystemTypes.Int32)));

            unlock.Statements.Add(new ExpressionStatement(call));

            return unlock;
        }

        internal static Expression GetLockObject()
        {
            Expression _lock = null;
            if (CONTEXT.current_unit is OBJECT_DECL) {
                _lock = new This();
            } else if (CONTEXT.current_unit is MODULE_DECL) {
                TypeNode typenode = (CONTEXT.current_unit as MODULE_DECL).convert() as TypeNode;
                UnaryExpression ldtoken = new UnaryExpression(new Literal(typenode, SystemTypes.RuntimeTypeHandle), NodeType.Ldtoken, SystemTypes.IntPtr);
                MethodCall type_of = new MethodCall(new MemberBinding(null, Runtime.GetTypeFromHandle), new ExpressionList(ldtoken), NodeType.Call, SystemTypes.Type);
                _lock = type_of;
            }
            else ERROR.InternalCompilerError("ECE33664");
            return _lock;
        }

        /// <summary>
        /// Generates statement to leave atomic interval
        /// </summary>
        /// <param name="_lock">object to lock on if thre is no RWL</param>
        /// <param name="RWL">reader writer lock</param>
        /// <param name="Shared">reader lock. only if RWL is true</param>
        /// <returns></returns>
        internal static Statement EvictLockEnter(bool RWL, bool Shared)
        {
            /*
             *  We need a better RWL lock. Till then use normal lock in all cases
             */

            Expression _lock = GetLockObject();

            AssemblyNode system = AssemblyNode.GetAssembly(typeof(System.Threading.Monitor).Assembly);
            TypeNode monitor = system.GetType(Identifier.For("System.Threading"), Identifier.For("Monitor"));
            TypeNode thread = system.GetType(Identifier.For("System.Threading"), Identifier.For("Thread"));
            Expression id = new QualifiedIdentifier(new QualifiedIdentifier(new MemberBinding(null, thread), Identifier.For("CurrentThread")), Identifier.For("ManagedThreadId"));

            MethodCall call = new MethodCall(); // do not reuse the previous call node!!!
            call.Operands = new ExpressionList();
            //if (RWL)
            //{
            //    if (Shared)
            //        // _lock.EnterSharedMethod();
            //        call.Callee = new QualifiedIdentifier(Identifier.For("_lock"), Identifier.For("EnterSharedMethod"));
            //    else
            //        // _lock.EnterMethod();
            //        call.Callee = new QualifiedIdentifier(Identifier.For("_lock"), Identifier.For("EnterMethod"));
            //}
            //else
            {
                call.Callee = new QualifiedIdentifier(new MemberBinding(null, monitor), Identifier.For("Enter"));
                call.Operands.Add(_lock);
            }
            ExpressionStatement lockEnter = new ExpressionStatement(call);
            Block enter = new Block();
            enter.Statements = new StatementList();
            enter.Statements.Add(lockEnter);
            enter.Statements.Add(new AssignmentStatement(Identifier.For("_ctowner"), id));
            return enter;
        }

        /// <summary>
        /// Generates statement to leave atomic interval
        /// </summary>
        /// <param name="_lock">object to lock on if thre is no RWL</param>
        /// <param name="RWL">reader writer lock</param>
        /// <param name="Shared">reader lock. only if RWL is true</param>
        /// <returns></returns>
        internal static Statement EvictLockEnterMethod(bool RWL, bool Shared)
        {
            /*
             *  We need a better RWL lock. Till then use normal lock in all cases
             */

            Expression _lock = GetLockObject();

            AssemblyNode system = AssemblyNode.GetAssembly(typeof(System.Threading.Monitor).Assembly);
            TypeNode monitor = system.GetType(Identifier.For("System.Threading"), Identifier.For("Monitor"));
            TypeNode thread = system.GetType(Identifier.For("System.Threading"), Identifier.For("Thread"));
            Expression id = new QualifiedIdentifier(new QualifiedIdentifier(new MemberBinding(null, thread), Identifier.For("CurrentThread")), Identifier.For("ManagedThreadId"));

            MethodCall call = new MethodCall(); // do not reuse the previous call node!!!
            call.Operands = new ExpressionList();

            call.Callee = new QualifiedIdentifier(new MemberBinding(null, monitor), Identifier.For("Enter"));
            call.Operands.Add(_lock);
            
            ExpressionStatement lockEnter = new ExpressionStatement(call);

            If ifs = new If();
            ifs.Condition = new BinaryExpression(Identifier.For("_ctowner"), id, NodeType.Eq);
            ifs.TrueBlock = new Block();
            ifs.FalseBlock = new Block();
            ifs.TrueBlock.Statements = new StatementList();
            ifs.TrueBlock.Statements.Add(new AssignmentStatement(Identifier.For("_unlock"), new Literal((Boolean)false, SystemTypes.Boolean)));
            ifs.FalseBlock.Statements = new StatementList();
            ifs.FalseBlock.Statements.Add(lockEnter);
            ifs.FalseBlock.Statements.Add(new AssignmentStatement(Identifier.For("_ctowner"), id));
            return ifs;
        }

        /// <summary>
        /// Generates statement to enter atomic interval
        /// </summary>
        /// <param name="_lock">object to lock on if thre is no RWL</param>
        /// <param name="RWL">reader writer lock</param>
        /// <param name="Shared">reader lock. only if RWL is true</param>
        /// <returns></returns>
        internal static Statement EvictLockLeaveMethod(bool RWL, bool Shared)
        {
            /*
             *  We need a better RWL lock. Till then use normal lock in all cases
             */

            Expression _lock = GetLockObject();

            AssemblyNode system = AssemblyNode.GetAssembly(typeof(System.Threading.Monitor).Assembly);
            TypeNode monitor = system.GetType(Identifier.For("System.Threading"), Identifier.For("Monitor"));


            Block unlock = new Block();
            unlock.Statements = new StatementList();

            // We need to pulse if !RWL lock. RWL does it in RTL

            //            if (!RWL) -  Lock is always not RWL so far
            //            {
            MethodCall pulse = new MethodCall();
            pulse.Operands = new ExpressionList();
            pulse.Callee = new QualifiedIdentifier(new MemberBinding(null, monitor), Identifier.For("PulseAll"));
            pulse.Operands.Add(_lock);
            unlock.Statements.Add(new ExpressionStatement(pulse));
            //            }

            MethodCall call = new MethodCall();
            call.Operands = new ExpressionList();

    
                call.Callee = new QualifiedIdentifier(new MemberBinding(null, monitor), Identifier.For("Exit"));
                call.Operands.Add(_lock);
            
            unlock.Statements.Add(new ExpressionStatement(call));

            If ifs = new If();
            ifs.Condition = Identifier.For("_unlock");
            ifs.TrueBlock = new Block();            
            ifs.TrueBlock.Statements = new StatementList();
            ifs.TrueBlock.Statements.Add(new AssignmentStatement(Identifier.For("_ctowner"), new Literal((int)0, SystemTypes.Int32)));
            ifs.TrueBlock.Statements.Add(unlock);

            return ifs;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("AWAIT");
            report_extra();

            if (val == null)
                return;
            val.report(shift+NODE.reportShift);
        }
#endif
    }

    public sealed class SEND_RECEIVE : STATEMENT {
        public EXPRESSION_LIST leftParts;
        public EXPRESSION      call; // right part

        //---------------------------------------------------------------------

        // Constructor
        public SEND_RECEIVE ( ) : base(ASTNodeType.SEND_RECEIVE) { }

        //---------------------------------------------------------------------

        public static SEND_RECEIVE create(EXPRESSION_LIST lp, EXPRESSION rp) {
            SEND_RECEIVE sr = new SEND_RECEIVE();

            sr.leftParts = lp;
            sr.call = rp;

            return sr;
        }

        public new void finalize(NODE enclosing) {
            base.finalize(enclosing);
        }

        //---------------------------------------------------------------------

        public override NODE resolve() {
            DECLARATION decl = this.getEnclosingDeclaration();
            if (decl is UNIT_DECL) ((UNIT_DECL)decl).activeBody = true;

            for ( int i=0, n=leftParts.Length; i<n; i++ )
                if (leftParts[i] != null)
                    leftParts[i].resolve();

            if (call != null)
                call.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // 'call' should by of type CALL.

            if (!(call is CALL) && !this.ErrorReported) {
                ERROR.WrongAssignmentLeft(this.sourceContext);
                this.ErrorReported = true;
                return false;
            }
            return call.validate();
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of the statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            // Here call's callee must be an activity instance.
            // CCI tree generation is implemented in the similar way that for
            // activity calls (see CALL.convert), but slightly differently,
            // because of a series of receivers.

            CALL        call = this.call as CALL; // validate() call above ensures this is non-null.
            DESIGNATOR  callee = call.callee;
            DECLARATION callee_decl = (DECLARATION)callee.resolve();

            if (!(callee_decl.type is ACTIVITY_TYPE) && !(callee_decl.type is ABSTRACT_ACTIVITY_TYPE)) {
                // Just a wrong assignment...
                if (!this.ErrorReported) {
                    ERROR.WrongAssignmentLeft(this.sourceContext);
                    this.ErrorReported = true;
                }
                return null;
            }

            // This is a common form of the send/receive construct:
            //
            //     x, y, z := a(expr1, expr2);
            //
            // It is mapped to the following code:
            //
            //     a.send(expr1).send(expr2);
            //     Leave lock
            //     x = (Typeof-x)a.receive();
            //     y = (Typeof-y)a.receive();
            //     z = (Typeof-z)a.receive();
            //     Enter lock

            Block block = new Block();
            block.Statements = new StatementList();
            block.SourceContext = this.sourceContext;

            Expression qualifier = (Expression)callee.convert();
            MethodCall send = null;

            if (call.arguments.Length > 0) {
                // There is a 'send' part in the statement.
                // Generate callee.send(expr1). ... .send(exprn);
                
                for (int i = 0, n = call.arguments.Length; i < n; i++) {
                    send = new MethodCall();
                    send.Callee = new QualifiedIdentifier(qualifier,Identifier.For("send"));
                    send.GiveErrorIfSpecialNameMethod = false; // ??
                    send.IsTailCall = false;
                 // send.NodeType
                    send.Operands = new ExpressionList(1);
                    send.Operands.Add((Expression)(call.arguments[i].convert()));
                    send.Type = (TypeNode)STANDARD.protocol.type.convert();

                    qualifier = send;
                }
                ExpressionStatement send_stmt = new ExpressionStatement(send);
                send_stmt.SourceContext = this.sourceContext;
                block.Statements.Add(send_stmt);
            }
            // Restore 'qualifier'
            qualifier = (Expression)callee.convert();

            // Enter lock
            bool RWL = getEnclosingUnit().modifiers.Shared;
            ROUTINE_DECL routine = CONTEXT.current_routine as ROUTINE_DECL;
            bool Shared = (routine == null) ? false : routine.modifiers.Shared;
            bool locked = getEnclosingUnit().modifiers.Protected;

            if (locked) block.Statements.Add(AWAIT.EvictLockLeave(RWL, Shared));

            // Generate code for 'receive' part:
            //
            //     x = (Typeof-x)callee.receive();
            //
            // for every designator from the left part of the assignment.
            Block assignments = new Block();
            assignments.Statements = new StatementList();

            for (int j = 0, m = this.leftParts.Length; j < m; j++) {
                AssignmentStatement assign = new AssignmentStatement();

                if (leftParts[j].Name == "#unused")
                    assign.Target = new MemberBinding(null, STANDARD.common.GetField(Identifier.For("_dummy")));
                else
                    assign.Target = (Expression)this.leftParts[j].convert();
                if (assign.Target == null)
                    continue; // because of an error...
                assign.Target.SourceContext = this.leftParts[j].sourceContext;

                    MethodCall receive = new MethodCall();
                    receive.Callee = new QualifiedIdentifier(qualifier,Identifier.For("receive"));
                    receive.Operands = new ExpressionList();  // no args
                    receive.SourceContext = callee.sourceContext;
                    receive.Type = SystemTypes.Object;
                
                if (leftParts[j].Name == "#unused")
                    assign.Source = receive;
                else{
                    TypeNode targetType = (TypeNode)leftParts[j].type.convert();

                    BinaryExpression right = 
                        new BinaryExpression(receive,new MemberBinding(null,targetType),NodeType.Castclass);

                    assign.Source = right;
                }
                assign.Source.SourceContext = callee.sourceContext;
                assign.SourceContext = this.sourceContext;

                assignments.Statements.Add(assign);
            }

            if (locked)
            {
                Try try_catch = new Try();
                try_catch.TryBlock = new Block();
                try_catch.TryBlock.Statements = new StatementList();

                try_catch.TryBlock.Statements.Add(assignments);

                ///=====
                try_catch.Finally = new Finally();
                try_catch.Finally.Block = new Block();
                try_catch.Finally.Block.Statements = new StatementList();
                try_catch.Finally.Block.Statements.Add(AWAIT.EvictLockEnter(RWL, Shared));

                block.Statements.Add(try_catch);
            }
            else
            {
                block.Statements.Add(assignments);
            }

            node = block;
            return node;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("SEND/RECEIVE");
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("RECEIVERS:");
            for ( int i=0, n=leftParts.Length; i<n; i++ )
                leftParts[i].report(shift+NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("SEND PART: ");
            if (call == null) {
                NODE.doShift(shift+NODE.reportShift);
                System.Console.WriteLine("MISSED");
            } else
                call.report(shift+NODE.reportShift);
        }
#endif
    }

    // LAUNCH
    // ======
    //
    public sealed class LAUNCH : STATEMENT {
        // Constructor
        public LAUNCH ( ) : base(ASTNodeType.LAUNCH) { }

        //---------------------------------------------------------------------

        public NEW call;

        //---------------------------------------------------------------------

        public static LAUNCH create(NEW call) {
            LAUNCH launch = new LAUNCH();
            launch.call = call;
            launch.call.enclosing = launch;
            return launch;
        }

        public new void finalize(NODE enclosing) {
            base.finalize(enclosing);
        }

        //---------------------------------------------------------------------

        public override NODE resolve() {
            if (call != null)
                call.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o
            if (call != null && !call.validate())
                return false;
            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates launch's type
        {
            // By definition, type of launch statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            node = new ExpressionStatement((Expression)call.convert());
            return node;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("LAUNCH");
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            call.report(shift+NODE.reportShift);
        }
#endif
    }

    public sealed class ACCEPT : STATEMENT {
        public EXPRESSION_LIST designators;

        //---------------------------------------------------------------------

        // Constructor
        public ACCEPT ( ) : base(ASTNodeType.ACCEPT) { designators = new EXPRESSION_LIST(); }

        //---------------------------------------------------------------------

        public static ACCEPT create() {
            ACCEPT sr = new ACCEPT();
            return sr;
        }

        public new void finalize(NODE enclosing) {
            base.finalize(enclosing);
        }

        //---------------------------------------------------------------------

        public override NODE resolve() {
            DECLARATION decl = this.getEnclosingDeclaration();
            if (decl is UNIT_DECL) ((UNIT_DECL)decl).activeBody = true;
            for ( int i=0, n=designators.Length; i<n; i++ )
                if (designators[i] != null)
                    designators[i].resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // ACCEPT node can appear only within activities.

            if (!(CONTEXT.current_routine is ACTIVITY_DECL) && !this.ErrorReported) {
                ERROR.SyntaxErrorIn("accept statement","it can appear only within an activity");
                this.ErrorReported = true;
                return false;
            }
            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of the statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            // Statements like
            //
            //     accept x, y;
            //
            // are mapped to a series of assignments:
            //     Leave lock
            //     x = (Typeof-x)protocol.accept();
            //     y = (Typeof-y)protocol.accept();
            //     Acquire lock
            //
            // where 'protocol' is the activity's parameter.

            bool RWL = getEnclosingUnit().modifiers.Shared;
            ROUTINE_DECL routine = CONTEXT.current_routine as ROUTINE_DECL;
            bool Shared = (routine == null) ? false : routine.modifiers.Shared;
            bool locked = getEnclosingUnit().modifiers.Protected;

            Block block = new Block();
            block.SourceContext = this.sourceContext;
            block.Statements = new StatementList();
            if(locked) block.Statements.Add(AWAIT.EvictLockLeave(RWL, Shared));

            Block assignments = new Block();
            assignments.Statements = new StatementList();

            for ( int i=0, n=designators.Length; i<n; i++ )
            {
                MethodCall rightCall = new MethodCall();
                rightCall.Callee = new QualifiedIdentifier(Identifier.For("protocol"),Identifier.For("accept"));
                rightCall.Operands = new ExpressionList();  // empty
                rightCall.SourceContext = designators[i].sourceContext;

                TypeNode rightType = null;

                if (designators[i].Name != "#unused") {
                    if (designators[i].type == null)
                        return null;
                    rightType = (TypeNode)designators[i].type.convert();
                    if (rightType == null)
                        return null;
                }

                AssignmentStatement assign = new AssignmentStatement();
                
                
                if (designators[i].Name == "#unused") {
                    assign.Source = rightCall;
                    assign.Target = new MemberBinding(null, STANDARD.common.GetField(Identifier.For("_dummy")));
                    // new QualifiedIdentifier(Identifier.For("Protocol"), Identifier.For("_dummy"));
                } else {
                    BinaryExpression rightPart =
                     new BinaryExpression(rightCall, new MemberBinding(null, rightType), NodeType.Castclass);
                    assign.Source = rightPart;
                    assign.Target = (Expression)designators[i].convert();
                }
                assign.Source.SourceContext = designators[i].sourceContext;
                assignments.Statements.Add(assign);
            }
            if (locked)
            {
                Try try_catch = new Try();
                try_catch.TryBlock = new Block();
                try_catch.TryBlock.Statements = new StatementList();

                try_catch.TryBlock.Statements.Add(assignments);

                ///=====
                try_catch.Finally = new Finally();
                try_catch.Finally.Block = new Block();
                try_catch.Finally.Block.Statements = new StatementList();
                try_catch.Finally.Block.Statements.Add(AWAIT.EvictLockEnter(RWL, Shared));
                block.Statements.Add(try_catch);
            }
            else
            {
                block.Statements.Add(assignments);
            }

            node = block;
            return node;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("ACCEPT line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("RECEIVERS:");
            for ( int i=0, n=designators.Length; i<n; i++ )
                designators[i].report(shift+NODE.reportShift);
        }
#endif
    }

/**********************

    // SEND
    // ====
    //
    public sealed class SEND : STATEMENT
    {
        // Constructor
        public SEND ( ) : base() { }

        //---------------------------------------------------------------------

        public DESIGNATOR channel;
        public EXPRESSION to_send;

        //---------------------------------------------------------------------

        public static SEND create ( DESIGNATOR d, EXPRESSION e )
        {
            SEND send = new SEND();
            send.channel = d;
            send.to_send = e;

            return send;
        }

        public new void finalize ( NODE enclosing )
        {
            base.finalize(enclosing);
        }

        //---------------------------------------------------------------------

        public override NODE resolve ( )
        {
            if ( channel != null ) channel.resolve();
            if ( to_send != null ) to_send.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o
            if ( channel != null && !channel.validate() ) return false;
            if ( to_send != null && !to_send.validate() ) return false;

            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates send's type
        {
            // By definition, type of send statement is VOID.
            get
            {
                if ( internal_type == null ) internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if ( node != null ) return node;

            resolve();
            if ( !validate() ) return null;

            return node;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report ( int shift )
        {
            report_unique(shift);
            System.Console.Write("SEND");
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("CHANNEL");
            if ( channel == null )
            {
                NODE.doShift(shift+NODE.reportShift);
                System.Console.WriteLine("MISSED");
            }
            else
                channel.report(shift+NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("TO SEND");
            if ( to_send == null )
            {
                NODE.doShift(shift+NODE.reportShift);
                System.Console.WriteLine("MISSED");
            }
            else
                to_send.report(shift+NODE.reportShift);
        }
#endif
    }

    // RECEIVE
    // =======
    //
    public sealed class RECEIVE : STATEMENT
    {
        // Constructor
        public RECEIVE ( ) : base() { }

        //---------------------------------------------------------------------

        public DESIGNATOR channel;
        public DESIGNATOR receiver;

        public bool   NonBlocking;

        //---------------------------------------------------------------------

        public static RECEIVE create ( bool nb, DESIGNATOR d1, DESIGNATOR d2 )
        {
            RECEIVE receive = new RECEIVE();
            receive.channel = d1;
            receive.receiver = d2;
            receive.NonBlocking = nb;

            return receive;
        }

        public new void finalize ( NODE enclosing )
        {
            base.finalize(enclosing);
        }

        //---------------------------------------------------------------------

        public override NODE resolve ( )
        {
            if ( channel != null ) channel.resolve();
            if ( receiver != null ) receiver.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o
            if ( channel != null && !channel.validate() ) return false;
            if ( receiver != null && !receiver.validate() ) return false;

            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates receive's type
        {
            // By definition, type of receive statement is VOID.
            get
            {
                if ( internal_type == null ) internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if ( node != null ) return node;

            resolve();
            if ( !validate() ) return null;

            return node;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report ( int shift )
        {
            report_unique(shift);
            System.Console.Write(NonBlocking?"ACCEPT":"RECEIVE");
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("CHANNEL");
            if ( channel == null )
            {
                NODE.doShift(shift+NODE.reportShift);
                System.Console.WriteLine("MISSED");
            }
            else
                channel.report(shift+NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("RECEIVER");
            if ( receiver == null )
            {
                NODE.doShift(shift+NODE.reportShift);
                System.Console.WriteLine("MISSED");
            }
            else
                receiver.report(shift+NODE.reportShift);
        }
#endif
    }

    // LAUNCH
    // ======
    //
    public sealed class LAUNCH : STATEMENT
    {
        // Constructor
        public LAUNCH ( ) : base() { }

        //---------------------------------------------------------------------

        public STATEMENT statement;

        //---------------------------------------------------------------------

        public static LAUNCH create ( )
        {
            LAUNCH launch = new LAUNCH();
            return launch;
        }

        public new void finalize ( NODE enclosing )
        {
            base.finalize(enclosing);
        }

        //---------------------------------------------------------------------

        public override NODE resolve ( )
        {
            if ( statement != null ) statement.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o
            if ( statement != null && !statement.validate() ) return false;

            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates launch's type
        {
            // By definition, type of launch statement is VOID.
            get
            {
                if ( internal_type == null ) internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // generates equivalent CCI sub-tree
        {
            if ( node != null ) return node;

            resolve();
            if ( !validate() ) return null;

            return node;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report ( int shift )
        {
            report_unique(shift);
            System.Console.Write("LAUNCH");
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            statement.report(shift+NODE.reportShift);
        }
#endif
    }
    
*****************************/

    // IF
    // ==
    //
    //   IfStatement = IF    Expression THEN StatementSequence
    //               { ELSIF Expression THEN StatementSequence }
    //               [ ELSE                  StatementSequence ]
    //                 END.
    //
    public sealed class IF : STATEMENT {
        // Constructor
        public IF ( ) : base(ASTNodeType.IF) { alternatives = new IF_PAIR_LIST(); }

        public static IF create ( ) { return new IF(); }

        public new void finalize(NODE enclosing) {
         // this.enclosing  -- later
            this.modifiers = null;
         // this.name       -- later
         // this.sourceContext  -- later?
         // this.type       -- later

            // Semantic processing
            base.finalize(enclosing);
        }

        //-------------------------------------------------------------------------

        public  SourceContext EndIfContext;

        private IF_PAIR_LIST alternatives;

        public IF_PAIR_LIST Alternatives { get { return alternatives; }}

        public void Add ( IF_PAIR if_pair ) { alternatives.Add(if_pair); }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            for (int i = 0; i < alternatives.Length; i++) {
                if (alternatives[i] == null)
                    continue;
                    scope = alternatives[i].findScopeAtContext(line, col, documentName);
                if (scope != null)
                    break;
                }
            return scope;
        }

        //-------------------------------------------------------------------------

        public override NODE resolve() {
            for (int i = 0, n = alternatives.Length; i < n; i++) {
                if ( alternatives[i].condition != null )
                    alternatives[i].condition.resolve();
                for ( int j=0, m=alternatives[i].statements.Length; j<m; j++ )
                    alternatives[i].statements[j].resolve();
            }
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o  All 'conditions' should be always of type BOOLEAN
            for (int i = 0, n = alternatives.Length; i < n; i++) {
                EXPRESSION condition = alternatives[i].condition;
                if (condition == null)
                    continue; // it's OK: the last condition can be null.
                if (!condition.validate())
                    return false;

                EXPRESSION extended = condition.extendProcType();
                if (extended != null) {
                    alternatives[i].condition = extended;
                    condition = extended;
                }
                if (condition.type is BOOLEAN_TYPE)
                    continue;
                if (condition.type is EXTERNAL_TYPE) {
                    Node t = ((EXTERNAL_TYPE)condition.type).entity;
                    if (t as Struct == SystemTypes.Boolean)
                        continue;
                }

                if (!ErrorReported) {
                    ErrorReported = true;
                    ERROR.IllegalConditionType(condition.sourceContext);
                    return false;
                }
            }
            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of if statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        private int i = 0;

        public override Node convert() {
            if (node != null)
                return null;

            resolve();
            if (!validate())
                return null;

            node = convert_internal();

            return node;
        }

        private Node convert_internal() {
            if (i >= alternatives.Length)
                return null;

            if (alternatives[i].condition != null) {
                object c = alternatives[i].condition.calculate();

                If if_stmt = new If();
                if (c != null && c is Boolean) {
                    if_stmt.Condition = new Literal(c, SystemTypes.Boolean);
                    ERROR.CompilerCalculatedValue("Condition", c.ToString(),
                    alternatives[i].sourceContext);
                } else {

                    Expression cond = null;
                    if (CONTEXT.useComputeMath) {
                        cond = MethodConverter.ConvertExpression(alternatives[i].condition, alternatives[i].condition.type);
                    }
                    if (cond != null) {
                        /*
                         * if OperationX.call(arg1, arg2, ...) then
                         */    
                        if_stmt.Condition = cond;
                    } else {
                        if_stmt.Condition = (Expression)alternatives[i].condition.convert();
                    }
                }
                if_stmt.TrueBlock = new Block();
                if_stmt.TrueBlock.Statements = new StatementList();
                for ( int j=0, n=alternatives[i].statements.Length; j<n; j++ )
                    if_stmt.TrueBlock.Statements.Add((Statement)alternatives[i].statements[j].convert());

                if_stmt.TrueBlock.SourceContext = alternatives[i].sourceContext;
                i++;

                Statement fb = (Statement)convert_internal();  // returns If or Block.
                if (fb is If) {
                    Block b = new Block();
                    b.Statements = new StatementList();
                    b.Statements.Add(fb);
                    b.SourceContext = fb.SourceContext;
                    fb = b;
                }
                if_stmt.FalseBlock = (Block)fb;
                if_stmt.SourceContext = this.sourceContext;

                if ( if_stmt.Condition != null ) // can occur because of an error
                    if_stmt.ConditionContext = if_stmt.Condition.SourceContext;
                if ( if_stmt.FalseBlock != null )
                    if_stmt.ElseContext = if_stmt.FalseBlock.SourceContext;
                if_stmt.EndIfContext = this.EndIfContext;

                return if_stmt;
            } else {
                Block block = new Block();
                block.Statements = new StatementList();
                for ( int j=0, n= alternatives[i].statements.Length; j<n; j++ )
                    block.Statements.Add((Statement)alternatives[i].statements[j].convert());
                block.SourceContext = alternatives[i].sourceContext;

                return block;
            }
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("IF STATEMENT, line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            for (int i = 0, n = alternatives.Length; i < n; i++) {
                alternatives[i].report(shift+NODE.reportShift);
            }
        }
#endif
    }

    // IF_PAIR
    // =======
    //
    public sealed class IF_PAIR : NODE ////////////////////////////////////////////
    {
        public EXPRESSION     condition;
        public STATEMENT_LIST statements;

        public IF_PAIR(IF if_stmt)
            : base(ASTNodeType.IF_PAIR, null) {
            this.enclosing = if_stmt;
            this.condition = null;
            this.statements = new STATEMENT_LIST();
        }

        public void Add ( EXPRESSION condition ) { this.condition = condition; }
        public void Add ( STATEMENT statement )  { statements.Add(statement); }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            if(condition != null) scope = condition.findScopeAtContext(line, col, documentName);
            if (scope == null)
            {
                for (int i = 0; i < statements.Length; i++)
                {
                    if (statements[i] == null) continue;
                    scope = statements[i].findScopeAtContext(line, col, documentName);
                    if (scope != null)
                        break;
                }
            }
            return scope;
        }

        public STATEMENT this[int i] {
            get { return this.statements[i]; }
            set { this.statements[i] = value; }
        }

        //------------------------------------------------------------------------------

        public override NODE resolve ( ) { return this; }
        public override bool validate ( )  { return true; }
        public override TYPE type  { get { return null; } set { } }

        //------------------------------------------------------------------------------

        public override Node convert() {
            return null;
        }

        //------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            // NODE.doShift(shift);
            report_unique(shift);
            System.Console.Write("IF CONDITION");
            report_extra();

            if (condition == null) {
                NODE.doShift(shift+NODE.reportShift);
                System.Console.WriteLine("MISSED");
            } else {
                condition.report(shift+NODE.reportShift);
            }

            // NODE.doShift(shift);
            report_unique(shift);
            System.Console.Write("IF STATEMENTS: ");
            if ( statements.Length == 0 )
                System.Console.WriteLine("MISSED");
            else {
                System.Console.WriteLine();
                for ( int i=0, n=statements.Length; i<n; i++ )
                    statements[i].report(shift+NODE.reportShift);
            }
        }
#endif
    }

    // CASE
    // ====
    //
    //   CaseStatement =  CASE Expression OF Case { "|" Case } [ ELSE StatementSequence ] END.
    //
    //   Case = [ CaseLabelList ":" StatementSequence ].
    //
    //   CaseLabelList = CaseLabels { "," CaseLabels }.
    //
    //   CaseLabels = ConstExpression [ ".." ConstExpression ].
    //
    public sealed class CASE : STATEMENT {
        // Constructor
        public CASE ( ) : base(ASTNodeType.CASE) { condition = null; cases = new CASE_ITEM_LIST(); }

        public static CASE create ( ) { return new CASE(); }

        public new void finalize(NODE enclosing) {
         // this.condition -- already set
         // this.enclosing -- later
            this.modifiers = null;
         // this.name      -- later
         // this.sourceContext  -- later?
         // this.type      -- later

            // Semantic processing

            base.finalize(enclosing);
        }

        //---------------------------------------------------------------------

        public  EXPRESSION      condition;
        private CASE_ITEM_LIST  cases;
        public CASE_ITEM_LIST Cases { get { return cases; } }

        public void Add ( CASE_ITEM case_item ) { cases.Add(case_item);  }

        //----------------------------------------------------------------------

        public override NODE resolve() {
            condition.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o  'condition' should be of type INTEGER, CARDINAL, CHAR, or ENUM;
            TYPE t = condition.type;
            if (t == null)
                return false;

            if (t is INTEGER_TYPE)
                goto Next;
            if (t is CARDINAL_TYPE)
                goto Next;
            if (t is ENUM_TYPE)
                goto Next;
            if (t is CHAR_TYPE)
                goto Next;

            ERROR.IllegalTypeOf(t.ToString(),"expression in CASE statement",condition.sourceContext);
            return false;

        Next:
            // All case labels should have unique values;
            // Ranges should not intersect.

            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of if statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //----------------------------------------------------------------------

        public override Node convert() {
            // System.Diagnostics.Debugger.Launch();
            int labelId = 0;
            if (node != null)
                return null;

            resolve();
            if (!validate())
                return null;

            Block mainBlock = new Block();
            mainBlock.Statements = new StatementList();

                VariableDeclaration sw = new VariableDeclaration();
                sw.Name = Identifier.For("sw");
                sw.Type = SystemTypes.Int32;
                    object e = condition.calculate();
                    if ( e != null )
                        ERROR.CompilerCalculatedValue("Expression in CASE statement",e.ToString(),condition.sourceContext);
                    BinaryExpression conv = new BinaryExpression();
                    conv.Operand1 = (Expression)condition.convert();
                    conv.Operand2 = new MemberBinding(null,SystemTypes.Int32);
                    conv.NodeType = NodeType.Castclass;
                sw.Initializer = conv;

            mainBlock.Statements.Add(sw);

            Switch swtch = new Switch();
            swtch.Cases = new SwitchCaseList();
            swtch.Expression = Identifier.For("sw");
            swtch.SourceContext = this.sourceContext;

            If if_stmt      = null;
            If last_if_stmt = null;

            Block defaultBlock = null;

            for (int i = 0, n = cases.Length; i < n; i++) {
                CASE_ITEM caseItem = cases[i];
                CNode c = (CNode)caseItem.convert();

                Expression currentExpr = null;

                if (c.expressions.Length == 0) {
                    defaultBlock = c.block;
                    continue;
                }

                Identifier prevLabel = null;
                SwitchCase prevCSE = null;
                for (int j = 0, m = c.expressions.Length; j < m; j++) {
                    Expression expr = c.expressions[j];
                    if (expr is Literal) {
                        SwitchCase cse = new SwitchCase();
                        if (prevCSE == null) {
                            prevCSE = cse;
                            cse.Body = new Block(new StatementList());
                            Block ls = new Block(); // Possibly a labled statement in future                            
                            ls.Statements = c.block.Statements;  // c.block;
                            cse.Body.Statements.Add(ls);
                            cse.Body.Statements.Add(new Exit());                          
                        } else {
                            // Goto prevTheSame block
                            if (prevLabel == null) // First reuse. Create a reference
                            {   // !!! Keep this code exactly as the same below #prevLabel
                                prevLabel = new Identifier("cs" + ((prevCSE.UniqueKey << 5) + labelId).ToString());
                                labelId++;
                                Statement oldStatement = ((Block)prevCSE.Body.Statements[0]);                                
                                LabeledStatement ls = new LabeledStatement();
                                ls.Label = prevLabel;
                                ls.Statement = oldStatement;
                                prevCSE.Body.Statements[0] = ls;
                            }
                            cse.Body = new Block(new StatementList());
                            cse.Body.Statements.Add(new Goto(prevLabel));
                        }
                           
                        cse.Label = expr;
                        swtch.Cases.Add(cse);

                    } else // expr is BinaryExpression
                    {
                        if ( currentExpr == null )
                            currentExpr = expr;
                        else {
                            BinaryExpression bin = new BinaryExpression();
                            bin.Operand1 = currentExpr;
                            bin.Operand2 = expr;
                            bin.NodeType = NodeType.Or;

                            currentExpr = bin;
                        }
                    }
                }  // end of loop trough expressions

                if (currentExpr != null) {
                    If new_if_stmt = new If();
                    new_if_stmt.Condition = currentExpr;
                    if (prevCSE == null)
                        new_if_stmt.TrueBlock = c.block;
                    else {
                        if (prevLabel == null) // First reuse. Create a reference
                        {   // !!! Keep this code exactly as the same above #prevLabel
                            prevLabel = new Identifier("cs" + ((prevCSE.UniqueKey << 5) + labelId).ToString());
                            labelId++;
                            StatementList oldBody = ((Block)prevCSE.Body.Statements[0]).Statements;
                            LabeledStatement ls = new LabeledStatement();
                            ls.Label = prevLabel;
                            ls.Statements = oldBody;
                            prevCSE.Body.Statements[0] = ls;
                        }
                        new_if_stmt.TrueBlock = new Block(new StatementList());
                        new_if_stmt.TrueBlock.Statements.Add(new Goto(prevLabel));
                    }

                    new_if_stmt.FalseBlock = new Block(new StatementList());

                    if ( if_stmt == null )
                        if_stmt = new_if_stmt;
                    else
                        last_if_stmt.FalseBlock.Statements.Add(new_if_stmt);

                    last_if_stmt = new_if_stmt;
                 }
            } // end of loop trough cases

            if (defaultBlock == null) {
                AssemblyNode rtlAssembly = AssemblyNode.GetAssembly(typeof(ZonnonHalt).Assembly);
                TypeNode     CaseError = rtlAssembly.GetType(Identifier.For("Zonnon.RTL"),Identifier.For("CaseError"));

                // throw new CaseError(l,c);
                Throw thro = new Throw();
                Construct ctor = new Construct();
                ctor.Constructor = new MemberBinding(null,CaseError);
                ctor.Type = CaseError;
                ctor.Operands = new ExpressionList();
                ctor.Operands.Add(new Literal((long)this.sourceContext.StartLine,SystemTypes.Int64));
                ctor.Operands.Add(new Literal((int)this.sourceContext.StartColumn,SystemTypes.Int32));
                thro.Expression = ctor;

                defaultBlock = new Block(new StatementList());
                defaultBlock.Statements.Add(thro);
            }

            if (last_if_stmt != null) {
                last_if_stmt.FalseBlock.Statements.Add(defaultBlock);

                defaultBlock = new Block(new StatementList());
                defaultBlock.Statements.Add(if_stmt);
            }

            SwitchCase def = new SwitchCase();
            def.Body  = defaultBlock;
            def.Label = null;
            swtch.Cases.Add(def);

            mainBlock.Statements.Add(swtch);

            node = mainBlock;
            return node;
        }

        //----------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("CASE STATEMENT, line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("CONDITION");
            if ( condition == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                condition.report(shift+NODE.reportShift);
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("CASES: ");
            if ( cases.Length == 0 )
                System.Console.WriteLine("MISSED");
            else {
                System.Console.WriteLine("{0}",cases.Length);
                for ( int i=0, n=cases.Length; i<n; i++ )
                    cases[i].report(shift+NODE.reportShift);
            }
        }
#endif
    }

    public sealed class CNode : Node {
        public CNode ( ) : base(NodeType.Nop) { }

        public ExpressionList expressions;
        public Block          block;
    }

    public sealed class CASE_ITEM : NODE //////////////////////////////////////
    {
        private RANGE_LIST     ranges;
        private STATEMENT_LIST statements;

        public CASE_ITEM(CASE case_stmt)
            : base(ASTNodeType.CASE_ITEM, null) {
            this.enclosing = case_stmt;
            this.ranges = new RANGE_LIST();
            this.statements = new STATEMENT_LIST();
        }

        public void Add ( RANGE range )         { ranges.Add(range); }
        public void Add ( STATEMENT statement ) { statements.Add(statement); }

        public int getRangeCount() { return ranges.Length; }
        public RANGE     getRange ( int index ) { return this.ranges[index]; }
        public int getStatementsCount() { return statements.Length; }
        public STATEMENT getStmt  ( int index ) { return this.statements[index]; }

        //------------------------------------------------------------------------------

        public override NODE resolve ( ) { return this; }
        public override bool validate ( )  { return true; }
        public override TYPE type  { get { return null; } set { } }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // returns CNode
        {
            if (node != null)
                return null;

            resolve();
            if (!validate())
                return null;

            Block block = new Block();
            block.Statements = new StatementList();
            for (int i = 0, n = statements.Length; i < n; i++) {
                STATEMENT s = statements[i];
                if (s == null)
                    continue;
                block.Statements.Add((Statement)s.convert());
            }            

            ExpressionList expressions = new ExpressionList();
            for (int i = 0, n = ranges.Length; i < n; i++) {
                RANGE range = ranges[i];
                Node r = range.convert();
                if (r == null)
                    continue;
                r.SourceContext = range.sourceContext;
                expressions.Add((Expression)r);
            }

            node = new CNode();
            ((CNode)node).expressions = expressions;
            ((CNode)node).block = block;

            return node;
        }


        //------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            NODE.doShift(shift);
            System.Console.WriteLine("CASE ITEM: line={0}", this.sourceContext.StartLine.ToString());

            for ( int i=0,n=ranges.Length; i<n; i++ )
                ranges[i].report(shift+NODE.reportShift);

            NODE.doShift(shift);
            System.Console.Write("CASE STATEMENTS: ");
            if ( statements.Length == 0 )
                System.Console.WriteLine("MISSED");
            else {
                System.Console.WriteLine();
                for ( int i=0, n=statements.Length; i<n; i++ )
                    statements[i].report(shift+NODE.reportShift);
            }
        }
#endif
    }

    public sealed class RANGE : NODE ////////////////////////////////////////
    {
        public EXPRESSION left_border;
        public EXPRESSION right_border;

        public RANGE(CASE_ITEM case_item)
            : base(ASTNodeType.RANGE, null) {
            this.enclosing = case_item;
            this.left_border = null;
            this.right_border = null;
        }

        //------------------------------------------------------------------------------

        public override NODE resolve() {
            if (left_border != null)
                left_border.resolve();
            if (right_border != null)
                right_border.resolve();
            return this; 
        }

        public override TYPE type  { get { return null; } set { } }

        //------------------------------------------------------------------------------

        public override bool validate() {
            bool err = false;
            TYPE mainType = ((CASE)enclosing.enclosing).condition.type;

            if (left_border is STRING_LITERAL && ((STRING_LITERAL)left_border).str.Length == 1) {
                char ch = ((STRING_LITERAL)left_border).str[0];
                left_border = CHAR_LITERAL.create(ch,left_border.sourceContext);
            }
            if (right_border is STRING_LITERAL && ((STRING_LITERAL)right_border).str.Length == 1) {
                char ch = ((STRING_LITERAL)right_border).str[0];
                right_border = CHAR_LITERAL.create(ch,right_border.sourceContext);
            }

            if ( left_border  == null || left_border.type == null || 
                 (right_border != null && right_border.type == null) )
                // Because of some errors before...
                return false;

         // if ( !TYPE.sameType(left_border.type,mainType) )
            if (!TYPE.sameTypeForCase(left_border.type, mainType)) {
                ERROR.IllegalTypeOf(left_border.type.ToString(),"case label",left_border.sourceContext);
                err = true;
            }
         // if ( right_border !=null && !TYPE.sameType(right_border.type,mainType) )
            if (right_border != null && !TYPE.sameTypeForCase(right_border.type, mainType)) {
                ERROR.IllegalTypeOf(right_border.type.ToString(),"case label",right_border.sourceContext);
                err = true;
            }
            return !err;
        }

        //------------------------------------------------------------------------------

        public override Node convert ( ) // returns either Literal or BinaryExpression
        {
            if (node != null)
                return null;

            resolve();
            if (!validate())
                return null;

            bool err = false;
            object l = left_border.calculate();
            object r = null;

            Expression left = null;
            Expression right = null;

            if (l == null) {
                ERROR.NonConstant(left_border.sourceContext,"case label");
                err = true;
            } else
                left = LITERAL.create(l,left_border.type, sourceContext);

            if (right_border != null) {
                r = right_border.calculate();
                if (r == null) {
                    ERROR.NonConstant(right_border.sourceContext,"case label");
                    err = true;
                } else
                    right = LITERAL.create(r,right_border.type, sourceContext);
            }
            if (err)
                return null;

            if ( right == null )
                node = left;
            else {
                // sw>=Left && sw<=Right

                Identifier sw = Identifier.For("sw");

                BinaryExpression lb = new BinaryExpression();
                lb.Operand1 = sw;
                lb.Operand2 = left;
                lb.NodeType = NodeType.Ge;

                BinaryExpression rb = new BinaryExpression();
                rb.Operand1 = sw;
                rb.Operand2 = right;
                rb.NodeType = NodeType.Le;

                BinaryExpression res = new BinaryExpression();
                res.Operand1 = lb;
                res.Operand2 = rb;
                res.NodeType = NodeType.And;

                node = res;
            }
            return node;
        }
        
        //------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            NODE.doShift(shift);
            System.Console.WriteLine("RANGE: ");

            if (left_border == null)
                return;
            left_border.report(shift+NODE.reportShift);

            if (right_border == null)
                return;
            right_border.report(shift+NODE.reportShift);
        }

        public override void report_short() {
            if (left_border == null)
                return;

            object val = left_border.calculate();
            if (val == null)
                System.Console.Write("<Expr>");
            else
                System.Console.Write(val);

            if (right_border == null)
                return;

            System.Console.Write("..");
            val = right_border.calculate();
            if (val == null)
                System.Console.Write("<Expr>");
            else
                System.Console.Write(val);
        }
#endif
    }

    // CYCLE
    // =====
    //
    public abstract class CYCLE : STATEMENT {
        public CYCLE ( ASTNodeType astNodeType ) : base(astNodeType) { statements = new STATEMENT_LIST(); }

        //------------------------------------------------------------

        public STATEMENT_LIST statements;

        //------------------------------------------------------------

        public override NODE resolve() {
            for ( int i=0, n=statements.Length; i<n; i++ )
                statements[i].resolve();
            return this;
        }

        //------------------------------------------------------------

        public abstract override bool validate ( );
        public abstract override TYPE type  { get; set; }
        public abstract override Node convert ( );
#if DEBUG
        public abstract override void report ( int shift );
#endif
    }

    // FOR
    // ===
    //
    //   ForStatement = FOR Ident ":=" Expression TO Expression [ BY ConstExpression ]
    //                  DO StatementSequence END.
    //
    public sealed class FOR : CYCLE {
        // Constructor
        public FOR ( ) : base(ASTNodeType.FOR) { }

        //----------------------------------------------------------------

        public DESIGNATOR forVar;  // should be INSTANCE in fact
        public EXPRESSION from;
        public EXPRESSION to;
        public EXPRESSION by;

        // public STATEMENT_LIST statements;  -- from BASE

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            if(forVar != null) scope = forVar.findScopeAtContext(line, col, documentName);
            if (scope == null && from != null) scope = from.findScopeAtContext(line, col, documentName);
            if (scope == null && to != null) scope = to.findScopeAtContext(line, col, documentName);
            if (scope == null && by != null) scope = by.findScopeAtContext(line, col, documentName);
            if (scope == null)
            {
                for (int i = 0; i < statements.Length; i++)
                {
                    if (statements[i] == null) continue;
                    scope = statements[i].findScopeAtContext(line, col, documentName);
                    if (scope != null)
                        break;
                }
            }
            return scope;
        }

        //----------------------------------------------------------------

        public static FOR create() {
            return new FOR();
        }

        public new void finalize(NODE enclosing) {
         // this.body -- already set
         // this.by   -- already set
         // this.enclosing -- later
         // this.forVar -- already set
         // this.from -- already set
            this.modifiers = null;
         // this.name -- later
         // this.sourceContext  -- later?
         // this.to -- already set

            base.finalize(enclosing);
        }

        //----------------------------------------------------------------

        public override NODE resolve() {
            forVar.resolve();
            if (from != null)
                from.resolve();
            if (to != null)
                to.resolve();
            if (by != null)
                by.resolve();
            base.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o  Both 'from' and 'to' expressions should be of the same type.
            // o  'from' and 'to' should be of type INTEGER or ENUM.
            // o  For-variable should be of the same type as both expressions.
            // o  'by' (if any) should be constant of type INTEGER.

            // 1. FROM & TO

            if (this.from == null)
                return false;
            if (this.to == null)
                return false;
            
            bool success = true;

            if (!from.validate() || !to.validate())
                success = false;

            EXPRESSION extended = from.extendProcType();
            if (extended != null)
                from = extended;
            extended = to.extendProcType();
            if (extended != null)
                to = extended;

            

            TYPE type_from = this.from.type;
            TYPE type_to   = this.to.type;

            if (type_from == null || type_to == null) {
                // An error was before
                success = false;
            } else {
                if (!(type_from is INTEGER_TYPE) && !(type_from is CARDINAL_TYPE) && !(type_from is ENUM_TYPE)) {
                    if (!from.ErrorReported) {
                        ERROR.IllegalTypeOf(type_from.ToString(),"the from-expression in the for-statement",from.sourceContext);
                        from.ErrorReported = true;
                    }
                    success = false;
                }
                if (!(type_to is INTEGER_TYPE) && !(type_to is CARDINAL_TYPE) && !(type_to is ENUM_TYPE)) {
                    if (!to.ErrorReported) {
                        ERROR.IllegalTypeOf(type_to.ToString(),"the to-expression in the for-statement",to.sourceContext);
                        to.ErrorReported = true;
                    }
                    success = false;
                }
            }

            TYPE wrong = null;
            if (type_from is ENUM_TYPE && !(type_to is ENUM_TYPE))
                wrong = type_to;
            if (type_to is ENUM_TYPE && !(type_from is ENUM_TYPE))
                wrong = type_from;
            if (wrong != null) {
                if (!this.ErrorReported) {
                    ERROR.IllegalTypeOf(wrong.ToString(),"the expression(s) in the for-statement",this.sourceContext);
                    this.ErrorReported = true;
                }
                success = false;
            }

            // 2. FOR var :=

            if (!(forVar is INSTANCE)) {
                if (!forVar.ErrorReported) {
                    ERROR.IllegalForVariable(forVar.sourceContext);
                    forVar.ErrorReported = true;
                }
                success = false;
            } else // forVar is INSTANCE
            {
                DECLARATION v = (DECLARATION)forVar.resolve();

                if (  v.type is INTEGER_TYPE  || 
                      v.type is CARDINAL_TYPE ||
                    (v.type is ENUM_TYPE && type_from is ENUM_TYPE)) {
                    // It's OK, going on
                } else if (!(v is UNKNOWN_DECL)) {
                    if (!forVar.ErrorReported) {
                        ERROR.IllegalTypeOf(v.type.ToString(),"for-variable",forVar.sourceContext);
                        forVar.ErrorReported = true;
                    }
                    success = false;
                }
            }

            // 3. BY

            if (by != null) {
                object val = by.calculate();
                if (val == null) {
                    if (!by.ErrorReported) {
                        ERROR.NonConstant(by.sourceContext,"step specification");
                        by.ErrorReported = true;
                    }
                    success = false;
                } else if (!(val is long) && !(val is int)) {
                    ERROR.IllegalTypeOf(by.type.ToString(),"step value",by.sourceContext);
                    success = false;
                } else if ((val is long && (long)val == 0) || (val is int && (int)val == 0)) {
                    ERROR.ZeroStepValue(by.sourceContext);
                    success = false;
                } else
                    by = INTEGER_LITERAL.create((long)val);
            } else
                by = INTEGER_LITERAL.create(1L);

            return success;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of if statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            For forStatement = new For();
         // forStatement.NodeType;
            forStatement.SourceContext = base.sourceContext;

            // Making for-statement's body
            forStatement.Body = new Block();
            forStatement.Body.Checked = true;
            forStatement.Body.HasLocals = false;
         // forStatement.Body.NodeType;
         // forStatement.Body.Scope;
            forStatement.Body.SourceContext = base.sourceContext;
            forStatement.Body.SuppressCheck = false;
            forStatement.Body.Statements = new StatementList();
            for ( int i=0, n=statements.Length; i<n; i++)
                forStatement.Body.Statements.Add((Statement)(statements[i].convert()));

            // Making condition
            BinaryExpression condition = new BinaryExpression();
            if ( by is INTEGER_LITERAL && ((INTEGER_LITERAL)by).integer < 0 )
                condition.NodeType = NodeType.Ge;
            else
                condition.NodeType = NodeType.Le;
            condition.Operand1 = (Expression)forVar.convert(); // ((DECLARATION)forVar.resolve()).name;
            condition.Operand2 = (Expression)to.convert();
            condition.SourceContext = to.sourceContext;

            forStatement.Condition = condition;

            // Making incrementer
            forStatement.Incrementer = new StatementList();

            AssignmentStatement assignment = new AssignmentStatement();

            assignment.NodeType = NodeType.AssignmentStatement;
            assignment.Operator = NodeType.Add;  // Hope this means +=
         // assignment.OperatorOverload
            assignment.Source = ( by != null ) ? (Expression)by.convert() : new Literal(1,SystemTypes.Int32);
            assignment.SourceContext = base.sourceContext;
            assignment.Target = (Expression)forVar.convert(); // ((DECLARATION)forVar.resolve()).name;

            forStatement.Incrementer.Add(assignment);

            // Making initializer
            forStatement.Initializer = new StatementList();

            AssignmentStatement initializer = new AssignmentStatement();
            initializer.NodeType = NodeType.AssignmentStatement;
            initializer.Operator = NodeType.Nop;  // this means "normal" assignment, but not += etc.
            initializer.Source = (Expression)from.convert();
                Node tmp = forVar.convert(); // ((DECLARATION)forVar.resolve()).name;
            if (tmp == null)
                return null; // an error before
            initializer.Target = (Expression)tmp.Clone();
            initializer.SourceContext = from.sourceContext;

            forStatement.Initializer.Add(initializer);

            node = forStatement;
            return node;
        }

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("FOR LOOP, line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("LOOP VAR");
            forVar.report(shift+NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("FROM");
            from.report(shift+NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.WriteLine("TO");
            to.report(shift+NODE.reportShift);

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("BY");
            if ( by == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                by.report(shift+NODE.reportShift);
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("FOR BODY");
            if ( statements == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                for ( int i=0, n=statements.Length; i<n; i++ )
                    statements[i].report(shift+NODE.reportShift);
            }
        }
#endif
    }

    // WHILE
    // =====
    //
    //   WhileStatement = WHILE Expression DO StatementSequence END.
    //
    public sealed class WHILE : CYCLE {
        // Constructor
        public WHILE ( ) : base(ASTNodeType.WHILE) { }

        //----------------------------------------------------------------

        public EXPRESSION     condition;
     // public STATEMENT_LIST statements; -- from BASE

        //----------------------------------------------------------------

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            if(condition != null) scope = condition.findScopeAtContext(line, col, documentName);
            if (scope == null)
            {
                for (int i = 0; i < statements.Length; i++)
                {
                    if (statements[i] == null) continue;
                    scope = statements[i].findScopeAtContext(line, col, documentName);
                    if (scope != null)
                        break;
                }
            }
            return scope;
        }

        public static WHILE create() {
            return new WHILE();
        }

        public new void finalize(NODE enclosing) {
            // this.body           -- already set
            // this.condition      -- already set
            // this.enclosing      -- later
            // this.modifiers      -- already set
            // this.name           -- later
            // this.sourceContext  -- later?
            // this.type           -- later

            // Semantic processing

            base.finalize(enclosing);
        }

        //----------------------------------------------------------------

        public override NODE resolve() {
            if (condition != null) {
                condition.resolve();
            } else {
                ERROR.MissingCondition(this.sourceContext);
            }
            base.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            if (condition == null) {
                ERROR.MissingCondition(sourceContext);
                return false;
            }
            EXPRESSION extended = condition.extendProcType();
            if (extended != null)
                condition = extended;
            condition.validate();
            // o Condition should be of type BOOLEAN
            if (condition.type is BOOLEAN_TYPE)
                return true;
            if ( (condition.type is EXTERNAL_TYPE)
                && (((EXTERNAL_TYPE)condition.type).entity is TypeNode)
                && (((TypeNode)(((EXTERNAL_TYPE)condition.type).entity)).TypeCode == TypeCode.Boolean)
                )
                return true;

            string t = null;
            if (condition.type != null)
                t = condition.type.ToString();
            else
                t = "(unknown type)";
            ERROR.IllegalTypeOf(t,"condition in WHILE statement",condition.sourceContext);
            return false;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of if statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            While while_loop = new While();

            while_loop.SourceContext = base.sourceContext;
            while_loop.Body = new Block();
            while_loop.Body.Statements = new StatementList();
            for ( int i=0, n=statements.Length; i<n; i++ )
                while_loop.Body.Statements.Add((Statement)statements[i].convert());

            object c = condition.calculate();
            if (c != null && c is Boolean) {
                while_loop.Condition = new Literal(c, SystemTypes.Boolean);
                ERROR.CompilerCalculatedValue("Condition in WHILE statement", c.ToString(), condition.sourceContext);
            } else {

                Expression cond = null;
                if (CONTEXT.useComputeMath) {
                    cond = MethodConverter.ConvertExpression(condition, condition.type);
                }
                if (cond != null) {
                    /*
                     * while OperationX.call(arg1, arg2, ...) do
                     */
                    while_loop.Condition = cond;
                } else {
                    while_loop.Condition = (Expression)condition.convert();
                }
            }
            if ( while_loop.Condition != null )
                 while_loop.Condition.SourceContext = condition.sourceContext;
            node = while_loop;
            return node;
        }

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("WHILE LOOP line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("CONDITION");
            if ( condition == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                condition.report(shift+NODE.reportShift);
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("LOOP BODY");
            if ( statements == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                for ( int i=0, n=statements.Length; i<n; i++ )
                    statements[i].report(shift+NODE.reportShift);
            }
        }
#endif
    }

    // REPEAT
    // ======
    //
    //   RepeatStatement = REPEAT StatementSequence UNTIL Expression.
    //
    public sealed class REPEAT : CYCLE {
        // Constructor
        public REPEAT ( ) : base(ASTNodeType.REPEAT) { }

        //--------------------------------------------------------------

        public EXPRESSION     condition;
     // public STATEMENT_LIST statements;  -- from BASE

        //--------------------------------------------------------------

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            if(condition != null) scope = condition.findScopeAtContext(line, col, documentName);
            if (scope == null)
            {
                for (int i = 0; i < statements.Length; i++)
                {
                    if (statements[i] == null) continue;
                    scope = statements[i].findScopeAtContext(line, col, documentName);
                    if (scope != null)
                        break;
                }
            }
            return scope;
        }

        public static REPEAT create() {
            return new REPEAT();
        }

        public new void finalize(NODE enclosing) {
         // this.body           -- already set
         // this.condition      -- already set
         // this.enclosing      -- later
         // this.modifiers      -- already set
         // this.name           -- later
         // this.sourceContext  -- later?
         // this.type           -- later

            // Semantic processing

            base.finalize(enclosing);
        }

        //--------------------------------------------------------------

        public override NODE resolve() {
            condition.resolve();
            base.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            EXPRESSION extended = condition.extendProcType();
            if (extended != null)
                condition = extended;

            // o Condition should be of type BOOLEAN
            if (condition.type is BOOLEAN_TYPE)
                return true;

            string t = null;
            if (condition.type != null)
                t = condition.type.ToString();
            else
                t = "(unknown type)";
            ERROR.IllegalTypeOf(t,"condition in REPEAT statement",condition.sourceContext);
            return false;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of if statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            DoWhile repeat = new DoWhile();

            repeat.SourceContext = base.sourceContext;
            repeat.Body = new Block();
            repeat.Body.Statements = new StatementList();
            for ( int i=0, n=statements.Length; i<n; i++ )
                repeat.Body.Statements.Add((Statement)statements[i].convert());

            object c = condition.calculate();
            if (c != null && c is Boolean) {
                repeat.Condition = new Literal(!(bool)c,SystemTypes.Boolean);
                ERROR.CompilerCalculatedValue("Condition in REPEAT statement",c.ToString(),condition.sourceContext);
            } else {
                UnaryExpression until_condition = new UnaryExpression();
                until_condition.NodeType = NodeType.LogicalNot;  // 'Neg' means unary minus

                Expression cond = null;
                if (CONTEXT.useComputeMath) {
                    cond = MethodConverter.ConvertExpression(condition, condition.type);
                }
                if (cond != null) {
                    until_condition.Operand = cond;
                } else {
                    until_condition.Operand = (Expression)condition.convert();
                }                

                repeat.Condition = until_condition;

             // repeat.Condition = (Expression)condition.convert();
            }
            node = repeat;
            return node;
        }

#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("REPEAT LOOP line={0}", this.sourceContext.StartLine.ToString());
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("CONDITION");
            if ( condition == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                condition.report(shift+NODE.reportShift);
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("LOOP BODY");
            if ( statements == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                for ( int i=0, n=statements.Length; i<n; i++ )
                    statements[i].report(shift+NODE.reportShift);
            }
        }
#endif
    }

    // LOOP
    // ====
    //
    //   LoopStatement = LOOP StatementSequence END.
    //
    public sealed class LOOP : CYCLE {
        public LOOP(Identifier Label) : base(ASTNodeType.LOOP) { this.Label = Label; }
        public Identifier Label;
        public bool LabelUsed = false;
        //-----------------------------------------------------------------

        // public STATEMENT_LIST statements; -- from BASE
        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            for (int i = 0; i < statements.Length; i++) {
                if (statements[i] == null)
                    continue;
                    scope = statements[i].findScopeAtContext(line, col, documentName);
                if (scope != null)
                    break;
                }

            return scope;
        }

        //-----------------------------------------------------------------

        public static LOOP create() {
            return new LOOP(CONTEXT.GetNextLabel());
        }

        public new void finalize(NODE enclosing) {
         // loop.body           -- already set
         // loop.condition      -- already set
         // loop.enclosing      -- later
         // loop.modifiers      -- already set
         // loop.name           -- later
         // loop.sourceContext  -- later?
         // loop.type           -- later

            // Semantic processing

            base.finalize(enclosing);
        }

        //-----------------------------------------------------------------
        public override NODE resolve() {
            base.resolve();
            return this;
        }

        //---------------------------------------------------------------------

        public override bool validate ( )  // checks semantical correctness
        {
            // o ...
            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of if statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;

            
            LabeledStatement lbst = new LabeledStatement();
            lbst.Label = Label;

            While while_loop = new While();

            
            while_loop.SourceContext = base.sourceContext;
            while_loop.Condition = new Literal(true,SystemTypes.Boolean);
            while_loop.Body = new Block();
            while_loop.Body.Statements = new StatementList();
            for ( int i=0, n=statements.Length; i<n; i++ )
                while_loop.Body.Statements.Add((Statement)statements[i].convert());

            Block block = new Block();
            block.Statements = new StatementList();
            block.Statements.Add(while_loop);
            block.Statements.Add(lbst);
            if (LabelUsed)
                node = block;
            else
                node = while_loop;
            return node;
        }

        //-------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("INFINITE LOOP");
            report_extra();

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("LOOP BODY");
            if ( statements == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                for ( int i=0, n=statements.Length; i<n; i++ )
                    statements[i].report(shift+NODE.reportShift);
            }
        }
#endif
    }

    // BLOCK
    // =====
    //
    //   BlockStatement = BEGIN [ BlockModifiers ] StatementSequence [ Exception { Exception } ] END.
    //
    //   Exception = ON [ QualIdent { "," QualIdent } ] DO StatementSequence
    //             | ON EXCEPTION                       DO StatementSequence
    //             | ON TERMINATION                     DO StatementSequence.
    //
    public sealed class BLOCK : STATEMENT {
        // Constructor
        public BLOCK()
            : base(ASTNodeType.BLOCK) {
            statements = new STATEMENT_LIST();
            exceptions = new EXCEPTION_LIST();
            termination = new BLOCK(1);
            termination.enclosing = this;
        }

        private BLOCK(int simple)
            : base(ASTNodeType.BLOCK) {
            statements = new STATEMENT_LIST();
        }

        protected override NODE findSubScopeAtContext(int line, int col, string documentName)
        {
            NODE scope = null;
            for (int i = 0; i < statements.Length; i++) {
                if (statements[i] == null)
                    continue;
                    scope = statements[i].findScopeAtContext(line, col, documentName);
                if (scope != null)
                    break;
                }
            if (exceptions != null && scope == null) {
                for (int i = 0; i < exceptions.Length; i++) {
                    if (exceptions[i] == null)
                        continue;
                        scope = exceptions[i].findScopeAtContext(line, col, documentName);
                    if (scope != null)
                        break;
                    }
                }
                //Do not visit termination
            return scope;
        }


        //-----------------------------------------------------------------

        public STATEMENT_LIST statements;
        public EXCEPTION_LIST exceptions;
        public BLOCK          termination;

        private bool createBarrier = false;


        public int useBarrier() {
            // check if we need to enforce barrier
            if (enclosing is MODULE_DECL || enclosing is ROUTINE_DECL) {
                this.modifiers.Barrier = true;
            }
            if (! this.modifiers.Barrier) // No barrier for current block
            { // Check enclosing
                return (getEnclosingBlock() != null) ? getEnclosingBlock().useBarrier() : 0;
            } else {// Barrier for the current block is used and will be generated
                createBarrier = true;
                return this.unique; // ID of block as a id for barrier
            }
        }
        
        //-----------------------------------------------------------------

        public static BLOCK create(NODE enclosing) {
            System.Diagnostics.Debug.Assert(enclosing != null);
            BLOCK block = new BLOCK();
            block.enclosing = enclosing;

            return block;
        }

        //-----------------------------------------------------------------

        public override NODE resolve() {
            for ( int i=0, n=statements.Length; i<n; i++ )
                statements[i].resolve();

            for (int i = 0, n = exceptions.Length; i < n; i++) {
                for ( int j=0, m=exceptions[i].types.Length; j<m; j++ )
                    exceptions[i].types[j].resolve();

                for ( int j=0, m=exceptions[i].statements.Length; j<m; j++ )
                    exceptions[i].statements[j].resolve();
            }
            if ( termination != null )
                for ( int i=0, n=termination.statements.Length; i<n; i++ )
                    termination.statements[i].resolve();

            return this;
        }

        //---------------------------------------------------------------------
        bool CFGAnalysed = false;
        // We implement protocol validation here. Call it only for the top most block.
        // Build simplified CFG (SCFG)
        public override bool validate ( )  // checks semantical correctness
        {
            // Do not release until stable
            // return true;
            //
            if (ErrorReported) return false;

            // Below is code for protocol validation. DEACTIVATED TODO: Fix and activate
            //if (this.enclosing is DECLARATION && !CFGAnalysed)
            //{ //It's the top most block. Build CFG. Once per block
            //    CFGAnalysed = true;
            //    if (this.enclosing is ACTIVITY_DECL)
            //        aprot = ((ACTIVITY_DECL)this.enclosing).prototype as PROTOCOL_DECL;
            //    ProtocolValidator pv = new ProtocolValidator(cfg, aprot);
            //    bool ok = pv.Validate(this.enclosing.sourceContext);
            //    if (!ok) ErrorReported = true;
            //    return ok;
            //}
            return true;
        }

        //---------------------------------------------------------------------

        public override TYPE type  // evaluates call's type
        {
            // By definition, type of if statement is VOID.
            get {
                if (internal_type == null)
                    internal_type = new VOID_TYPE();
                return internal_type;
            }
            set { }
        }

        //------------------------------------------------------------------------------

        public override Node convert() {
            if (node != null)
                return node;

            resolve();
            if (!validate())
                return null;
            bool locked = getEnclosingUnit().modifiers.Protected;
            bool RWL = getEnclosingUnit().modifiers.Protected && getEnclosingUnit().modifiers.Shared;
            bool Shared = false;
            if (getEnclosingDeclaration() is ROUTINE_DECL) Shared = getEnclosingDeclaration().modifiers.Shared;

            if (this.exceptions.Length == 0) {
                Block block = new Block();
                block.Checked = true;
                block.HasLocals = false;
             // block.NodeType;
             // block.Scope;
                block.SourceContext = base.sourceContext;
                block.SuppressCheck = false;

                block.Statements = new StatementList();
                if ( createBarrier ) 
                    block.Statements.Add(PROCEDURE_DECL.generateEntryBarrier(this.unique));
                for ( int i=0,n=statements.Length; i<n; i++)
                    block.Statements.Add((Statement)(statements[i].convert()));
                if (createBarrier)
                    block.Statements.Add(PROCEDURE_DECL.generateLeaveBarrier(locked, RWL, Shared, this.unique));
                
                node = block;
            } else {
                Try try_block = new Try();

                try_block.TryBlock = new Block();
                try_block.TryBlock.Checked = true;
                try_block.TryBlock.HasLocals = false;
             // try_block.TryBlock.NodeType;
             // try_block.TryBlock.Scope;
                try_block.TryBlock.SourceContext = base.sourceContext;
                try_block.TryBlock.SuppressCheck = false;

                try_block.TryBlock.Statements = new StatementList();
                if ( this.createBarrier ) 
                    try_block.TryBlock.Statements.Add(PROCEDURE_DECL.generateEntryBarrier(this.unique));
                for ( int i=0,n=statements.Length; i<n; i++)
                    try_block.TryBlock.Statements.Add((Statement)(statements[i].convert()));
                if (this.createBarrier)
                    try_block.TryBlock.Statements.Add(PROCEDURE_DECL.generateLeaveBarrier(locked, RWL, Shared, this.unique));
                

                try_block.Catchers = new CatchList();
                for (int i = 0, n = this.exceptions.Length; i < n; i++) {
                    EXCEPTION exception = this.exceptions[i];

                    if (exception.types.Length == 0) {
                        Catch catcher = new Catch();
                        catcher.Block = new Block();
                        catcher.Block.Statements = new StatementList();
                        for ( int j=0, k=exception.statements.Length; j<k; j++ )
                            catcher.Block.Statements.Add((Statement)exception.statements[j].convert());
                        catcher.Type = null;
                        catcher.Variable = null;

                        try_block.Catchers.Add(catcher);
                    } else {
                        for (int j = 0, m = exception.types.Length; j < m; j++) {
                            Catch catcher = new Catch();
                            catcher.Block = new Block();
                            catcher.Block.Statements = new StatementList();
                            for ( int k=0, p=exception.statements.Length; k<p; k++ )
                                catcher.Block.Statements.Add((Statement)exception.statements[k].convert());
                            catcher.Type = (TypeNode)exception.types[j].convert();
                            catcher.Variable = null;

                            try_block.Catchers.Add(catcher);
                        }
                    }
                }
                if (termination != null && termination.statements.Length != 0) {
                    Finally fin = new Finally();
                    fin.Block = new Block(new StatementList());
                 // fin.SourceContext = 
                    for ( int i=0, n=termination.statements.Length; i<n; i++ )
                        fin.Block.Statements.Add((Statement)termination.statements[i].convert());
                    try_block.Finally = fin;
                }
                node = try_block;
            }

            return node;
        }

        //--------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("BLOCK STATEMENT, line={0}", this.sourceContext.StartLine);
            report_extra();

            if (this.createBarrier) {
                NODE.doShift(shift+NODE.reportShift);
                System.Console.WriteLine("Barrier: {0}",this.unique);
                if ( statements == null )
                    System.Console.WriteLine(" MISSED");
            }

            if ((comments != null) && (comments.Length > 0)) {
				for (int i = 0; i < comments.Length; i++)
					comments[i].report(shift + reportShift);
			}

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("STATEMENTS:");
            if ( statements == null )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine(" {0}",statements.Length);
                for ( int i=0, n=statements.Length; i<n; i++ )
                    statements[i].report(shift+NODE.reportShift);
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("EXCEPTIONS:");
            if ( exceptions == null || exceptions.Length == 0 )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine(" {0}",exceptions.Length);
                for ( int i=0, n=exceptions.Length; i<n; i++ )
                    exceptions[i].report(shift+NODE.reportShift);
            }

            NODE.doShift(shift+NODE.reportShift);
            System.Console.Write("TERMINATION:");
            if ( termination == null || termination.statements.Length == 0 )
                System.Console.WriteLine(" MISSED");
            else {
                System.Console.WriteLine();
                for ( int i=0, n=termination.statements.Length; i<n; i++ )
                    termination.statements[i].report(shift+2*NODE.reportShift);
            }
        }
#endif
    }

    public sealed class EXCEPTION : NODE /////////////////////////////////////////////
    {
        public TYPE_LIST      types;
        public STATEMENT_LIST statements;

        //-----------------------------------------------------------------

        public EXCEPTION()
            : base(ASTNodeType.EXCEPTION, null) {
            this.types = new TYPE_LIST();
            this.statements = new STATEMENT_LIST();
        }

        public EXCEPTION(int n)
            : base(ASTNodeType.EXCEPTION, null) {
            this.types = new TYPE_LIST(n);
            this.statements = new STATEMENT_LIST(n);
        }

        //------------------------------------------------------------------

        public static EXCEPTION create(NODE enclosing) {
            EXCEPTION exception = new EXCEPTION();

            exception.enclosing = enclosing;
            exception.modifiers = null;
         // exception.name = null;
         // exception.sourceContext = -------------
         // exception.type = null;

            return exception;
        }

        //------------------------------------------------------------------

        public void Add ( TYPE type )           { types.Add(type); }
        public void Add ( STATEMENT statement ) { statements.Add(statement); }

        public TYPE      getType ( int index ) { return this.types[index]; }
        public STATEMENT getStmt ( int index ) { return this.statements[index]; }

        //------------------------------------------------------------------

        public override NODE resolve ( ) { return this; }
        public override bool validate ( ) { return true; }
        public override TYPE type { get { return null; } set { } }

        //------------------------------------------------------------------

        public override Node convert ( ) { return null; }

        //------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            NODE.doShift(shift);
            System.Console.Write("EXCEPTION TYPES: ");
            if ( types.Length == 0 )
                System.Console.WriteLine("MISSED");
            else {
                for ( int i=0, n=types.Length; i<n; i++ )
                    System.Console.Write(" {0}:{1}",types[i].unique,types[i].name);
                System.Console.WriteLine();
            }

            NODE.doShift(shift);
            System.Console.Write("EXCEPTION STATEMENTS: ");
            if ( statements.Length == 0 )
                System.Console.WriteLine("MISSED");
            else {
                System.Console.WriteLine();
                for ( int i=0, n=statements.Length; i<n; i++ )
                    statements[i].report(shift+NODE.reportShift);
            }
        }
#endif
    }

    public sealed class MODIFIERS {
        private BitArray modifiers;
     // private int      precedence;

        public const int posPrivate    =  0;
        public const int posPublic     =  1;
        public const int posSealed     =  2;
        public const int posImmutable  =  3;
        public const int posReference  =  4;
        public const int posValue      =  5;
        public const int posLocked     =  6;
        public const int posConcurrent =  7;
        public const int posBarrier    =  8;
        public const int posGetter     =  9;
        public const int posSetter     = 10;
		public const int posProtected  = 11;
		public const int posShared	   = 12;
        public const int posActor      = 13;

        public MODIFIERS() {
            modifiers = new BitArray(20);
            modifiers.SetAll(false);
         // precedence = -1;
        }

        public bool getModifier ( int pos )           { return modifiers[pos]; }
        public void setModifier ( int pos, bool val ) { modifiers[pos] = val; }

        public void add(MODIFIERS mods) {
            if (mods == null)
                return;
            this.modifiers.Or(mods.modifiers);
        }

        public bool Empty() {
            for ( int i=0, n=modifiers.Length; i<n; i++ )
                if (modifiers[i])
                    return false;
            return true;
        }

        public bool Private    { get { return modifiers[posPrivate]; }    set { modifiers[posPrivate] = value; } }
        public bool Public     { get { return modifiers[posPublic]; }     set { modifiers[posPublic] = value; } }
        public bool Sealed     { get { return modifiers[posSealed]; }     set { modifiers[posSealed] = value; } }
        public bool Immutable  { get { return modifiers[posImmutable]; }  set { modifiers[posImmutable] = value; } }
        public bool Reference  { get { return modifiers[posReference]; }  set { modifiers[posReference] = value; } }
        public bool Value      { get { return modifiers[posValue]; }      set { modifiers[posValue] = value; } }
        public bool Locked     { get { return modifiers[posLocked]; }     set { modifiers[posLocked] = value; } }
        public bool Concurrent { get { return modifiers[posConcurrent]; } set { modifiers[posConcurrent] = value; } }
        public bool Barrier    { get { return modifiers[posBarrier]; }    set { modifiers[posBarrier] = value; } }
        public bool Getter     { get { return modifiers[posGetter]; }     set { modifiers[posGetter] = value; } }
        public bool Setter     { get { return modifiers[posSetter]; }     set { modifiers[posSetter] = value; } }
		public bool Protected  { get { return modifiers[posProtected]; }  set { modifiers[posProtected] = value; } }
		public bool Shared     { get { return modifiers[posShared]; }     set { modifiers[posShared] = value; } }
        public bool Actor      { get { return modifiers[posActor]; }      set { modifiers[posActor] = value; } }

     // public int  Precedence { get { return precedence; } set { precedence = value; }  }

        public void validate() {
            if ( (Public && Private)     ||
                 (Private && Immutable)  ||
                 (Value && Reference)    ||
                 (Locked && Concurrent ) || (Locked && Barrier) || (Concurrent && Barrier) )
                ERROR.IllegalModifier("(wrong combination)");
        }

        public override string ToString() {
            string result = "";
            if (Private)
                result += "private ";
            if (Public)
                result += "public ";
            if (Sealed)
                result += "sealed ";
            if (Immutable)
                result += "immutable ";
            if (Reference)
                result += "ref ";
            if (Value)
                result += "value ";
            if (Locked)
                result += "locked ";
            if (Concurrent)
                result += "concurrent ";
            if (Barrier)
                result += "barrier ";
            if (Getter)
                result += "get ";
            if (Setter)
                result += "set ";
            if (Protected)
                result += "protected ";
            if (Shared)
                result += "shared ";
            if ( Actor )      result += "actor ";
            return result;
        }
    }

    // SPARSE_TYPE
    // ==========
    // SPARSE_TYPE is a type to represent sparce vectors and matrices
    // Common syntax is as follows:
    //
    //   SparseType = array "{" sparse "}" Length { "," Length } of Type.
    //   Length = ConstExpression | "*" | Ident.
    //
    public sealed class SPARSE_TYPE : TYPE {
        // Constructor
        public SPARSE_TYPE() : base(ASTNodeType.SPARSE_TYPE) { dimensions = new EXPRESSION_LIST(); }

        //-------------------------------------------------------------------------------------

        public EXPRESSION_LIST dimensions;
        public TYPE base_type;
        public bool isVector;

        private static System.Compiler.Module module;

        //-------------------------------------------------------------------------------------

        public static SPARSE_TYPE create() {
            SPARSE_TYPE sparseType = new SPARSE_TYPE();

            sparseType.base_type = null;
            // sparseType.dimensions -- already initialized
            sparseType.enclosing = null;
            sparseType.modifiers = null;
            sparseType.name = null;
            // arrayType.sourceContext = Parser.LEXAN.getSourceContext(); -- already done in ctor

            module = CONTEXT.symbolTable;

            return sparseType;
        }

        public void finalize(TYPE elemType) {
            for (int i = 0, n = dimensions.Length; i < n; i++)
                if (dimensions[i] != null)
                    dimensions[i].enclosing = this;

            if (elemType == null)
                return;
            // This is because of an error in type.

            base_type = elemType;
            if (elemType.enclosing == null)
                elemType.enclosing = this;
        }

        //-------------------------------------------------------------------------------------

        public override NODE resolve() {
            for (int i = 0, n = dimensions.Length; i < n; i++)
                if (dimensions[i] != null)
                    dimensions[i].resolve();

            if (base_type != null)
                base_type = (TYPE)base_type.resolve();

            return this;
        }

        //-------------------------------------------------------------------------------------

        public override bool validate()  // checks semantical correctness
        {
            if (base_type == null)
                return false;
            if (!base_type.validate())
                return false;

            if ((dimensions.Length != 1) && (dimensions.Length != 2))
                return false;

            for (int i = 0, n = dimensions.Length; i < n; i++) {
                EXPRESSION dim = dimensions[i];

                if (dim == null)
                    continue;
                if (!dim.validate())
                    return false;
                if (!(dim.type is INTEGER_TYPE) && !(dim.type is CARDINAL_TYPE) && !dim.ErrorReported) {
                    ERROR.IllegalTypeOf(dim.type.ToString(),
                                        "array dimension " + (i + 1).ToString(),
                                        dim.sourceContext);
                    dim.ErrorReported = true;
                    return false;
                }
            }
            return true;
        }

        //-------------------------------------------------------------------------------------

        public override TYPE type { get { return this; } set { } } // evaluates type 

        //--------------------------------------------------------------------------------------

        public override bool checkVisibility(SourceContext context) {
            if (base_type == null)
                return false;
            return base_type.checkVisibility(context);
        }
        //--------------------------------------------------------------------------------------

        public Node getConstructionCall(EXPRESSION_LIST arguments) {
            Construct constrSparse = new Construct();
            if (!isVector) {
                constrSparse.Type = STANDARD.SparseMatrix.GetTemplateInstance(
                            module, base_type.convert() as TypeNode);

                if (arguments.Length == 6) {
                    constrSparse.Constructor = new MemberBinding(null,
                            constrSparse.Type.GetConstructors()[1]);
                } else if (arguments.Length == 5) {
                    constrSparse.Constructor = new MemberBinding(null,
                            constrSparse.Type.GetConstructors()[2]);
                } else if (arguments.Length == 3) {
                    constrSparse.Constructor = new MemberBinding(null,
                            constrSparse.Type.GetConstructors()[3]);
                } else if (arguments.Length == 2) {
                    constrSparse.Constructor = new MemberBinding(null,
                            constrSparse.Type.GetConstructors()[4]);
                } else {
                    //ERROR!
                    return null;
                }
            } else {
                constrSparse.Type = STANDARD.SparseVector.GetTemplateInstance(
                            module, base_type.convert() as TypeNode);

                if (arguments.Length == 4) {
                    constrSparse.Constructor = new MemberBinding(null,
                            constrSparse.Type.GetConstructors()[1]);
                } else if (arguments.Length == 3) {
                    constrSparse.Constructor = new MemberBinding(null,
                            constrSparse.Type.GetConstructors()[2]);
                } else if (arguments.Length == 2) {
                    constrSparse.Constructor = new MemberBinding(null,
                            constrSparse.Type.GetConstructors()[3]);
                } else if (arguments.Length == 1) {
                    constrSparse.Constructor = new MemberBinding(null,
                            constrSparse.Type.GetConstructors()[4]);
                } else {
                    //ERROR!
                    return null;
                }
            }

            constrSparse.SourceContext = sourceContext;
            constrSparse.Operands = new ExpressionList();

            constrSparse.Operands.Add(new Literal(
                sourceContext.StartLine, SystemTypes.Int64));
            constrSparse.Operands.Add(new Literal(
                sourceContext.StartColumn, SystemTypes.Int32));
            for (int i = 0, n = arguments.Length; i < n; i++)
                constrSparse.Operands.Add((Expression)arguments[i].convert());

            return constrSparse;
        }

        //--------------------------------------------------------------------------------------

        public override Node convert() // generates equivalent CCI sub-tree
        {
            if (node != null)
                return node;
            resolve();
            if (!validate())
                return null;

            if (!isVector) {
                //node = STANDARD.SparseMatrix;
                node = STANDARD.SparseMatrix.GetTemplateInstance(module, base_type.convert() as TypeNode);
            } else {
                //node = STANDARD.SparseVector;
                node = STANDARD.SparseVector.GetTemplateInstance(module, base_type.convert() as TypeNode);
            }

            return node;
        }

        //-------------------------------------------------------------------------------------

        public override string ToString() {
            string dims = "";
            for (int i = 0, n = dimensions.Length; i < n; i++) {
                if (dimensions[i] != null) {
                    object val = dimensions[i].calculate();
                    if (val != null)
                        dims += val.ToString();
                    else
                        dims += "*";
                } else
                    dims += "*";

                if (i < n - 1)
                    dims += ",";
            }

            string elem = base_type != null ? base_type.ToString() : "unknown type";

            return "array {sparse} " + dims + " of " + elem;
        }

        //--------------------------------------------------------------------------------------
#if DEBUG
        public override void report(int shift) {
            report_unique(shift);
            System.Console.Write("SPARSE TYPE [{0}]", dimensions.Length);
            report_extra();

            NODE.doShift(shift + NODE.reportShift);
            System.Console.WriteLine("BASE TYPE:");
            if (base_type == null) // because of an error
            {
                NODE.doShift(shift + 2 * NODE.reportShift);
                System.Console.WriteLine("<NO TYPE>");
            } else
                base_type.report(shift + 2 * NODE.reportShift);

            NODE.doShift(shift + NODE.reportShift);
            System.Console.WriteLine("DIMENSIONS: {0}", dimensions.Length);
            for (int i = 0, n = dimensions.Length; i < n; i++) {
                if (dimensions[i] == null) {
                    NODE.doShift(shift + 2 * NODE.reportShift);
                    System.Console.WriteLine("*");
                } else {
                    dimensions[i].report(shift + 2 * NODE.reportShift);
                }
            }
        }
#endif
    }

    //sealed class MATH_TYPE : TYPE {

    //    public TYPE BaseType;
    //    public ComputeType? Details;

    //    public MATH_TYPE(TYPE baseType)
    //        : base(ASTNodeType.MATH_TYPE) {
    //        BaseType = baseType;
    //    }

    //    void resolveDetails() {
    //        if (Details == null && BaseType != null) {
    //            ARRAY_TYPE baseArrayType;
    //            ComputeScalarType computeType;
    //            if (BaseType.Is(out baseArrayType)) {
    //                if (ComputeScalarType.TryGet(baseArrayType.base_type, out computeType)) {
    //                    Details = new ComputeType(computeType, baseArrayType.dimensions.Length);
    //                }
    //            } else if (ComputeScalarType.TryGet(BaseType, out computeType)) {
    //                Details = new ComputeType(computeType, 0);
    //            }
    //        }
    //    }


    //    public override NODE resolve() {
    //        if (BaseType != null) {
    //            BaseType = (TYPE)BaseType.resolve();
    //        }
    //        resolveDetails();
    //        return this;
    //    }

    //    public override bool validate() {
    //        if (BaseType == null || !BaseType.validate()) {
    //            return false;
    //        }
    //        resolveDetails();
    //        return Details != null;
    //    }

    //    public override TYPE type {
    //        get {
    //            return this;
    //        }
    //        set {
    //            throw new NotImplementedException();
    //        }
    //    }

    //    public override Node convert() {
    //        return STANDARD.Data;
    //    }

    //    public override bool checkVisibility(SourceContext context) {
    //        return BaseType != null && BaseType.checkVisibility(context);
    //    }

    //    public override void report(int shift) {
    //        // TODO (be)
    //        BaseType.report(shift);
    //    }

    //    public override string ToString() {
    //        String baseString;
    //        if (BaseType != null) {
    //            baseString = BaseType.ToString();
    //        } else {
    //            baseString = "unknown type";
    //        }
    //        baseString += " {math}";
    //        return baseString;
    //    }

    //    public static Boolean IsAnyMathType(TYPE type1, TYPE type2, out Boolean correct) {
    //        TYPE nonMathType1;
    //        TYPE nonMathType2;
    //        MATH_TYPE mathType1;
    //        MATH_TYPE mathType2;
    //        Boolean isMathType1 = type1.Is(out mathType1);
    //        Boolean isMathType2 = type2.type.Is(out mathType2);
    //        if (isMathType1) {
    //            nonMathType1 = mathType1.BaseType;
    //        } else {
    //            nonMathType1 = type1;
    //        }
    //        if (isMathType2) {
    //            nonMathType2 = mathType2.BaseType;
    //        } else {
    //            nonMathType2 = type2;
    //        }
    //        if (isMathType1 || isMathType2) {
    //            correct = TYPE.sameType(nonMathType1, nonMathType2);
    //            return true;
    //        } else {
    //            correct = false;
    //            return false;
    //        }
    //    }

    //    public static MathTypeCheckResult? CheckElementWise(TYPE type1, TYPE type2, MathTypeCheckErrorInfo? errorInfo) {
    //        MATH_TYPE mathType1;
    //        MATH_TYPE mathType2;
    //        Boolean IsMathType1 = type1.Is(out mathType1);
    //        Boolean IsMathType2 = type2.Is(out mathType2);
    //        MathTypeCheckErrorInfo info;
    //        if (IsMathType1 && IsMathType2) {
    //            Int32 rank1 = mathType1.Details.Value.Rank;
    //            Int32 rank2 = mathType2.Details.Value.Rank;
    //            if (rank1 == 0) {
    //                return new MathTypeCheckResult(type2);
    //            } else if (rank2 == 0 || rank1 == rank2) {
    //                return new MathTypeCheckResult(type1);
    //            } else {
    //                if (errorInfo.TryGetValue(out info)) {
    //                    ERROR.IncompatibleMathTypes(info.SourceContext, type1.ToString(), type2.ToString(), info.Op);
    //                }
    //                return new MathTypeCheckResult(null);
    //            }
    //        } else if (IsMathType1) {
    //            if (errorInfo.TryGetValue(out info)) {
    //                ERROR.ArrayNotMath(info.SourceContext, info.Op, type2.ToString());
    //            }
    //            return new MathTypeCheckResult(null);
    //        } else if (IsMathType2) {
    //            if (errorInfo.TryGetValue(out info)) {
    //                ERROR.ArrayNotMath(info.SourceContext, info.Op, type1.ToString());
    //            }
    //            return new MathTypeCheckResult(null);
    //        } else {
    //            return null;
    //        }
    //    }
    //}
}  // namespace ETH.Zonnon.Compiler
